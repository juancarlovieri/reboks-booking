// ==UserScript==
// @name     React Userscripts
// @namespace https://github.com/siefkenj/react-userscripts
// @version  1.1
// @description A sample userscript built using react
// @include *://reboks.nus.edu.sg/*
// ==/UserScript==


(function() {
  "use strict";
  function _mergeNamespaces(n2, m2) {
    for (var i = 0; i < m2.length; i++) {
      const e2 = m2[i];
      if (typeof e2 !== "string" && !Array.isArray(e2)) {
        for (const k2 in e2) {
          if (k2 !== "default" && !(k2 in n2)) {
            const d2 = Object.getOwnPropertyDescriptor(e2, k2);
            if (d2) {
              Object.defineProperty(n2, k2, d2.get ? d2 : {
                enumerable: true,
                get: () => e2[k2]
              });
            }
          }
        }
      }
    }
    return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function getAugmentedNamespace(n2) {
    if (n2.__esModule)
      return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a.prototype = f2.prototype;
    } else
      a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n2).forEach(function(k2) {
      var d2 = Object.getOwnPropertyDescriptor(n2, k2);
      Object.defineProperty(a, k2, d2.get ? d2 : {
        enumerable: true,
        get: function() {
          return n2[k2];
        }
      });
    });
    return a;
  }
  var react = { exports: {} };
  var react_production_min = {};
  /**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var l$3 = Symbol.for("react.element"), n$3 = Symbol.for("react.portal"), p$4 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
  function A$2(a) {
    if (null === a || "object" !== typeof a)
      return null;
    a = z$2 && a[z$2] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var B$1 = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C$1 = Object.assign, D$1 = {};
  function E$1(a, b2, e2) {
    this.props = a;
    this.context = b2;
    this.refs = D$1;
    this.updater = e2 || B$1;
  }
  E$1.prototype.isReactComponent = {};
  E$1.prototype.setState = function(a, b2) {
    if ("object" !== typeof a && "function" !== typeof a && null != a)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b2, "setState");
  };
  E$1.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E$1.prototype;
  function G$1(a, b2, e2) {
    this.props = a;
    this.context = b2;
    this.refs = D$1;
    this.updater = e2 || B$1;
  }
  var H$1 = G$1.prototype = new F();
  H$1.constructor = G$1;
  C$1(H$1, E$1.prototype);
  H$1.isPureReactComponent = true;
  var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
  function M$1(a, b2, e2) {
    var d2, c2 = {}, k2 = null, h2 = null;
    if (null != b2)
      for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
        J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
    var g2 = arguments.length - 2;
    if (1 === g2)
      c2.children = e2;
    else if (1 < g2) {
      for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
        f2[m2] = arguments[m2 + 2];
      c2.children = f2;
    }
    if (a && a.defaultProps)
      for (d2 in g2 = a.defaultProps, g2)
        void 0 === c2[d2] && (c2[d2] = g2[d2]);
    return { $$typeof: l$3, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
  }
  function N$1(a, b2) {
    return { $$typeof: l$3, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
  }
  function O$1(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l$3;
  }
  function escape(a) {
    var b2 = { "=": "=0", ":": "=2" };
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b2[a2];
    });
  }
  var P$1 = /\/+/g;
  function Q$1(a, b2) {
    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
  }
  function R$1(a, b2, e2, d2, c2) {
    var k2 = typeof a;
    if ("undefined" === k2 || "boolean" === k2)
      a = null;
    var h2 = false;
    if (null === a)
      h2 = true;
    else
      switch (k2) {
        case "string":
        case "number":
          h2 = true;
          break;
        case "object":
          switch (a.$$typeof) {
            case l$3:
            case n$3:
              h2 = true;
          }
      }
    if (h2)
      return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
        return a2;
      })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
    h2 = 0;
    d2 = "" === d2 ? "." : d2 + ":";
    if (I$1(a))
      for (var g2 = 0; g2 < a.length; g2++) {
        k2 = a[g2];
        var f2 = d2 + Q$1(k2, g2);
        h2 += R$1(k2, b2, e2, f2, c2);
      }
    else if (f2 = A$2(a), "function" === typeof f2)
      for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
        k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
    else if ("object" === k2)
      throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
    return h2;
  }
  function S$1(a, b2, e2) {
    if (null == a)
      return a;
    var d2 = [], c2 = 0;
    R$1(a, d2, "", "", function(a2) {
      return b2.call(e2, a2, c2++);
    });
    return d2;
  }
  function T$1(a) {
    if (-1 === a._status) {
      var b2 = a._result;
      b2 = b2();
      b2.then(function(b3) {
        if (0 === a._status || -1 === a._status)
          a._status = 1, a._result = b3;
      }, function(b3) {
        if (0 === a._status || -1 === a._status)
          a._status = 2, a._result = b3;
      });
      -1 === a._status && (a._status = 0, a._result = b2);
    }
    if (1 === a._status)
      return a._result.default;
    throw a._result;
  }
  var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
  function X$1() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
    S$1(a, function() {
      b2.apply(this, arguments);
    }, e2);
  }, count: function(a) {
    var b2 = 0;
    S$1(a, function() {
      b2++;
    });
    return b2;
  }, toArray: function(a) {
    return S$1(a, function(a2) {
      return a2;
    }) || [];
  }, only: function(a) {
    if (!O$1(a))
      throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  } };
  react_production_min.Component = E$1;
  react_production_min.Fragment = p$4;
  react_production_min.Profiler = r$2;
  react_production_min.PureComponent = G$1;
  react_production_min.StrictMode = q$3;
  react_production_min.Suspense = w$1;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
  react_production_min.act = X$1;
  react_production_min.cloneElement = function(a, b2, e2) {
    if (null === a || void 0 === a)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
    if (null != b2) {
      void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
      void 0 !== b2.key && (c2 = "" + b2.key);
      if (a.type && a.type.defaultProps)
        var g2 = a.type.defaultProps;
      for (f2 in b2)
        J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
    }
    var f2 = arguments.length - 2;
    if (1 === f2)
      d2.children = e2;
    else if (1 < f2) {
      g2 = Array(f2);
      for (var m2 = 0; m2 < f2; m2++)
        g2[m2] = arguments[m2 + 2];
      d2.children = g2;
    }
    return { $$typeof: l$3, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
  };
  react_production_min.createContext = function(a) {
    a = { $$typeof: u$1, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a.Provider = { $$typeof: t$2, _context: a };
    return a.Consumer = a;
  };
  react_production_min.createElement = M$1;
  react_production_min.createFactory = function(a) {
    var b2 = M$1.bind(null, a);
    b2.type = a;
    return b2;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a) {
    return { $$typeof: v$3, render: a };
  };
  react_production_min.isValidElement = O$1;
  react_production_min.lazy = function(a) {
    return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$1 };
  };
  react_production_min.memo = function(a, b2) {
    return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
  };
  react_production_min.startTransition = function(a) {
    var b2 = V$1.transition;
    V$1.transition = {};
    try {
      a();
    } finally {
      V$1.transition = b2;
    }
  };
  react_production_min.unstable_act = X$1;
  react_production_min.useCallback = function(a, b2) {
    return U$1.current.useCallback(a, b2);
  };
  react_production_min.useContext = function(a) {
    return U$1.current.useContext(a);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a) {
    return U$1.current.useDeferredValue(a);
  };
  react_production_min.useEffect = function(a, b2) {
    return U$1.current.useEffect(a, b2);
  };
  react_production_min.useId = function() {
    return U$1.current.useId();
  };
  react_production_min.useImperativeHandle = function(a, b2, e2) {
    return U$1.current.useImperativeHandle(a, b2, e2);
  };
  react_production_min.useInsertionEffect = function(a, b2) {
    return U$1.current.useInsertionEffect(a, b2);
  };
  react_production_min.useLayoutEffect = function(a, b2) {
    return U$1.current.useLayoutEffect(a, b2);
  };
  react_production_min.useMemo = function(a, b2) {
    return U$1.current.useMemo(a, b2);
  };
  react_production_min.useReducer = function(a, b2, e2) {
    return U$1.current.useReducer(a, b2, e2);
  };
  react_production_min.useRef = function(a) {
    return U$1.current.useRef(a);
  };
  react_production_min.useState = function(a) {
    return U$1.current.useState(a);
  };
  react_production_min.useSyncExternalStore = function(a, b2, e2) {
    return U$1.current.useSyncExternalStore(a, b2, e2);
  };
  react_production_min.useTransition = function() {
    return U$1.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  {
    react.exports = react_production_min;
  }
  var reactExports = react.exports;
  const React$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
  const React$2 = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: React$1
  }, [reactExports]);
  var reactDom = { exports: {} };
  var reactDom_production_min = {};
  var scheduler = { exports: {} };
  var scheduler_production_min = {};
  /**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function(exports) {
    function f2(a, b2) {
      var c2 = a.length;
      a.push(b2);
      a:
        for (; 0 < c2; ) {
          var d2 = c2 - 1 >>> 1, e2 = a[d2];
          if (0 < g2(e2, b2))
            a[d2] = b2, a[c2] = e2, c2 = d2;
          else
            break a;
        }
    }
    function h2(a) {
      return 0 === a.length ? null : a[0];
    }
    function k2(a) {
      if (0 === a.length)
        return null;
      var b2 = a[0], c2 = a.pop();
      if (c2 !== b2) {
        a[0] = c2;
        a:
          for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
            var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
            if (0 > g2(C2, c2))
              n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
            else if (n2 < e2 && 0 > g2(x2, c2))
              a[d2] = x2, a[n2] = c2, d2 = n2;
            else
              break a;
          }
      }
      return b2;
    }
    function g2(a, b2) {
      var c2 = a.sortIndex - b2.sortIndex;
      return 0 !== c2 ? c2 : a.id - b2.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l2 = performance;
      exports.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p2 = Date, q2 = p2.now();
      exports.unstable_now = function() {
        return p2.now() - q2;
      };
    }
    var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G2(a) {
      for (var b2 = h2(t2); null !== b2; ) {
        if (null === b2.callback)
          k2(t2);
        else if (b2.startTime <= a)
          k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
        else
          break;
        b2 = h2(t2);
      }
    }
    function H2(a) {
      B2 = false;
      G2(a);
      if (!A2)
        if (null !== h2(r2))
          A2 = true, I2(J2);
        else {
          var b2 = h2(t2);
          null !== b2 && K2(H2, b2.startTime - a);
        }
    }
    function J2(a, b2) {
      A2 = false;
      B2 && (B2 = false, E2(L2), L2 = -1);
      z2 = true;
      var c2 = y2;
      try {
        G2(b2);
        for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
          var d2 = v2.callback;
          if ("function" === typeof d2) {
            v2.callback = null;
            y2 = v2.priorityLevel;
            var e2 = d2(v2.expirationTime <= b2);
            b2 = exports.unstable_now();
            "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
            G2(b2);
          } else
            k2(r2);
          v2 = h2(r2);
        }
        if (null !== v2)
          var w2 = true;
        else {
          var m2 = h2(t2);
          null !== m2 && K2(H2, m2.startTime - b2);
          w2 = false;
        }
        return w2;
      } finally {
        v2 = null, y2 = c2, z2 = false;
      }
    }
    var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
    function M2() {
      return exports.unstable_now() - Q2 < P2 ? false : true;
    }
    function R2() {
      if (null !== O2) {
        var a = exports.unstable_now();
        Q2 = a;
        var b2 = true;
        try {
          b2 = O2(true, a);
        } finally {
          b2 ? S2() : (N2 = false, O2 = null);
        }
      } else
        N2 = false;
    }
    var S2;
    if ("function" === typeof F2)
      S2 = function() {
        F2(R2);
      };
    else if ("undefined" !== typeof MessageChannel) {
      var T2 = new MessageChannel(), U2 = T2.port2;
      T2.port1.onmessage = R2;
      S2 = function() {
        U2.postMessage(null);
      };
    } else
      S2 = function() {
        D2(R2, 0);
      };
    function I2(a) {
      O2 = a;
      N2 || (N2 = true, S2());
    }
    function K2(a, b2) {
      L2 = D2(function() {
        a(exports.unstable_now());
      }, b2);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A2 || z2 || (A2 = true, I2(J2));
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y2;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h2(r2);
    };
    exports.unstable_next = function(a) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b2 = 3;
          break;
        default:
          b2 = y2;
      }
      var c2 = y2;
      y2 = b2;
      try {
        return a();
      } finally {
        y2 = c2;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a, b2) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c2 = y2;
      y2 = a;
      try {
        return b2();
      } finally {
        y2 = c2;
      }
    };
    exports.unstable_scheduleCallback = function(a, b2, c2) {
      var d2 = exports.unstable_now();
      "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
      switch (a) {
        case 1:
          var e2 = -1;
          break;
        case 2:
          e2 = 250;
          break;
        case 5:
          e2 = 1073741823;
          break;
        case 4:
          e2 = 1e4;
          break;
        default:
          e2 = 5e3;
      }
      e2 = c2 + e2;
      a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
      c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
      return a;
    };
    exports.unstable_shouldYield = M2;
    exports.unstable_wrapCallback = function(a) {
      var b2 = y2;
      return function() {
        var c2 = y2;
        y2 = b2;
        try {
          return a.apply(this, arguments);
        } finally {
          y2 = c2;
        }
      };
    };
  })(scheduler_production_min);
  {
    scheduler.exports = scheduler_production_min;
  }
  var schedulerExports = scheduler.exports;
  /**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var aa = reactExports, ca = schedulerExports;
  function p$3(a) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
      b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a, b2) {
    ha(a, b2);
    ha(a + "Capture", b2);
  }
  function ha(a, b2) {
    ea[a] = b2;
    for (a = 0; a < b2.length; a++)
      da.add(b2[a]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a) {
    if (ja.call(ma, a))
      return true;
    if (ja.call(la, a))
      return false;
    if (ka.test(a))
      return ma[a] = true;
    la[a] = true;
    return false;
  }
  function pa(a, b2, c2, d2) {
    if (null !== c2 && 0 === c2.type)
      return false;
    switch (typeof b2) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d2)
          return false;
        if (null !== c2)
          return !c2.acceptsBooleans;
        a = a.toLowerCase().slice(0, 5);
        return "data-" !== a && "aria-" !== a;
      default:
        return false;
    }
  }
  function qa(a, b2, c2, d2) {
    if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2))
      return true;
    if (d2)
      return false;
    if (null !== c2)
      switch (c2.type) {
        case 3:
          return !b2;
        case 4:
          return false === b2;
        case 5:
          return isNaN(b2);
        case 6:
          return isNaN(b2) || 1 > b2;
      }
    return false;
  }
  function v$2(a, b2, c2, d2, e2, f2, g2) {
    this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
    this.attributeName = d2;
    this.attributeNamespace = e2;
    this.mustUseProperty = c2;
    this.propertyName = a;
    this.type = b2;
    this.sanitizeURL = f2;
    this.removeEmptyString = g2;
  }
  var z$1 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    z$1[a] = new v$2(a, 0, false, a, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b2 = a[0];
    z$1[b2] = new v$2(b2, 1, false, a[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    z$1[a] = new v$2(a, 2, false, a.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    z$1[a] = new v$2(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    z$1[a] = new v$2(a, 3, false, a.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    z$1[a] = new v$2(a, 3, true, a, null, false, false);
  });
  ["capture", "download"].forEach(function(a) {
    z$1[a] = new v$2(a, 4, false, a, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a) {
    z$1[a] = new v$2(a, 6, false, a, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a) {
    z$1[a] = new v$2(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b2 = a.replace(
      ra,
      sa
    );
    z$1[b2] = new v$2(b2, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b2 = a.replace(ra, sa);
    z$1[b2] = new v$2(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b2 = a.replace(ra, sa);
    z$1[b2] = new v$2(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a) {
    z$1[a] = new v$2(a, 1, false, a.toLowerCase(), null, false, false);
  });
  z$1.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a) {
    z$1[a] = new v$2(a, 1, false, a.toLowerCase(), null, true, true);
  });
  function ta(a, b2, c2, d2) {
    var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
    if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
      qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a) {
    if (null === a || "object" !== typeof a)
      return null;
    a = Ja && a[Ja] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var A$1 = Object.assign, La;
  function Ma(a) {
    if (void 0 === La)
      try {
        throw Error();
      } catch (c2) {
        var b2 = c2.stack.trim().match(/\n( *(at )?)/);
        La = b2 && b2[1] || "";
      }
    return "\n" + La + a;
  }
  var Na = false;
  function Oa(a, b2) {
    if (!a || Na)
      return "";
    Na = true;
    var c2 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b2)
        if (b2 = function() {
          throw Error();
        }, Object.defineProperty(b2.prototype, "props", { set: function() {
          throw Error();
        } }), "object" === typeof Reflect && Reflect.construct) {
          try {
            Reflect.construct(b2, []);
          } catch (l2) {
            var d2 = l2;
          }
          Reflect.construct(a, [], b2);
        } else {
          try {
            b2.call();
          } catch (l2) {
            d2 = l2;
          }
          a.call(b2.prototype);
        }
      else {
        try {
          throw Error();
        } catch (l2) {
          d2 = l2;
        }
        a();
      }
    } catch (l2) {
      if (l2 && d2 && "string" === typeof l2.stack) {
        for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
          h2--;
        for (; 1 <= g2 && 0 <= h2; g2--, h2--)
          if (e2[g2] !== f2[h2]) {
            if (1 !== g2 || 1 !== h2) {
              do
                if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                  var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                  a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                  return k2;
                }
              while (1 <= g2 && 0 <= h2);
            }
            break;
          }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c2;
    }
    return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
  }
  function Pa(a) {
    switch (a.tag) {
      case 5:
        return Ma(a.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Oa(a.type, false), a;
      case 11:
        return a = Oa(a.type.render, false), a;
      case 1:
        return a = Oa(a.type, true), a;
      default:
        return "";
    }
  }
  function Qa(a) {
    if (null == a)
      return null;
    if ("function" === typeof a)
      return a.displayName || a.name || null;
    if ("string" === typeof a)
      return a;
    switch (a) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a)
      switch (a.$$typeof) {
        case Ca:
          return (a.displayName || "Context") + ".Consumer";
        case Ba:
          return (a._context.displayName || "Context") + ".Provider";
        case Da:
          var b2 = a.render;
          a = a.displayName;
          a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          return a;
        case Ga:
          return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
        case Ha:
          b2 = a._payload;
          a = a._init;
          try {
            return Qa(a(b2));
          } catch (c2) {
          }
      }
    return null;
  }
  function Ra(a) {
    var b2 = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b2.displayName || "Context") + ".Consumer";
      case 10:
        return (b2._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b2;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b2);
      case 8:
        return b2 === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b2)
          return b2.displayName || b2.name || null;
        if ("string" === typeof b2)
          return b2;
    }
    return null;
  }
  function Sa(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ta(a) {
    var b2 = a.type;
    return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
  }
  function Ua(a) {
    var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
    if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
      var e2 = c2.get, f2 = c2.set;
      Object.defineProperty(a, b2, { configurable: true, get: function() {
        return e2.call(this);
      }, set: function(a2) {
        d2 = "" + a2;
        f2.call(this, a2);
      } });
      Object.defineProperty(a, b2, { enumerable: c2.enumerable });
      return { getValue: function() {
        return d2;
      }, setValue: function(a2) {
        d2 = "" + a2;
      }, stopTracking: function() {
        a._valueTracker = null;
        delete a[b2];
      } };
    }
  }
  function Va(a) {
    a._valueTracker || (a._valueTracker = Ua(a));
  }
  function Wa(a) {
    if (!a)
      return false;
    var b2 = a._valueTracker;
    if (!b2)
      return true;
    var c2 = b2.getValue();
    var d2 = "";
    a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
    a = d2;
    return a !== c2 ? (b2.setValue(a), true) : false;
  }
  function Xa(a) {
    a = a || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a)
      return null;
    try {
      return a.activeElement || a.body;
    } catch (b2) {
      return a.body;
    }
  }
  function Ya(a, b2) {
    var c2 = b2.checked;
    return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
  }
  function Za(a, b2) {
    var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
    c2 = Sa(null != b2.value ? b2.value : c2);
    a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
  }
  function ab(a, b2) {
    b2 = b2.checked;
    null != b2 && ta(a, "checked", b2, false);
  }
  function bb(a, b2) {
    ab(a, b2);
    var c2 = Sa(b2.value), d2 = b2.type;
    if (null != c2)
      if ("number" === d2) {
        if (0 === c2 && "" === a.value || a.value != c2)
          a.value = "" + c2;
      } else
        a.value !== "" + c2 && (a.value = "" + c2);
    else if ("submit" === d2 || "reset" === d2) {
      a.removeAttribute("value");
      return;
    }
    b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
    null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
  }
  function db(a, b2, c2) {
    if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
      var d2 = b2.type;
      if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
        return;
      b2 = "" + a._wrapperState.initialValue;
      c2 || b2 === a.value || (a.value = b2);
      a.defaultValue = b2;
    }
    c2 = a.name;
    "" !== c2 && (a.name = "");
    a.defaultChecked = !!a._wrapperState.initialChecked;
    "" !== c2 && (a.name = c2);
  }
  function cb(a, b2, c2) {
    if ("number" !== b2 || Xa(a.ownerDocument) !== a)
      null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
  }
  var eb = Array.isArray;
  function fb(a, b2, c2, d2) {
    a = a.options;
    if (b2) {
      b2 = {};
      for (var e2 = 0; e2 < c2.length; e2++)
        b2["$" + c2[e2]] = true;
      for (c2 = 0; c2 < a.length; c2++)
        e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
    } else {
      c2 = "" + Sa(c2);
      b2 = null;
      for (e2 = 0; e2 < a.length; e2++) {
        if (a[e2].value === c2) {
          a[e2].selected = true;
          d2 && (a[e2].defaultSelected = true);
          return;
        }
        null !== b2 || a[e2].disabled || (b2 = a[e2]);
      }
      null !== b2 && (b2.selected = true);
    }
  }
  function gb(a, b2) {
    if (null != b2.dangerouslySetInnerHTML)
      throw Error(p$3(91));
    return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function hb(a, b2) {
    var c2 = b2.value;
    if (null == c2) {
      c2 = b2.children;
      b2 = b2.defaultValue;
      if (null != c2) {
        if (null != b2)
          throw Error(p$3(92));
        if (eb(c2)) {
          if (1 < c2.length)
            throw Error(p$3(93));
          c2 = c2[0];
        }
        b2 = c2;
      }
      null == b2 && (b2 = "");
      c2 = b2;
    }
    a._wrapperState = { initialValue: Sa(c2) };
  }
  function ib(a, b2) {
    var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
    null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
    null != d2 && (a.defaultValue = "" + d2);
  }
  function jb(a) {
    var b2 = a.textContent;
    b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
  }
  function kb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a, b2) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
  }
  var mb, nb = function(a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(b2, c2, d2, e2);
      });
    } : a;
  }(function(a, b2) {
    if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
      a.innerHTML = b2;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
      for (b2 = mb.firstChild; a.firstChild; )
        a.removeChild(a.firstChild);
      for (; b2.firstChild; )
        a.appendChild(b2.firstChild);
    }
  });
  function ob(a, b2) {
    if (b2) {
      var c2 = a.firstChild;
      if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
        c2.nodeValue = b2;
        return;
      }
    }
    a.textContent = b2;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a) {
    qb.forEach(function(b2) {
      b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
      pb[b2] = pb[a];
    });
  });
  function rb(a, b2, c2) {
    return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
  }
  function sb(a, b2) {
    a = a.style;
    for (var c2 in b2)
      if (b2.hasOwnProperty(c2)) {
        var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
        "float" === c2 && (c2 = "cssFloat");
        d2 ? a.setProperty(c2, e2) : a[c2] = e2;
      }
  }
  var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a, b2) {
    if (b2) {
      if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
        throw Error(p$3(137, a));
      if (null != b2.dangerouslySetInnerHTML) {
        if (null != b2.children)
          throw Error(p$3(60));
        if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
          throw Error(p$3(61));
      }
      if (null != b2.style && "object" !== typeof b2.style)
        throw Error(p$3(62));
    }
  }
  function vb(a, b2) {
    if (-1 === a.indexOf("-"))
      return "string" === typeof b2.is;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a) {
    a = a.target || a.srcElement || window;
    a.correspondingUseElement && (a = a.correspondingUseElement);
    return 3 === a.nodeType ? a.parentNode : a;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a) {
    if (a = Cb(a)) {
      if ("function" !== typeof yb)
        throw Error(p$3(280));
      var b2 = a.stateNode;
      b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
    }
  }
  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
  }
  function Fb() {
    if (zb) {
      var a = zb, b2 = Ab;
      Ab = zb = null;
      Bb(a);
      if (b2)
        for (a = 0; a < b2.length; a++)
          Bb(b2[a]);
    }
  }
  function Gb(a, b2) {
    return a(b2);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a, b2, c2) {
    if (Ib)
      return a(b2, c2);
    Ib = true;
    try {
      return Gb(a, b2, c2);
    } finally {
      if (Ib = false, null !== zb || null !== Ab)
        Hb(), Fb();
    }
  }
  function Kb(a, b2) {
    var c2 = a.stateNode;
    if (null === c2)
      return null;
    var d2 = Db(c2);
    if (null === d2)
      return null;
    c2 = d2[b2];
    a:
      switch (b2) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
          a = !d2;
          break a;
        default:
          a = false;
      }
    if (a)
      return null;
    if (c2 && "function" !== typeof c2)
      throw Error(p$3(231, b2, typeof c2));
    return c2;
  }
  var Lb = false;
  if (ia)
    try {
      var Mb = {};
      Object.defineProperty(Mb, "passive", { get: function() {
        Lb = true;
      } });
      window.addEventListener("test", Mb, Mb);
      window.removeEventListener("test", Mb, Mb);
    } catch (a) {
      Lb = false;
    }
  function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b2.apply(c2, l2);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
    Ob = true;
    Pb = a;
  } };
  function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l2 = Pb;
        Ob = false;
        Pb = null;
      } else
        throw Error(p$3(198));
      Qb || (Qb = true, Rb = l2);
    }
  }
  function Vb(a) {
    var b2 = a, c2 = a;
    if (a.alternate)
      for (; b2.return; )
        b2 = b2.return;
    else {
      a = b2;
      do
        b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
      while (a);
    }
    return 3 === b2.tag ? c2 : null;
  }
  function Wb(a) {
    if (13 === a.tag) {
      var b2 = a.memoizedState;
      null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
      if (null !== b2)
        return b2.dehydrated;
    }
    return null;
  }
  function Xb(a) {
    if (Vb(a) !== a)
      throw Error(p$3(188));
  }
  function Yb(a) {
    var b2 = a.alternate;
    if (!b2) {
      b2 = Vb(a);
      if (null === b2)
        throw Error(p$3(188));
      return b2 !== a ? null : a;
    }
    for (var c2 = a, d2 = b2; ; ) {
      var e2 = c2.return;
      if (null === e2)
        break;
      var f2 = e2.alternate;
      if (null === f2) {
        d2 = e2.return;
        if (null !== d2) {
          c2 = d2;
          continue;
        }
        break;
      }
      if (e2.child === f2.child) {
        for (f2 = e2.child; f2; ) {
          if (f2 === c2)
            return Xb(e2), a;
          if (f2 === d2)
            return Xb(e2), b2;
          f2 = f2.sibling;
        }
        throw Error(p$3(188));
      }
      if (c2.return !== d2.return)
        c2 = e2, d2 = f2;
      else {
        for (var g2 = false, h2 = e2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = e2;
            d2 = f2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = e2;
            c2 = f2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) {
          for (h2 = f2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = f2;
              d2 = e2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = f2;
              c2 = e2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2)
            throw Error(p$3(189));
        }
      }
      if (c2.alternate !== d2)
        throw Error(p$3(190));
    }
    if (3 !== c2.tag)
      throw Error(p$3(188));
    return c2.stateNode.current === c2 ? a : b2;
  }
  function Zb(a) {
    a = Yb(a);
    return null !== a ? $b(a) : null;
  }
  function $b(a) {
    if (5 === a.tag || 6 === a.tag)
      return a;
    for (a = a.child; null !== a; ) {
      var b2 = $b(a);
      if (null !== b2)
        return b2;
      a = a.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a) {
    if (lc && "function" === typeof lc.onCommitFiberRoot)
      try {
        lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
      } catch (b2) {
      }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function uc(a, b2) {
    var c2 = a.pendingLanes;
    if (0 === c2)
      return 0;
    var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
    if (0 !== g2) {
      var h2 = g2 & ~e2;
      0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
    } else
      g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
    if (0 === d2)
      return 0;
    if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
      return b2;
    0 !== (d2 & 4) && (d2 |= c2 & 16);
    b2 = a.entangledLanes;
    if (0 !== b2)
      for (a = a.entanglements, b2 &= d2; 0 < b2; )
        c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
    return d2;
  }
  function vc(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return b2 + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b2 + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a, b2) {
    for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
      var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
      if (-1 === k2) {
        if (0 === (h2 & c2) || 0 !== (h2 & d2))
          e2[g2] = vc(h2, b2);
      } else
        k2 <= b2 && (a.expiredLanes |= h2);
      f2 &= ~h2;
    }
  }
  function xc(a) {
    a = a.pendingLanes & -1073741825;
    return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a;
  }
  function zc(a) {
    for (var b2 = [], c2 = 0; 31 > c2; c2++)
      b2.push(a);
    return b2;
  }
  function Ac(a, b2, c2) {
    a.pendingLanes |= b2;
    536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
    a = a.eventTimes;
    b2 = 31 - oc(b2);
    a[b2] = c2;
  }
  function Bc(a, b2) {
    var c2 = a.pendingLanes & ~b2;
    a.pendingLanes = b2;
    a.suspendedLanes = 0;
    a.pingedLanes = 0;
    a.expiredLanes &= b2;
    a.mutableReadLanes &= b2;
    a.entangledLanes &= b2;
    b2 = a.entanglements;
    var d2 = a.eventTimes;
    for (a = a.expirationTimes; 0 < c2; ) {
      var e2 = 31 - oc(c2), f2 = 1 << e2;
      b2[e2] = 0;
      d2[e2] = -1;
      a[e2] = -1;
      c2 &= ~f2;
    }
  }
  function Cc(a, b2) {
    var c2 = a.entangledLanes |= b2;
    for (a = a.entanglements; c2; ) {
      var d2 = 31 - oc(c2), e2 = 1 << d2;
      e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
      c2 &= ~e2;
    }
  }
  var C = 0;
  function Dc(a) {
    a &= -a;
    return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a, b2) {
    switch (a) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b2.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b2.pointerId);
    }
  }
  function Tc(a, b2, c2, d2, e2, f2) {
    if (null === a || a.nativeEvent !== f2)
      return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
    a.eventSystemFlags |= d2;
    b2 = a.targetContainers;
    null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
    return a;
  }
  function Uc(a, b2, c2, d2, e2) {
    switch (b2) {
      case "focusin":
        return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
      case "dragenter":
        return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
      case "mouseover":
        return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
      case "pointerover":
        var f2 = e2.pointerId;
        Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
        return true;
      case "gotpointercapture":
        return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
    }
    return false;
  }
  function Vc(a) {
    var b2 = Wc(a.target);
    if (null !== b2) {
      var c2 = Vb(b2);
      if (null !== c2) {
        if (b2 = c2.tag, 13 === b2) {
          if (b2 = Wb(c2), null !== b2) {
            a.blockedOn = b2;
            Ic(a.priority, function() {
              Gc(c2);
            });
            return;
          }
        } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Xc(a) {
    if (null !== a.blockedOn)
      return false;
    for (var b2 = a.targetContainers; 0 < b2.length; ) {
      var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
      if (null === c2) {
        c2 = a.nativeEvent;
        var d2 = new c2.constructor(c2.type, c2);
        wb = d2;
        c2.target.dispatchEvent(d2);
        wb = null;
      } else
        return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
      b2.shift();
    }
    return true;
  }
  function Zc(a, b2, c2) {
    Xc(a) && c2.delete(b2);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a, b2) {
    a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a) {
    function b2(b3) {
      return ad(b3, a);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a);
      for (var c2 = 1; c2 < Kc.length; c2++) {
        var d2 = Kc[c2];
        d2.blockedOn === a && (d2.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a);
    null !== Mc && ad(Mc, a);
    null !== Nc && ad(Nc, a);
    Oc.forEach(b2);
    Pc.forEach(b2);
    for (c2 = 0; c2 < Qc.length; c2++)
      d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
    for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
      Vc(c2), null === c2.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a, b2, c2, d2) {
    var e2 = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a, b2, c2, d2);
    } finally {
      C = e2, cd.transition = f2;
    }
  }
  function gd(a, b2, c2, d2) {
    var e2 = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a, b2, c2, d2);
    } finally {
      C = e2, cd.transition = f2;
    }
  }
  function fd(a, b2, c2, d2) {
    if (dd) {
      var e2 = Yc(a, b2, c2, d2);
      if (null === e2)
        hd(a, b2, d2, id, c2), Sc(a, d2);
      else if (Uc(e2, a, b2, c2, d2))
        d2.stopPropagation();
      else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
        for (; null !== e2; ) {
          var f2 = Cb(e2);
          null !== f2 && Ec(f2);
          f2 = Yc(a, b2, c2, d2);
          null === f2 && hd(a, b2, d2, id, c2);
          if (f2 === e2)
            break;
          e2 = f2;
        }
        null !== e2 && d2.stopPropagation();
      } else
        hd(a, b2, d2, null, c2);
    }
  }
  var id = null;
  function Yc(a, b2, c2, d2) {
    id = null;
    a = xb(d2);
    a = Wc(a);
    if (null !== a)
      if (b2 = Vb(a), null === b2)
        a = null;
      else if (c2 = b2.tag, 13 === c2) {
        a = Wb(b2);
        if (null !== a)
          return a;
        a = null;
      } else if (3 === c2) {
        if (b2.stateNode.current.memoizedState.isDehydrated)
          return 3 === b2.tag ? b2.stateNode.containerInfo : null;
        a = null;
      } else
        b2 !== a && (a = null);
    id = a;
    return null;
  }
  function jd(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md)
      return md;
    var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
    for (a = 0; a < c2 && b2[a] === e2[a]; a++)
      ;
    var g2 = c2 - a;
    for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
      ;
    return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
  }
  function od(a) {
    var b2 = a.keyCode;
    "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
    10 === a && (a = 13);
    return 32 <= a || 13 === a ? a : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a) {
    function b2(b3, d2, e2, f2, g2) {
      this._reactName = b3;
      this._targetInst = e2;
      this.type = d2;
      this.nativeEvent = f2;
      this.target = g2;
      this.currentTarget = null;
      for (var c2 in a)
        a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
      this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A$1(b2.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a2 = this.nativeEvent;
      a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a2 = this.nativeEvent;
      a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b2;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    if ("movementX" in a)
      return a.movementX;
    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
    return wd;
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : xd;
  } }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a) {
    var b2 = this.nativeEvent;
    return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A$1({}, ud, { key: function(a) {
    if (a.key) {
      var b2 = Md[a.key] || a.key;
      if ("Unidentified" !== b2)
        return b2;
    }
    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
    return "keypress" === a.type ? od(a) : 0;
  }, keyCode: function(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a, b2) {
    switch (a) {
      case "keyup":
        return -1 !== $d.indexOf(b2.keyCode);
      case "keydown":
        return 229 !== b2.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a) {
    a = a.detail;
    return "object" === typeof a && "data" in a ? a.data : null;
  }
  var ie = false;
  function je(a, b2) {
    switch (a) {
      case "compositionend":
        return he(b2);
      case "keypress":
        if (32 !== b2.which)
          return null;
        fe = true;
        return ee;
      case "textInput":
        return a = b2.data, a === ee && fe ? null : a;
      default:
        return null;
    }
  }
  function ke(a, b2) {
    if (ie)
      return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
          if (b2.char && 1 < b2.char.length)
            return b2.char;
          if (b2.which)
            return String.fromCharCode(b2.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b2.locale ? null : b2.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a) {
    var b2 = a && a.nodeName && a.nodeName.toLowerCase();
    return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
  }
  function ne(a, b2, c2, d2) {
    Eb(d2);
    b2 = oe(b2, "onChange");
    0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
  }
  var pe = null, qe = null;
  function re(a) {
    se(a, 0);
  }
  function te(a) {
    var b2 = ue(a);
    if (Wa(b2))
      return a;
  }
  function ve(a, b2) {
    if ("change" === a)
      return b2;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else
      xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a) {
    if ("value" === a.propertyName && te(qe)) {
      var b2 = [];
      ne(b2, qe, a, xb(a));
      Jb(re, b2);
    }
  }
  function Ce(a, b2, c2) {
    "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
  }
  function De(a) {
    if ("selectionchange" === a || "keyup" === a || "keydown" === a)
      return te(qe);
  }
  function Ee(a, b2) {
    if ("click" === a)
      return te(b2);
  }
  function Fe(a, b2) {
    if ("input" === a || "change" === a)
      return te(b2);
  }
  function Ge(a, b2) {
    return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a, b2) {
    if (He(a, b2))
      return true;
    if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
      return false;
    var c2 = Object.keys(a), d2 = Object.keys(b2);
    if (c2.length !== d2.length)
      return false;
    for (d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      if (!ja.call(b2, e2) || !He(a[e2], b2[e2]))
        return false;
    }
    return true;
  }
  function Je(a) {
    for (; a && a.firstChild; )
      a = a.firstChild;
    return a;
  }
  function Ke(a, b2) {
    var c2 = Je(a);
    a = 0;
    for (var d2; c2; ) {
      if (3 === c2.nodeType) {
        d2 = a + c2.textContent.length;
        if (a <= b2 && d2 >= b2)
          return { node: c2, offset: b2 - a };
        a = d2;
      }
      a: {
        for (; c2; ) {
          if (c2.nextSibling) {
            c2 = c2.nextSibling;
            break a;
          }
          c2 = c2.parentNode;
        }
        c2 = void 0;
      }
      c2 = Je(c2);
    }
  }
  function Le(a, b2) {
    return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
  }
  function Me() {
    for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
      try {
        var c2 = "string" === typeof b2.contentWindow.location.href;
      } catch (d2) {
        c2 = false;
      }
      if (c2)
        a = b2.contentWindow;
      else
        break;
      b2 = Xa(a.document);
    }
    return b2;
  }
  function Ne(a) {
    var b2 = a && a.nodeName && a.nodeName.toLowerCase();
    return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
  }
  function Oe(a) {
    var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
    if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
      if (null !== d2 && Ne(c2)) {
        if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2)
          c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
        else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
          d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
          !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
          e2 = Ke(c2, f2);
          var g2 = Ke(
            c2,
            d2
          );
          e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
        }
      }
      b2 = [];
      for (a = c2; a = a.parentNode; )
        1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      "function" === typeof c2.focus && c2.focus();
      for (c2 = 0; c2 < b2.length; c2++)
        a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a, b2, c2) {
    var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
    Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
  }
  function Ve(a, b2) {
    var c2 = {};
    c2[a.toLowerCase()] = b2.toLowerCase();
    c2["Webkit" + a] = "webkit" + b2;
    c2["Moz" + a] = "moz" + b2;
    return c2;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a) {
    if (Xe[a])
      return Xe[a];
    if (!We[a])
      return a;
    var b2 = We[a], c2;
    for (c2 in b2)
      if (b2.hasOwnProperty(c2) && c2 in Ye)
        return Xe[a] = b2[c2];
    return a;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a, b2) {
    df.set(a, b2);
    fa(b2, [a]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a, b2, c2) {
    var d2 = a.type || "unknown-event";
    a.currentTarget = c2;
    Ub(d2, b2, void 0, a);
    a.currentTarget = null;
  }
  function se(a, b2) {
    b2 = 0 !== (b2 & 4);
    for (var c2 = 0; c2 < a.length; c2++) {
      var d2 = a[c2], e2 = d2.event;
      d2 = d2.listeners;
      a: {
        var f2 = void 0;
        if (b2)
          for (var g2 = d2.length - 1; 0 <= g2; g2--) {
            var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
            h2 = h2.listener;
            if (k2 !== f2 && e2.isPropagationStopped())
              break a;
            nf(e2, h2, l2);
            f2 = k2;
          }
        else
          for (g2 = 0; g2 < d2.length; g2++) {
            h2 = d2[g2];
            k2 = h2.instance;
            l2 = h2.currentTarget;
            h2 = h2.listener;
            if (k2 !== f2 && e2.isPropagationStopped())
              break a;
            nf(e2, h2, l2);
            f2 = k2;
          }
      }
    }
    if (Qb)
      throw a = Rb, Qb = false, Rb = null, a;
  }
  function D(a, b2) {
    var c2 = b2[of];
    void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
    var d2 = a + "__bubble";
    c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
  }
  function qf(a, b2, c2) {
    var d2 = 0;
    b2 && (d2 |= 4);
    pf(c2, a, d2, b2);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a) {
    if (!a[rf]) {
      a[rf] = true;
      da.forEach(function(b3) {
        "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
      });
      var b2 = 9 === a.nodeType ? a : a.ownerDocument;
      null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
    }
  }
  function pf(a, b2, c2, d2) {
    switch (jd(b2)) {
      case 1:
        var e2 = ed;
        break;
      case 4:
        e2 = gd;
        break;
      default:
        e2 = fd;
    }
    c2 = e2.bind(null, b2, c2, a);
    e2 = void 0;
    !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
    d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
  }
  function hd(a, b2, c2, d2, e2) {
    var f2 = d2;
    if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
      a:
        for (; ; ) {
          if (null === d2)
            return;
          var g2 = d2.tag;
          if (3 === g2 || 4 === g2) {
            var h2 = d2.stateNode.containerInfo;
            if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
              break;
            if (4 === g2)
              for (g2 = d2.return; null !== g2; ) {
                var k2 = g2.tag;
                if (3 === k2 || 4 === k2) {
                  if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                    return;
                }
                g2 = g2.return;
              }
            for (; null !== h2; ) {
              g2 = Wc(h2);
              if (null === g2)
                return;
              k2 = g2.tag;
              if (5 === k2 || 6 === k2) {
                d2 = f2 = g2;
                continue a;
              }
              h2 = h2.parentNode;
            }
          }
          d2 = d2.return;
        }
    Jb(function() {
      var d3 = f2, e3 = xb(c2), g3 = [];
      a: {
        var h3 = df.get(a);
        if (void 0 !== h3) {
          var k3 = td, n2 = a;
          switch (a) {
            case "keypress":
              if (0 === od(c2))
                break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              n2 = "focus";
              k3 = Fd;
              break;
            case "focusout":
              n2 = "blur";
              k3 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd;
              break;
            case "click":
              if (2 === c2.button)
                break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k3 = Hd;
              break;
            case cf:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td;
          }
          var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
          t2 = [];
          for (var w2 = d3, u2; null !== w2; ) {
            u2 = w2;
            var F2 = u2.stateNode;
            5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
            if (J2)
              break;
            w2 = w2.return;
          }
          0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
        }
      }
      if (0 === (b2 & 7)) {
        a: {
          h3 = "mouseover" === a || "pointerover" === a;
          k3 = "mouseout" === a || "pointerout" === a;
          if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
            break a;
          if (k3 || h3) {
            h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k3) {
              if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
                n2 = null;
            } else
              k3 = null, n2 = d3;
            if (k3 !== n2) {
              t2 = Bd;
              F2 = "onMouseLeave";
              x2 = "onMouseEnter";
              w2 = "mouse";
              if ("pointerout" === a || "pointerover" === a)
                t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
              J2 = null == k3 ? h3 : ue(k3);
              u2 = null == n2 ? h3 : ue(n2);
              h3 = new t2(F2, w2 + "leave", k3, c2, e3);
              h3.target = J2;
              h3.relatedTarget = u2;
              F2 = null;
              Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
              J2 = F2;
              if (k3 && n2)
                b: {
                  t2 = k3;
                  x2 = n2;
                  w2 = 0;
                  for (u2 = t2; u2; u2 = vf(u2))
                    w2++;
                  u2 = 0;
                  for (F2 = x2; F2; F2 = vf(F2))
                    u2++;
                  for (; 0 < w2 - u2; )
                    t2 = vf(t2), w2--;
                  for (; 0 < u2 - w2; )
                    x2 = vf(x2), u2--;
                  for (; w2--; ) {
                    if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                      break b;
                    t2 = vf(t2);
                    x2 = vf(x2);
                  }
                  t2 = null;
                }
              else
                t2 = null;
              null !== k3 && wf(g3, h3, k3, t2, false);
              null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
            }
          }
        }
        a: {
          h3 = d3 ? ue(d3) : window;
          k3 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h3.type)
            var na = ve;
          else if (me(h3))
            if (we)
              na = Fe;
            else {
              na = De;
              var xa = Ce;
            }
          else
            (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
          if (na && (na = na(a, d3))) {
            ne(g3, na, c2, e3);
            break a;
          }
          xa && xa(a, h3, d3);
          "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
        }
        xa = d3 ? ue(d3) : window;
        switch (a) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable)
              Qe = xa, Re = d3, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g3, c2, e3);
            break;
          case "selectionchange":
            if (Pe)
              break;
          case "keydown":
          case "keyup":
            Ue(g3, c2, e3);
        }
        var $a;
        if (ae)
          b: {
            switch (a) {
              case "compositionstart":
                var ba = "onCompositionStart";
                break b;
              case "compositionend":
                ba = "onCompositionEnd";
                break b;
              case "compositionupdate":
                ba = "onCompositionUpdate";
                break b;
            }
            ba = void 0;
          }
        else
          ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a, c2) : ke(a, c2))
          d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
      }
      se(g3, b2);
    });
  }
  function tf(a, b2, c2) {
    return { instance: a, listener: b2, currentTarget: c2 };
  }
  function oe(a, b2) {
    for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
      var e2 = a, f2 = e2.stateNode;
      5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
      a = a.return;
    }
    return d2;
  }
  function vf(a) {
    if (null === a)
      return null;
    do
      a = a.return;
    while (a && 5 !== a.tag);
    return a ? a : null;
  }
  function wf(a, b2, c2, d2, e2) {
    for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
      var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
      if (null !== k2 && k2 === d2)
        break;
      5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
      c2 = c2.return;
    }
    0 !== g2.length && a.push({ event: b2, listeners: g2 });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a) {
    return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
  }
  function Af(a, b2, c2) {
    b2 = zf(b2);
    if (zf(a) !== b2 && c2)
      throw Error(p$3(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a, b2) {
    return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
  function If(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Kf(a, b2) {
    var c2 = b2, d2 = 0;
    do {
      var e2 = c2.nextSibling;
      a.removeChild(c2);
      if (e2 && 8 === e2.nodeType)
        if (c2 = e2.data, "/$" === c2) {
          if (0 === d2) {
            a.removeChild(e2);
            bd(b2);
            return;
          }
          d2--;
        } else
          "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
      c2 = e2;
    } while (c2);
    bd(b2);
  }
  function Lf(a) {
    for (; null != a; a = a.nextSibling) {
      var b2 = a.nodeType;
      if (1 === b2 || 3 === b2)
        break;
      if (8 === b2) {
        b2 = a.data;
        if ("$" === b2 || "$!" === b2 || "$?" === b2)
          break;
        if ("/$" === b2)
          return null;
      }
    }
    return a;
  }
  function Mf(a) {
    a = a.previousSibling;
    for (var b2 = 0; a; ) {
      if (8 === a.nodeType) {
        var c2 = a.data;
        if ("$" === c2 || "$!" === c2 || "$?" === c2) {
          if (0 === b2)
            return a;
          b2--;
        } else
          "/$" === c2 && b2++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a) {
    var b2 = a[Of];
    if (b2)
      return b2;
    for (var c2 = a.parentNode; c2; ) {
      if (b2 = c2[uf] || c2[Of]) {
        c2 = b2.alternate;
        if (null !== b2.child || null !== c2 && null !== c2.child)
          for (a = Mf(a); null !== a; ) {
            if (c2 = a[Of])
              return c2;
            a = Mf(a);
          }
        return b2;
      }
      a = c2;
      c2 = a.parentNode;
    }
    return null;
  }
  function Cb(a) {
    a = a[Of] || a[uf];
    return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
  }
  function ue(a) {
    if (5 === a.tag || 6 === a.tag)
      return a.stateNode;
    throw Error(p$3(33));
  }
  function Db(a) {
    return a[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a) {
    return { current: a };
  }
  function E(a) {
    0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a, b2) {
    Tf++;
    Sf[Tf] = a.current;
    a.current = b2;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a, b2) {
    var c2 = a.type.contextTypes;
    if (!c2)
      return Vf;
    var d2 = a.stateNode;
    if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
      return d2.__reactInternalMemoizedMaskedChildContext;
    var e2 = {}, f2;
    for (f2 in c2)
      e2[f2] = b2[f2];
    d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
    return e2;
  }
  function Zf(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }
  function $f() {
    E(Wf);
    E(H);
  }
  function ag(a, b2, c2) {
    if (H.current !== Vf)
      throw Error(p$3(168));
    G(H, b2);
    G(Wf, c2);
  }
  function bg(a, b2, c2) {
    var d2 = a.stateNode;
    b2 = b2.childContextTypes;
    if ("function" !== typeof d2.getChildContext)
      return c2;
    d2 = d2.getChildContext();
    for (var e2 in d2)
      if (!(e2 in b2))
        throw Error(p$3(108, Ra(a) || "Unknown", e2));
    return A$1({}, c2, d2);
  }
  function cg(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H.current;
    G(H, a);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a, b2, c2) {
    var d2 = a.stateNode;
    if (!d2)
      throw Error(p$3(169));
    c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
    G(Wf, c2);
  }
  var eg = null, fg = false, gg = false;
  function hg(a) {
    null === eg ? eg = [a] : eg.push(a);
  }
  function ig(a) {
    fg = true;
    hg(a);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a = 0, b2 = C;
      try {
        var c2 = eg;
        for (C = 1; a < c2.length; a++) {
          var d2 = c2[a];
          do
            d2 = d2(true);
          while (null !== d2);
        }
        eg = null;
        fg = false;
      } catch (e2) {
        throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
      } finally {
        C = b2, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a, b2) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a;
    ng = b2;
  }
  function ug(a, b2, c2) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a;
    var d2 = rg;
    a = sg;
    var e2 = 32 - oc(d2) - 1;
    d2 &= ~(1 << e2);
    c2 += 1;
    var f2 = 32 - oc(b2) + e2;
    if (30 < f2) {
      var g2 = e2 - e2 % 5;
      f2 = (d2 & (1 << g2) - 1).toString(32);
      d2 >>= g2;
      e2 -= g2;
      rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
      sg = f2 + a;
    } else
      rg = 1 << f2 | c2 << e2 | d2, sg = a;
  }
  function vg(a) {
    null !== a.return && (tg(a, 1), ug(a, 1, 0));
  }
  function wg(a) {
    for (; a === mg; )
      mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a === qg; )
      qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a, b2) {
    var c2 = Bg(5, null, null, 0);
    c2.elementType = "DELETED";
    c2.stateNode = b2;
    c2.return = a;
    b2 = a.deletions;
    null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
  }
  function Cg(a, b2) {
    switch (a.tag) {
      case 5:
        var c2 = a.type;
        b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
        return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
      case 6:
        return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
      case 13:
        return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a) {
    return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
  }
  function Eg(a) {
    if (I) {
      var b2 = yg;
      if (b2) {
        var c2 = b2;
        if (!Cg(a, b2)) {
          if (Dg(a))
            throw Error(p$3(418));
          b2 = Lf(c2.nextSibling);
          var d2 = xg;
          b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
        }
      } else {
        if (Dg(a))
          throw Error(p$3(418));
        a.flags = a.flags & -4097 | 2;
        I = false;
        xg = a;
      }
    }
  }
  function Fg(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
      a = a.return;
    xg = a;
  }
  function Gg(a) {
    if (a !== xg)
      return false;
    if (!I)
      return Fg(a), I = true, false;
    var b2;
    (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
    if (b2 && (b2 = yg)) {
      if (Dg(a))
        throw Hg(), Error(p$3(418));
      for (; b2; )
        Ag(a, b2), b2 = Lf(b2.nextSibling);
    }
    Fg(a);
    if (13 === a.tag) {
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a)
        throw Error(p$3(317));
      a: {
        a = a.nextSibling;
        for (b2 = 0; a; ) {
          if (8 === a.nodeType) {
            var c2 = a.data;
            if ("/$" === c2) {
              if (0 === b2) {
                yg = Lf(a.nextSibling);
                break a;
              }
              b2--;
            } else
              "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
          }
          a = a.nextSibling;
        }
        yg = null;
      }
    } else
      yg = xg ? Lf(a.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a = yg; a; )
      a = Lf(a.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a) {
    null === zg ? zg = [a] : zg.push(a);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a, b2, c2) {
    a = c2.ref;
    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c2._owner) {
        c2 = c2._owner;
        if (c2) {
          if (1 !== c2.tag)
            throw Error(p$3(309));
          var d2 = c2.stateNode;
        }
        if (!d2)
          throw Error(p$3(147, a));
        var e2 = d2, f2 = "" + a;
        if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
          return b2.ref;
        b2 = function(a2) {
          var b3 = e2.refs;
          null === a2 ? delete b3[f2] : b3[f2] = a2;
        };
        b2._stringRef = f2;
        return b2;
      }
      if ("string" !== typeof a)
        throw Error(p$3(284));
      if (!c2._owner)
        throw Error(p$3(290, a));
    }
    return a;
  }
  function Mg(a, b2) {
    a = Object.prototype.toString.call(b2);
    throw Error(p$3(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
  }
  function Ng(a) {
    var b2 = a._init;
    return b2(a._payload);
  }
  function Og(a) {
    function b2(b3, c3) {
      if (a) {
        var d3 = b3.deletions;
        null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
      }
    }
    function c2(c3, d3) {
      if (!a)
        return null;
      for (; null !== d3; )
        b2(c3, d3), d3 = d3.sibling;
      return null;
    }
    function d2(a2, b3) {
      for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
        null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
      return a2;
    }
    function e2(a2, b3) {
      a2 = Pg(a2, b3);
      a2.index = 0;
      a2.sibling = null;
      return a2;
    }
    function f2(b3, c3, d3) {
      b3.index = d3;
      if (!a)
        return b3.flags |= 1048576, c3;
      d3 = b3.alternate;
      if (null !== d3)
        return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
      b3.flags |= 2;
      return c3;
    }
    function g2(b3) {
      a && null === b3.alternate && (b3.flags |= 2);
      return b3;
    }
    function h2(a2, b3, c3, d3) {
      if (null === b3 || 6 !== b3.tag)
        return b3 = Qg(c3, a2.mode, d3), b3.return = a2, b3;
      b3 = e2(b3, c3);
      b3.return = a2;
      return b3;
    }
    function k2(a2, b3, c3, d3) {
      var f3 = c3.type;
      if (f3 === ya)
        return m2(a2, b3, c3.props.children, d3, c3.key);
      if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type))
        return d3 = e2(b3, c3.props), d3.ref = Lg(a2, b3, c3), d3.return = a2, d3;
      d3 = Rg(c3.type, c3.key, c3.props, null, a2.mode, d3);
      d3.ref = Lg(a2, b3, c3);
      d3.return = a2;
      return d3;
    }
    function l2(a2, b3, c3, d3) {
      if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
        return b3 = Sg(c3, a2.mode, d3), b3.return = a2, b3;
      b3 = e2(b3, c3.children || []);
      b3.return = a2;
      return b3;
    }
    function m2(a2, b3, c3, d3, f3) {
      if (null === b3 || 7 !== b3.tag)
        return b3 = Tg(c3, a2.mode, d3, f3), b3.return = a2, b3;
      b3 = e2(b3, c3);
      b3.return = a2;
      return b3;
    }
    function q2(a2, b3, c3) {
      if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
        return b3 = Qg("" + b3, a2.mode, c3), b3.return = a2, b3;
      if ("object" === typeof b3 && null !== b3) {
        switch (b3.$$typeof) {
          case va:
            return c3 = Rg(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = Lg(a2, null, b3), c3.return = a2, c3;
          case wa:
            return b3 = Sg(b3, a2.mode, c3), b3.return = a2, b3;
          case Ha:
            var d3 = b3._init;
            return q2(a2, d3(b3._payload), c3);
        }
        if (eb(b3) || Ka(b3))
          return b3 = Tg(b3, a2.mode, c3, null), b3.return = a2, b3;
        Mg(a2, b3);
      }
      return null;
    }
    function r2(a2, b3, c3, d3) {
      var e3 = null !== b3 ? b3.key : null;
      if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
        return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
      if ("object" === typeof c3 && null !== c3) {
        switch (c3.$$typeof) {
          case va:
            return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
          case wa:
            return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
          case Ha:
            return e3 = c3._init, r2(
              a2,
              b3,
              e3(c3._payload),
              d3
            );
        }
        if (eb(c3) || Ka(c3))
          return null !== e3 ? null : m2(a2, b3, c3, d3, null);
        Mg(a2, c3);
      }
      return null;
    }
    function y2(a2, b3, c3, d3, e3) {
      if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
        return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
      if ("object" === typeof d3 && null !== d3) {
        switch (d3.$$typeof) {
          case va:
            return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
          case wa:
            return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
          case Ha:
            var f3 = d3._init;
            return y2(a2, b3, c3, f3(d3._payload), e3);
        }
        if (eb(d3) || Ka(d3))
          return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
        Mg(b3, d3);
      }
      return null;
    }
    function n2(e3, g3, h3, k3) {
      for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
        u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
        var n3 = r2(e3, u2, h3[w2], k3);
        if (null === n3) {
          null === u2 && (u2 = x2);
          break;
        }
        a && u2 && null === n3.alternate && b2(e3, u2);
        g3 = f2(n3, g3, w2);
        null === m3 ? l3 = n3 : m3.sibling = n3;
        m3 = n3;
        u2 = x2;
      }
      if (w2 === h3.length)
        return c2(e3, u2), I && tg(e3, w2), l3;
      if (null === u2) {
        for (; w2 < h3.length; w2++)
          u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
        I && tg(e3, w2);
        return l3;
      }
      for (u2 = d2(e3, u2); w2 < h3.length; w2++)
        x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
      a && u2.forEach(function(a2) {
        return b2(e3, a2);
      });
      I && tg(e3, w2);
      return l3;
    }
    function t2(e3, g3, h3, k3) {
      var l3 = Ka(h3);
      if ("function" !== typeof l3)
        throw Error(p$3(150));
      h3 = l3.call(h3);
      if (null == h3)
        throw Error(p$3(151));
      for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
        m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
        var t3 = r2(e3, m3, n3.value, k3);
        if (null === t3) {
          null === m3 && (m3 = x2);
          break;
        }
        a && m3 && null === t3.alternate && b2(e3, m3);
        g3 = f2(t3, g3, w2);
        null === u2 ? l3 = t3 : u2.sibling = t3;
        u2 = t3;
        m3 = x2;
      }
      if (n3.done)
        return c2(
          e3,
          m3
        ), I && tg(e3, w2), l3;
      if (null === m3) {
        for (; !n3.done; w2++, n3 = h3.next())
          n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        I && tg(e3, w2);
        return l3;
      }
      for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
        n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      a && m3.forEach(function(a2) {
        return b2(e3, a2);
      });
      I && tg(e3, w2);
      return l3;
    }
    function J2(a2, d3, f3, h3) {
      "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
      if ("object" === typeof f3 && null !== f3) {
        switch (f3.$$typeof) {
          case va:
            a: {
              for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                if (l3.key === k3) {
                  k3 = f3.type;
                  if (k3 === ya) {
                    if (7 === l3.tag) {
                      c2(a2, l3.sibling);
                      d3 = e2(l3, f3.props.children);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                  } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                    c2(a2, l3.sibling);
                    d3 = e2(l3, f3.props);
                    d3.ref = Lg(a2, l3, f3);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                  c2(a2, l3);
                  break;
                } else
                  b2(a2, l3);
                l3 = l3.sibling;
              }
              f3.type === ya ? (d3 = Tg(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Lg(a2, d3, f3), h3.return = a2, a2 = h3);
            }
            return g2(a2);
          case wa:
            a: {
              for (l3 = f3.key; null !== d3; ) {
                if (d3.key === l3)
                  if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                    c2(a2, d3.sibling);
                    d3 = e2(d3, f3.children || []);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  } else {
                    c2(a2, d3);
                    break;
                  }
                else
                  b2(a2, d3);
                d3 = d3.sibling;
              }
              d3 = Sg(f3, a2.mode, h3);
              d3.return = a2;
              a2 = d3;
            }
            return g2(a2);
          case Ha:
            return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
        }
        if (eb(f3))
          return n2(a2, d3, f3, h3);
        if (Ka(f3))
          return t2(a2, d3, f3, h3);
        Mg(a2, f3);
      }
      return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = Qg(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
    }
    return J2;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a) {
    var b2 = Wg.current;
    E(Wg);
    a._currentValue = b2;
  }
  function bh(a, b2, c2) {
    for (; null !== a; ) {
      var d2 = a.alternate;
      (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
      if (a === c2)
        break;
      a = a.return;
    }
  }
  function ch(a, b2) {
    Xg = a;
    Zg = Yg = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (dh = true), a.firstContext = null);
  }
  function eh(a) {
    var b2 = a._currentValue;
    if (Zg !== a)
      if (a = { context: a, memoizedValue: b2, next: null }, null === Yg) {
        if (null === Xg)
          throw Error(p$3(308));
        Yg = a;
        Xg.dependencies = { lanes: 0, firstContext: a };
      } else
        Yg = Yg.next = a;
    return b2;
  }
  var fh = null;
  function gh(a) {
    null === fh ? fh = [a] : fh.push(a);
  }
  function hh(a, b2, c2, d2) {
    var e2 = b2.interleaved;
    null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
    b2.interleaved = c2;
    return ih(a, d2);
  }
  function ih(a, b2) {
    a.lanes |= b2;
    var c2 = a.alternate;
    null !== c2 && (c2.lanes |= b2);
    c2 = a;
    for (a = a.return; null !== a; )
      a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
    return 3 === c2.tag ? c2.stateNode : null;
  }
  var jh = false;
  function kh(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a, b2) {
    a = a.updateQueue;
    b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function mh(a, b2) {
    return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a, b2, c2) {
    var d2 = a.updateQueue;
    if (null === d2)
      return null;
    d2 = d2.shared;
    if (0 !== (K & 2)) {
      var e2 = d2.pending;
      null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
      d2.pending = b2;
      return ih(a, c2);
    }
    e2 = d2.interleaved;
    null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
    d2.interleaved = b2;
    return ih(a, c2);
  }
  function oh(a, b2, c2) {
    b2 = b2.updateQueue;
    if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
      var d2 = b2.lanes;
      d2 &= a.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc(a, c2);
    }
  }
  function ph(a, b2) {
    var c2 = a.updateQueue, d2 = a.alternate;
    if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
      var e2 = null, f2 = null;
      c2 = c2.firstBaseUpdate;
      if (null !== c2) {
        do {
          var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
          null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
          c2 = c2.next;
        } while (null !== c2);
        null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
      } else
        e2 = f2 = b2;
      c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
      a.updateQueue = c2;
      return;
    }
    a = c2.lastBaseUpdate;
    null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
    c2.lastBaseUpdate = b2;
  }
  function qh(a, b2, c2, d2) {
    var e2 = a.updateQueue;
    jh = false;
    var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
    if (null !== h2) {
      e2.shared.pending = null;
      var k2 = h2, l2 = k2.next;
      k2.next = null;
      null === g2 ? f2 = l2 : g2.next = l2;
      g2 = k2;
      var m2 = a.alternate;
      null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
    }
    if (null !== f2) {
      var q2 = e2.baseState;
      g2 = 0;
      m2 = l2 = k2 = null;
      h2 = f2;
      do {
        var r2 = h2.lane, y2 = h2.eventTime;
        if ((d2 & r2) === r2) {
          null !== m2 && (m2 = m2.next = {
            eventTime: y2,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n2 = a, t2 = h2;
            r2 = b2;
            y2 = c2;
            switch (t2.tag) {
              case 1:
                n2 = t2.payload;
                if ("function" === typeof n2) {
                  q2 = n2.call(y2, q2, r2);
                  break a;
                }
                q2 = n2;
                break a;
              case 3:
                n2.flags = n2.flags & -65537 | 128;
              case 0:
                n2 = t2.payload;
                r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                if (null === r2 || void 0 === r2)
                  break a;
                q2 = A$1({}, q2, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
        } else
          y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
        h2 = h2.next;
        if (null === h2)
          if (h2 = e2.shared.pending, null === h2)
            break;
          else
            r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
      } while (1);
      null === m2 && (k2 = q2);
      e2.baseState = k2;
      e2.firstBaseUpdate = l2;
      e2.lastBaseUpdate = m2;
      b2 = e2.shared.interleaved;
      if (null !== b2) {
        e2 = b2;
        do
          g2 |= e2.lane, e2 = e2.next;
        while (e2 !== b2);
      } else
        null === f2 && (e2.shared.lanes = 0);
      rh |= g2;
      a.lanes = g2;
      a.memoizedState = q2;
    }
  }
  function sh(a, b2, c2) {
    a = b2.effects;
    b2.effects = null;
    if (null !== a)
      for (b2 = 0; b2 < a.length; b2++) {
        var d2 = a[b2], e2 = d2.callback;
        if (null !== e2) {
          d2.callback = null;
          d2 = c2;
          if ("function" !== typeof e2)
            throw Error(p$3(191, e2));
          e2.call(d2);
        }
      }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a) {
    if (a === th)
      throw Error(p$3(174));
    return a;
  }
  function yh(a, b2) {
    G(wh, b2);
    G(vh, a);
    G(uh, th);
    a = b2.nodeType;
    switch (a) {
      case 9:
      case 11:
        b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
        break;
      default:
        a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
    }
    E(uh);
    G(uh, b2);
  }
  function zh() {
    E(uh);
    E(vh);
    E(wh);
  }
  function Ah(a) {
    xh(wh.current);
    var b2 = xh(uh.current);
    var c2 = lb(b2, a.type);
    b2 !== c2 && (G(vh, a), G(uh, c2));
  }
  function Bh(a) {
    vh.current === a && (E(uh), E(vh));
  }
  var L = Uf(0);
  function Ch(a) {
    for (var b2 = a; null !== b2; ) {
      if (13 === b2.tag) {
        var c2 = b2.memoizedState;
        if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
          return b2;
      } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
        if (0 !== (b2.flags & 128))
          return b2;
      } else if (null !== b2.child) {
        b2.child.return = b2;
        b2 = b2.child;
        continue;
      }
      if (b2 === a)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a)
          return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a = 0; a < Dh.length; a++)
      Dh[a]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P() {
    throw Error(p$3(321));
  }
  function Mh(a, b2) {
    if (null === b2)
      return false;
    for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
      if (!He(a[c2], b2[c2]))
        return false;
    return true;
  }
  function Nh(a, b2, c2, d2, e2, f2) {
    Hh = f2;
    M = b2;
    b2.memoizedState = null;
    b2.updateQueue = null;
    b2.lanes = 0;
    Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
    a = c2(d2, e2);
    if (Jh) {
      f2 = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f2)
          throw Error(p$3(301));
        f2 += 1;
        O = N = null;
        b2.updateQueue = null;
        Fh.current = Qh;
        a = c2(d2, e2);
      } while (Jh);
    }
    Fh.current = Rh;
    b2 = null !== N && null !== N.next;
    Hh = 0;
    O = N = M = null;
    Ih = false;
    if (b2)
      throw Error(p$3(300));
    return a;
  }
  function Sh() {
    var a = 0 !== Kh;
    Kh = 0;
    return a;
  }
  function Th() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
    return O;
  }
  function Uh() {
    if (null === N) {
      var a = M.alternate;
      a = null !== a ? a.memoizedState : null;
    } else
      a = N.next;
    var b2 = null === O ? M.memoizedState : O.next;
    if (null !== b2)
      O = b2, N = a;
    else {
      if (null === a)
        throw Error(p$3(310));
      N = a;
      a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
      null === O ? M.memoizedState = O = a : O = O.next = a;
    }
    return O;
  }
  function Vh(a, b2) {
    return "function" === typeof b2 ? b2(a) : b2;
  }
  function Wh(a) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2)
      throw Error(p$3(311));
    c2.lastRenderedReducer = a;
    var d2 = N, e2 = d2.baseQueue, f2 = c2.pending;
    if (null !== f2) {
      if (null !== e2) {
        var g2 = e2.next;
        e2.next = f2.next;
        f2.next = g2;
      }
      d2.baseQueue = e2 = f2;
      c2.pending = null;
    }
    if (null !== e2) {
      f2 = e2.next;
      d2 = d2.baseState;
      var h2 = g2 = null, k2 = null, l2 = f2;
      do {
        var m2 = l2.lane;
        if ((Hh & m2) === m2)
          null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
        else {
          var q2 = {
            lane: m2,
            action: l2.action,
            hasEagerState: l2.hasEagerState,
            eagerState: l2.eagerState,
            next: null
          };
          null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
          M.lanes |= m2;
          rh |= m2;
        }
        l2 = l2.next;
      } while (null !== l2 && l2 !== f2);
      null === k2 ? g2 = d2 : k2.next = h2;
      He(d2, b2.memoizedState) || (dh = true);
      b2.memoizedState = d2;
      b2.baseState = g2;
      b2.baseQueue = k2;
      c2.lastRenderedState = d2;
    }
    a = c2.interleaved;
    if (null !== a) {
      e2 = a;
      do
        f2 = e2.lane, M.lanes |= f2, rh |= f2, e2 = e2.next;
      while (e2 !== a);
    } else
      null === e2 && (c2.lanes = 0);
    return [b2.memoizedState, c2.dispatch];
  }
  function Xh(a) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2)
      throw Error(p$3(311));
    c2.lastRenderedReducer = a;
    var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
    if (null !== e2) {
      c2.pending = null;
      var g2 = e2 = e2.next;
      do
        f2 = a(f2, g2.action), g2 = g2.next;
      while (g2 !== e2);
      He(f2, b2.memoizedState) || (dh = true);
      b2.memoizedState = f2;
      null === b2.baseQueue && (b2.baseState = f2);
      c2.lastRenderedState = f2;
    }
    return [f2, d2];
  }
  function Yh() {
  }
  function Zh(a, b2) {
    var c2 = M, d2 = Uh(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
    f2 && (d2.memoizedState = e2, dh = true);
    d2 = d2.queue;
    $h(ai.bind(null, c2, d2, a), [a]);
    if (d2.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
      c2.flags |= 2048;
      bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
      if (null === Q)
        throw Error(p$3(349));
      0 !== (Hh & 30) || di(c2, b2, e2);
    }
    return e2;
  }
  function di(a, b2, c2) {
    a.flags |= 16384;
    a = { getSnapshot: b2, value: c2 };
    b2 = M.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
  }
  function ci(a, b2, c2, d2) {
    b2.value = c2;
    b2.getSnapshot = d2;
    ei(b2) && fi(a);
  }
  function ai(a, b2, c2) {
    return c2(function() {
      ei(b2) && fi(a);
    });
  }
  function ei(a) {
    var b2 = a.getSnapshot;
    a = a.value;
    try {
      var c2 = b2();
      return !He(a, c2);
    } catch (d2) {
      return true;
    }
  }
  function fi(a) {
    var b2 = ih(a, 1);
    null !== b2 && gi(b2, a, 1, -1);
  }
  function hi(a) {
    var b2 = Th();
    "function" === typeof a && (a = a());
    b2.memoizedState = b2.baseState = a;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
    b2.queue = a;
    a = a.dispatch = ii.bind(null, M, a);
    return [b2.memoizedState, a];
  }
  function bi(a, b2, c2, d2) {
    a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
    b2 = M.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
    return a;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a, b2, c2, d2) {
    var e2 = Th();
    M.flags |= a;
    e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
  }
  function li(a, b2, c2, d2) {
    var e2 = Uh();
    d2 = void 0 === d2 ? null : d2;
    var f2 = void 0;
    if (null !== N) {
      var g2 = N.memoizedState;
      f2 = g2.destroy;
      if (null !== d2 && Mh(d2, g2.deps)) {
        e2.memoizedState = bi(b2, c2, f2, d2);
        return;
      }
    }
    M.flags |= a;
    e2.memoizedState = bi(1 | b2, c2, f2, d2);
  }
  function mi(a, b2) {
    return ki(8390656, 8, a, b2);
  }
  function $h(a, b2) {
    return li(2048, 8, a, b2);
  }
  function ni(a, b2) {
    return li(4, 2, a, b2);
  }
  function oi(a, b2) {
    return li(4, 4, a, b2);
  }
  function pi(a, b2) {
    if ("function" === typeof b2)
      return a = a(), b2(a), function() {
        b2(null);
      };
    if (null !== b2 && void 0 !== b2)
      return a = a(), b2.current = a, function() {
        b2.current = null;
      };
  }
  function qi(a, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
    return li(4, 4, pi.bind(null, b2, a), c2);
  }
  function ri() {
  }
  function si(a, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1]))
      return d2[0];
    c2.memoizedState = [a, b2];
    return a;
  }
  function ti(a, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1]))
      return d2[0];
    a = a();
    c2.memoizedState = [a, b2];
    return a;
  }
  function ui(a, b2, c2) {
    if (0 === (Hh & 21))
      return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c2;
    He(c2, b2) || (c2 = yc(), M.lanes |= c2, rh |= c2, a.baseState = true);
    return b2;
  }
  function vi(a, b2) {
    var c2 = C;
    C = 0 !== c2 && 4 > c2 ? c2 : 4;
    a(true);
    var d2 = Gh.transition;
    Gh.transition = {};
    try {
      a(false), b2();
    } finally {
      C = c2, Gh.transition = d2;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a, b2, c2) {
    var d2 = yi(a);
    c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a))
      Ai(b2, c2);
    else if (c2 = hh(a, b2, c2, d2), null !== c2) {
      var e2 = R();
      gi(c2, a, d2, e2);
      Bi(c2, b2, d2);
    }
  }
  function ii(a, b2, c2) {
    var d2 = yi(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a))
      Ai(b2, e2);
    else {
      var f2 = a.alternate;
      if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
        try {
          var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
          e2.hasEagerState = true;
          e2.eagerState = h2;
          if (He(h2, g2)) {
            var k2 = b2.interleaved;
            null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
            b2.interleaved = e2;
            return;
          }
        } catch (l2) {
        } finally {
        }
      c2 = hh(a, b2, e2, d2);
      null !== c2 && (e2 = R(), gi(c2, a, d2, e2), Bi(c2, b2, d2));
    }
  }
  function zi(a) {
    var b2 = a.alternate;
    return a === M || null !== b2 && b2 === M;
  }
  function Ai(a, b2) {
    Jh = Ih = true;
    var c2 = a.pending;
    null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
    a.pending = b2;
  }
  function Bi(a, b2, c2) {
    if (0 !== (c2 & 4194240)) {
      var d2 = b2.lanes;
      d2 &= a.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc(a, c2);
    }
  }
  var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b2) {
    Th().memoizedState = [a, void 0 === b2 ? null : b2];
    return a;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
    return ki(
      4194308,
      4,
      pi.bind(null, b2, a),
      c2
    );
  }, useLayoutEffect: function(a, b2) {
    return ki(4194308, 4, a, b2);
  }, useInsertionEffect: function(a, b2) {
    return ki(4, 2, a, b2);
  }, useMemo: function(a, b2) {
    var c2 = Th();
    b2 = void 0 === b2 ? null : b2;
    a = a();
    c2.memoizedState = [a, b2];
    return a;
  }, useReducer: function(a, b2, c2) {
    var d2 = Th();
    b2 = void 0 !== c2 ? c2(b2) : b2;
    d2.memoizedState = d2.baseState = b2;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
    d2.queue = a;
    a = a.dispatch = xi.bind(null, M, a);
    return [d2.memoizedState, a];
  }, useRef: function(a) {
    var b2 = Th();
    a = { current: a };
    return b2.memoizedState = a;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
    return Th().memoizedState = a;
  }, useTransition: function() {
    var a = hi(false), b2 = a[0];
    a = vi.bind(null, a[1]);
    Th().memoizedState = a;
    return [b2, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, b2, c2) {
    var d2 = M, e2 = Th();
    if (I) {
      if (void 0 === c2)
        throw Error(p$3(407));
      c2 = c2();
    } else {
      c2 = b2();
      if (null === Q)
        throw Error(p$3(349));
      0 !== (Hh & 30) || di(d2, b2, c2);
    }
    e2.memoizedState = c2;
    var f2 = { value: c2, getSnapshot: b2 };
    e2.queue = f2;
    mi(ai.bind(
      null,
      d2,
      f2,
      a
    ), [a]);
    d2.flags |= 2048;
    bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
    return c2;
  }, useId: function() {
    var a = Th(), b2 = Q.identifierPrefix;
    if (I) {
      var c2 = sg;
      var d2 = rg;
      c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
      b2 = ":" + b2 + "R" + c2;
      c2 = Kh++;
      0 < c2 && (b2 += "H" + c2.toString(32));
      b2 += ":";
    } else
      c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
    return a.memoizedState = b2;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a) {
      var b2 = Uh();
      return ui(b2, N.memoizedState, a);
    },
    useTransition: function() {
      var a = Wh(Vh)[0], b2 = Uh().memoizedState;
      return [a, b2];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a) {
    var b2 = Uh();
    return null === N ? b2.memoizedState = a : ui(b2, N.memoizedState, a);
  }, useTransition: function() {
    var a = Xh(Vh)[0], b2 = Uh().memoizedState;
    return [a, b2];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a, b2) {
    if (a && a.defaultProps) {
      b2 = A$1({}, b2);
      a = a.defaultProps;
      for (var c2 in a)
        void 0 === b2[c2] && (b2[c2] = a[c2]);
      return b2;
    }
    return b2;
  }
  function Di(a, b2, c2, d2) {
    b2 = a.memoizedState;
    c2 = c2(d2, b2);
    c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
    a.memoizedState = c2;
    0 === a.lanes && (a.updateQueue.baseState = c2);
  }
  var Ei = { isMounted: function(a) {
    return (a = a._reactInternals) ? Vb(a) === a : false;
  }, enqueueSetState: function(a, b2, c2) {
    a = a._reactInternals;
    var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a, f2, e2);
    null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
  }, enqueueReplaceState: function(a, b2, c2) {
    a = a._reactInternals;
    var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
    f2.tag = 1;
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a, f2, e2);
    null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
  }, enqueueForceUpdate: function(a, b2) {
    a = a._reactInternals;
    var c2 = R(), d2 = yi(a), e2 = mh(c2, d2);
    e2.tag = 2;
    void 0 !== b2 && null !== b2 && (e2.callback = b2);
    b2 = nh(a, e2, d2);
    null !== b2 && (gi(b2, a, d2, c2), oh(b2, a, d2));
  } };
  function Fi(a, b2, c2, d2, e2, f2, g2) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
  }
  function Gi(a, b2, c2) {
    var d2 = false, e2 = Vf;
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
    b2 = new b2(c2, f2);
    a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
    b2.updater = Ei;
    a.stateNode = b2;
    b2._reactInternals = a;
    d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
    return b2;
  }
  function Hi(a, b2, c2, d2) {
    a = b2.state;
    "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
    "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
    b2.state !== a && Ei.enqueueReplaceState(b2, b2.state, null);
  }
  function Ii(a, b2, c2, d2) {
    var e2 = a.stateNode;
    e2.props = c2;
    e2.state = a.memoizedState;
    e2.refs = {};
    kh(a);
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
    e2.state = a.memoizedState;
    f2 = b2.getDerivedStateFromProps;
    "function" === typeof f2 && (Di(a, b2, f2, c2), e2.state = a.memoizedState);
    "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a, c2, e2, d2), e2.state = a.memoizedState);
    "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
  }
  function Ji(a, b2) {
    try {
      var c2 = "", d2 = b2;
      do
        c2 += Pa(d2), d2 = d2.return;
      while (d2);
      var e2 = c2;
    } catch (f2) {
      e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
    }
    return { value: a, source: b2, stack: e2, digest: null };
  }
  function Ki(a, b2, c2) {
    return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
  }
  function Li(a, b2) {
    try {
      console.error(b2.value);
    } catch (c2) {
      setTimeout(function() {
        throw c2;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    c2.payload = { element: null };
    var d2 = b2.value;
    c2.callback = function() {
      Oi || (Oi = true, Pi = d2);
      Li(a, b2);
    };
    return c2;
  }
  function Qi(a, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    var d2 = a.type.getDerivedStateFromError;
    if ("function" === typeof d2) {
      var e2 = b2.value;
      c2.payload = function() {
        return d2(e2);
      };
      c2.callback = function() {
        Li(a, b2);
      };
    }
    var f2 = a.stateNode;
    null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
      Li(a, b2);
      "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c3 = b2.stack;
      this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
    });
    return c2;
  }
  function Si(a, b2, c2) {
    var d2 = a.pingCache;
    if (null === d2) {
      d2 = a.pingCache = new Mi();
      var e2 = /* @__PURE__ */ new Set();
      d2.set(b2, e2);
    } else
      e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
    e2.has(c2) || (e2.add(c2), a = Ti.bind(null, a, b2, c2), b2.then(a, a));
  }
  function Ui(a) {
    do {
      var b2;
      if (b2 = 13 === a.tag)
        b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
      if (b2)
        return a;
      a = a.return;
    } while (null !== a);
    return null;
  }
  function Vi(a, b2, c2, d2, e2) {
    if (0 === (a.mode & 1))
      return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a;
    a.flags |= 65536;
    a.lanes = e2;
    return a;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a, b2, c2, d2) {
    b2.child = null === a ? Vg(b2, null, c2, d2) : Ug(b2, a.child, c2, d2);
  }
  function Yi(a, b2, c2, d2, e2) {
    c2 = c2.render;
    var f2 = b2.ref;
    ch(b2, e2);
    d2 = Nh(a, b2, c2, d2, f2, e2);
    c2 = Sh();
    if (null !== a && !dh)
      return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
    I && c2 && vg(b2);
    b2.flags |= 1;
    Xi(a, b2, d2, e2);
    return b2.child;
  }
  function $i(a, b2, c2, d2, e2) {
    if (null === a) {
      var f2 = c2.type;
      if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
        return b2.tag = 15, b2.type = f2, bj(a, b2, f2, d2, e2);
      a = Rg(c2.type, null, d2, b2, b2.mode, e2);
      a.ref = b2.ref;
      a.return = b2;
      return b2.child = a;
    }
    f2 = a.child;
    if (0 === (a.lanes & e2)) {
      var g2 = f2.memoizedProps;
      c2 = c2.compare;
      c2 = null !== c2 ? c2 : Ie;
      if (c2(g2, d2) && a.ref === b2.ref)
        return Zi(a, b2, e2);
    }
    b2.flags |= 1;
    a = Pg(f2, d2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  function bj(a, b2, c2, d2, e2) {
    if (null !== a) {
      var f2 = a.memoizedProps;
      if (Ie(f2, d2) && a.ref === b2.ref)
        if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2))
          0 !== (a.flags & 131072) && (dh = true);
        else
          return b2.lanes = a.lanes, Zi(a, b2, e2);
    }
    return cj(a, b2, c2, d2, e2);
  }
  function dj(a, b2, c2) {
    var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
    if ("hidden" === d2.mode)
      if (0 === (b2.mode & 1))
        b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
      else {
        if (0 === (c2 & 1073741824))
          return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a, null;
        b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
        d2 = null !== f2 ? f2.baseLanes : c2;
        G(ej, fj);
        fj |= d2;
      }
    else
      null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(ej, fj), fj |= d2;
    Xi(a, b2, e2, c2);
    return b2.child;
  }
  function gj(a, b2) {
    var c2 = b2.ref;
    if (null === a && null !== c2 || null !== a && a.ref !== c2)
      b2.flags |= 512, b2.flags |= 2097152;
  }
  function cj(a, b2, c2, d2, e2) {
    var f2 = Zf(c2) ? Xf : H.current;
    f2 = Yf(b2, f2);
    ch(b2, e2);
    c2 = Nh(a, b2, c2, d2, f2, e2);
    d2 = Sh();
    if (null !== a && !dh)
      return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
    I && d2 && vg(b2);
    b2.flags |= 1;
    Xi(a, b2, c2, e2);
    return b2.child;
  }
  function hj(a, b2, c2, d2, e2) {
    if (Zf(c2)) {
      var f2 = true;
      cg(b2);
    } else
      f2 = false;
    ch(b2, e2);
    if (null === b2.stateNode)
      ij(a, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
    else if (null === a) {
      var g2 = b2.stateNode, h2 = b2.memoizedProps;
      g2.props = h2;
      var k2 = g2.context, l2 = c2.contextType;
      "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
      var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
      q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
      jh = false;
      var r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e2);
      k2 = b2.memoizedState;
      h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
    } else {
      g2 = b2.stateNode;
      lh(a, b2);
      h2 = b2.memoizedProps;
      l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
      g2.props = l2;
      q2 = b2.pendingProps;
      r2 = g2.context;
      k2 = c2.contextType;
      "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
      var y2 = c2.getDerivedStateFromProps;
      (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
      jh = false;
      r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e2);
      var n2 = b2.memoizedState;
      h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
    }
    return jj(a, b2, c2, d2, f2, e2);
  }
  function jj(a, b2, c2, d2, e2, f2) {
    gj(a, b2);
    var g2 = 0 !== (b2.flags & 128);
    if (!d2 && !g2)
      return e2 && dg(b2, c2, false), Zi(a, b2, f2);
    d2 = b2.stateNode;
    Wi.current = b2;
    var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
    b2.flags |= 1;
    null !== a && g2 ? (b2.child = Ug(b2, a.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a, b2, h2, f2);
    b2.memoizedState = d2.state;
    e2 && dg(b2, c2, true);
    return b2.child;
  }
  function kj(a) {
    var b2 = a.stateNode;
    b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
    yh(a, b2.containerInfo);
  }
  function lj(a, b2, c2, d2, e2) {
    Ig();
    Jg(e2);
    b2.flags |= 256;
    Xi(a, b2, c2, d2);
    return b2.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function oj(a, b2, c2) {
    var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
    (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
    if (h2)
      f2 = true, b2.flags &= -129;
    else if (null === a || null !== a.memoizedState)
      e2 |= 1;
    G(L, e2 & 1);
    if (null === a) {
      Eg(b2);
      a = b2.memoizedState;
      if (null !== a && (a = a.dehydrated, null !== a))
        return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
      g2 = d2.children;
      a = d2.fallback;
      return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a = Tg(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a) : qj(b2, g2);
    }
    e2 = a.memoizedState;
    if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
      return rj(a, b2, g2, d2, h2, e2, c2);
    if (f2) {
      f2 = d2.fallback;
      g2 = b2.mode;
      e2 = a.child;
      h2 = e2.sibling;
      var k2 = { mode: "hidden", children: d2.children };
      0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
      null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
      f2.return = b2;
      d2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      d2 = f2;
      f2 = b2.child;
      g2 = a.child.memoizedState;
      g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
      f2.memoizedState = g2;
      f2.childLanes = a.childLanes & ~c2;
      b2.memoizedState = mj;
      return d2;
    }
    f2 = a.child;
    a = f2.sibling;
    d2 = Pg(f2, { mode: "visible", children: d2.children });
    0 === (b2.mode & 1) && (d2.lanes = c2);
    d2.return = b2;
    d2.sibling = null;
    null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
    b2.child = d2;
    b2.memoizedState = null;
    return d2;
  }
  function qj(a, b2) {
    b2 = pj({ mode: "visible", children: b2 }, a.mode, 0, null);
    b2.return = a;
    return a.child = b2;
  }
  function sj(a, b2, c2, d2) {
    null !== d2 && Jg(d2);
    Ug(b2, a.child, null, c2);
    a = qj(b2, b2.pendingProps.children);
    a.flags |= 2;
    b2.memoizedState = null;
    return a;
  }
  function rj(a, b2, c2, d2, e2, f2, g2) {
    if (c2) {
      if (b2.flags & 256)
        return b2.flags &= -257, d2 = Ki(Error(p$3(422))), sj(a, b2, g2, d2);
      if (null !== b2.memoizedState)
        return b2.child = a.child, b2.flags |= 128, null;
      f2 = d2.fallback;
      e2 = b2.mode;
      d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
      f2 = Tg(f2, e2, g2, null);
      f2.flags |= 2;
      d2.return = b2;
      f2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      0 !== (b2.mode & 1) && Ug(b2, a.child, null, g2);
      b2.child.memoizedState = nj(g2);
      b2.memoizedState = mj;
      return f2;
    }
    if (0 === (b2.mode & 1))
      return sj(a, b2, g2, null);
    if ("$!" === e2.data) {
      d2 = e2.nextSibling && e2.nextSibling.dataset;
      if (d2)
        var h2 = d2.dgst;
      d2 = h2;
      f2 = Error(p$3(419));
      d2 = Ki(f2, d2, void 0);
      return sj(a, b2, g2, d2);
    }
    h2 = 0 !== (g2 & a.childLanes);
    if (dh || h2) {
      d2 = Q;
      if (null !== d2) {
        switch (g2 & -g2) {
          case 4:
            e2 = 2;
            break;
          case 16:
            e2 = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e2 = 32;
            break;
          case 536870912:
            e2 = 268435456;
            break;
          default:
            e2 = 0;
        }
        e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
        0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a, e2), gi(d2, a, e2, -1));
      }
      tj();
      d2 = Ki(Error(p$3(421)));
      return sj(a, b2, g2, d2);
    }
    if ("$?" === e2.data)
      return b2.flags |= 128, b2.child = a.child, b2 = uj.bind(null, a), e2._reactRetry = b2, null;
    a = f2.treeContext;
    yg = Lf(e2.nextSibling);
    xg = b2;
    I = true;
    zg = null;
    null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
    b2 = qj(b2, d2.children);
    b2.flags |= 4096;
    return b2;
  }
  function vj(a, b2, c2) {
    a.lanes |= b2;
    var d2 = a.alternate;
    null !== d2 && (d2.lanes |= b2);
    bh(a.return, b2, c2);
  }
  function wj(a, b2, c2, d2, e2) {
    var f2 = a.memoizedState;
    null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
  }
  function xj(a, b2, c2) {
    var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
    Xi(a, b2, d2.children, c2);
    d2 = L.current;
    if (0 !== (d2 & 2))
      d2 = d2 & 1 | 2, b2.flags |= 128;
    else {
      if (null !== a && 0 !== (a.flags & 128))
        a:
          for (a = b2.child; null !== a; ) {
            if (13 === a.tag)
              null !== a.memoizedState && vj(a, c2, b2);
            else if (19 === a.tag)
              vj(a, c2, b2);
            else if (null !== a.child) {
              a.child.return = a;
              a = a.child;
              continue;
            }
            if (a === b2)
              break a;
            for (; null === a.sibling; ) {
              if (null === a.return || a.return === b2)
                break a;
              a = a.return;
            }
            a.sibling.return = a.return;
            a = a.sibling;
          }
      d2 &= 1;
    }
    G(L, d2);
    if (0 === (b2.mode & 1))
      b2.memoizedState = null;
    else
      switch (e2) {
        case "forwards":
          c2 = b2.child;
          for (e2 = null; null !== c2; )
            a = c2.alternate, null !== a && null === Ch(a) && (e2 = c2), c2 = c2.sibling;
          c2 = e2;
          null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
          wj(b2, false, e2, c2, f2);
          break;
        case "backwards":
          c2 = null;
          e2 = b2.child;
          for (b2.child = null; null !== e2; ) {
            a = e2.alternate;
            if (null !== a && null === Ch(a)) {
              b2.child = e2;
              break;
            }
            a = e2.sibling;
            e2.sibling = c2;
            c2 = e2;
            e2 = a;
          }
          wj(b2, true, c2, null, f2);
          break;
        case "together":
          wj(b2, false, null, null, void 0);
          break;
        default:
          b2.memoizedState = null;
      }
    return b2.child;
  }
  function ij(a, b2) {
    0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
  }
  function Zi(a, b2, c2) {
    null !== a && (b2.dependencies = a.dependencies);
    rh |= b2.lanes;
    if (0 === (c2 & b2.childLanes))
      return null;
    if (null !== a && b2.child !== a.child)
      throw Error(p$3(153));
    if (null !== b2.child) {
      a = b2.child;
      c2 = Pg(a, a.pendingProps);
      b2.child = c2;
      for (c2.return = b2; null !== a.sibling; )
        a = a.sibling, c2 = c2.sibling = Pg(a, a.pendingProps), c2.return = b2;
      c2.sibling = null;
    }
    return b2.child;
  }
  function yj(a, b2, c2) {
    switch (b2.tag) {
      case 3:
        kj(b2);
        Ig();
        break;
      case 5:
        Ah(b2);
        break;
      case 1:
        Zf(b2.type) && cg(b2);
        break;
      case 4:
        yh(b2, b2.stateNode.containerInfo);
        break;
      case 10:
        var d2 = b2.type._context, e2 = b2.memoizedProps.value;
        G(Wg, d2._currentValue);
        d2._currentValue = e2;
        break;
      case 13:
        d2 = b2.memoizedState;
        if (null !== d2) {
          if (null !== d2.dehydrated)
            return G(L, L.current & 1), b2.flags |= 128, null;
          if (0 !== (c2 & b2.child.childLanes))
            return oj(a, b2, c2);
          G(L, L.current & 1);
          a = Zi(a, b2, c2);
          return null !== a ? a.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d2 = 0 !== (c2 & b2.childLanes);
        if (0 !== (a.flags & 128)) {
          if (d2)
            return xj(a, b2, c2);
          b2.flags |= 128;
        }
        e2 = b2.memoizedState;
        null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
        G(L, L.current);
        if (d2)
          break;
        else
          return null;
      case 22:
      case 23:
        return b2.lanes = 0, dj(a, b2, c2);
    }
    return Zi(a, b2, c2);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a, b2) {
    for (var c2 = b2.child; null !== c2; ) {
      if (5 === c2.tag || 6 === c2.tag)
        a.appendChild(c2.stateNode);
      else if (4 !== c2.tag && null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === b2)
        break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === b2)
          return;
        c2 = c2.return;
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a, b2, c2, d2) {
    var e2 = a.memoizedProps;
    if (e2 !== d2) {
      a = b2.stateNode;
      xh(uh.current);
      var f2 = null;
      switch (c2) {
        case "input":
          e2 = Ya(a, e2);
          d2 = Ya(a, d2);
          f2 = [];
          break;
        case "select":
          e2 = A$1({}, e2, { value: void 0 });
          d2 = A$1({}, d2, { value: void 0 });
          f2 = [];
          break;
        case "textarea":
          e2 = gb(a, e2);
          d2 = gb(a, d2);
          f2 = [];
          break;
        default:
          "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
      }
      ub(c2, d2);
      var g2;
      c2 = null;
      for (l2 in e2)
        if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
          if ("style" === l2) {
            var h2 = e2[l2];
            for (g2 in h2)
              h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
          } else
            "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
      for (l2 in d2) {
        var k2 = d2[l2];
        h2 = null != e2 ? e2[l2] : void 0;
        if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
          if ("style" === l2)
            if (h2) {
              for (g2 in h2)
                !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
              for (g2 in k2)
                k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
            } else
              c2 || (f2 || (f2 = []), f2.push(
                l2,
                c2
              )), c2 = k2;
          else
            "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
      }
      c2 && (f2 = f2 || []).push("style", c2);
      var l2 = f2;
      if (b2.updateQueue = l2)
        b2.flags |= 4;
    }
  };
  Cj = function(a, b2, c2, d2) {
    c2 !== d2 && (b2.flags |= 4);
  };
  function Dj(a, b2) {
    if (!I)
      switch (a.tailMode) {
        case "hidden":
          b2 = a.tail;
          for (var c2 = null; null !== b2; )
            null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
          null === c2 ? a.tail = null : c2.sibling = null;
          break;
        case "collapsed":
          c2 = a.tail;
          for (var d2 = null; null !== c2; )
            null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
          null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
      }
  }
  function S(a) {
    var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
    if (b2)
      for (var e2 = a.child; null !== e2; )
        c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
    else
      for (e2 = a.child; null !== e2; )
        c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
    a.subtreeFlags |= d2;
    a.childLanes = c2;
    return b2;
  }
  function Ej(a, b2, c2) {
    var d2 = b2.pendingProps;
    wg(b2);
    switch (b2.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b2), null;
      case 1:
        return Zf(b2.type) && $f(), S(b2), null;
      case 3:
        d2 = b2.stateNode;
        zh();
        E(Wf);
        E(H);
        Eh();
        d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
        if (null === a || null === a.child)
          Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a, b2);
        S(b2);
        return null;
      case 5:
        Bh(b2);
        var e2 = xh(wh.current);
        c2 = b2.type;
        if (null !== a && null != b2.stateNode)
          Bj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        else {
          if (!d2) {
            if (null === b2.stateNode)
              throw Error(p$3(166));
            S(b2);
            return null;
          }
          a = xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.type;
            var f2 = b2.memoizedProps;
            d2[Of] = b2;
            d2[Pf] = f2;
            a = 0 !== (b2.mode & 1);
            switch (c2) {
              case "dialog":
                D("cancel", d2);
                D("close", d2);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d2);
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D(lf[e2], d2);
                break;
              case "source":
                D("error", d2);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d2
                );
                D("load", d2);
                break;
              case "details":
                D("toggle", d2);
                break;
              case "input":
                Za(d2, f2);
                D("invalid", d2);
                break;
              case "select":
                d2._wrapperState = { wasMultiple: !!f2.multiple };
                D("invalid", d2);
                break;
              case "textarea":
                hb(d2, f2), D("invalid", d2);
            }
            ub(c2, f2);
            e2 = null;
            for (var g2 in f2)
              if (f2.hasOwnProperty(g2)) {
                var h2 = f2[g2];
                "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                  d2.textContent,
                  h2,
                  a
                ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
              }
            switch (c2) {
              case "input":
                Va(d2);
                db(d2, f2, true);
                break;
              case "textarea":
                Va(d2);
                jb(d2);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f2.onClick && (d2.onclick = Bf);
            }
            d2 = e2;
            b2.updateQueue = d2;
            null !== d2 && (b2.flags |= 4);
          } else {
            g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
            "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
            a[Of] = b2;
            a[Pf] = d2;
            zj(a, b2, false, false);
            b2.stateNode = a;
            a: {
              g2 = vb(c2, d2);
              switch (c2) {
                case "dialog":
                  D("cancel", a);
                  D("close", a);
                  e2 = d2;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a);
                  e2 = d2;
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++)
                    D(lf[e2], a);
                  e2 = d2;
                  break;
                case "source":
                  D("error", a);
                  e2 = d2;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a
                  );
                  D("load", a);
                  e2 = d2;
                  break;
                case "details":
                  D("toggle", a);
                  e2 = d2;
                  break;
                case "input":
                  Za(a, d2);
                  e2 = Ya(a, d2);
                  D("invalid", a);
                  break;
                case "option":
                  e2 = d2;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!d2.multiple };
                  e2 = A$1({}, d2, { value: void 0 });
                  D("invalid", a);
                  break;
                case "textarea":
                  hb(a, d2);
                  e2 = gb(a, d2);
                  D("invalid", a);
                  break;
                default:
                  e2 = d2;
              }
              ub(c2, e2);
              h2 = e2;
              for (f2 in h2)
                if (h2.hasOwnProperty(f2)) {
                  var k2 = h2[f2];
                  "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
                }
              switch (c2) {
                case "input":
                  Va(a);
                  db(a, d2, false);
                  break;
                case "textarea":
                  Va(a);
                  jb(a);
                  break;
                case "option":
                  null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                  break;
                case "select":
                  a.multiple = !!d2.multiple;
                  f2 = d2.value;
                  null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                    a,
                    !!d2.multiple,
                    d2.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e2.onClick && (a.onclick = Bf);
              }
              switch (c2) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d2 = !!d2.autoFocus;
                  break a;
                case "img":
                  d2 = true;
                  break a;
                default:
                  d2 = false;
              }
            }
            d2 && (b2.flags |= 4);
          }
          null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        }
        S(b2);
        return null;
      case 6:
        if (a && null != b2.stateNode)
          Cj(a, b2, a.memoizedProps, d2);
        else {
          if ("string" !== typeof d2 && null === b2.stateNode)
            throw Error(p$3(166));
          c2 = xh(wh.current);
          xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.memoizedProps;
            d2[Of] = b2;
            if (f2 = d2.nodeValue !== c2) {
              if (a = xg, null !== a)
                switch (a.tag) {
                  case 3:
                    Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                    break;
                  case 5:
                    true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                }
            }
            f2 && (b2.flags |= 4);
          } else
            d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
        }
        S(b2);
        return null;
      case 13:
        E(L);
        d2 = b2.memoizedState;
        if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
            Hg(), Ig(), b2.flags |= 98560, f2 = false;
          else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
            if (null === a) {
              if (!f2)
                throw Error(p$3(318));
              f2 = b2.memoizedState;
              f2 = null !== f2 ? f2.dehydrated : null;
              if (!f2)
                throw Error(p$3(317));
              f2[Of] = b2;
            } else
              Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
            S(b2);
            f2 = false;
          } else
            null !== zg && (Fj(zg), zg = null), f2 = true;
          if (!f2)
            return b2.flags & 65536 ? b2 : null;
        }
        if (0 !== (b2.flags & 128))
          return b2.lanes = c2, b2;
        d2 = null !== d2;
        d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b2.updateQueue && (b2.flags |= 4);
        S(b2);
        return null;
      case 4:
        return zh(), Aj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
      case 10:
        return ah(b2.type._context), S(b2), null;
      case 17:
        return Zf(b2.type) && $f(), S(b2), null;
      case 19:
        E(L);
        f2 = b2.memoizedState;
        if (null === f2)
          return S(b2), null;
        d2 = 0 !== (b2.flags & 128);
        g2 = f2.rendering;
        if (null === g2)
          if (d2)
            Dj(f2, false);
          else {
            if (0 !== T || null !== a && 0 !== (a.flags & 128))
              for (a = b2.child; null !== a; ) {
                g2 = Ch(a);
                if (null !== g2) {
                  b2.flags |= 128;
                  Dj(f2, false);
                  d2 = g2.updateQueue;
                  null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                  b2.subtreeFlags = 0;
                  d2 = c2;
                  for (c2 = b2.child; null !== c2; )
                    f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
                  G(L, L.current & 1 | 2);
                  return b2.child;
                }
                a = a.sibling;
              }
            null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
          }
        else {
          if (!d2)
            if (a = Ch(g2), null !== a) {
              if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
                return S(b2), null;
            } else
              2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
          f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
        }
        if (null !== f2.tail)
          return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L.current, G(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
        S(b2);
        return null;
      case 22:
      case 23:
        return Hj(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p$3(156, b2.tag));
  }
  function Ij(a, b2) {
    wg(b2);
    switch (b2.tag) {
      case 1:
        return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
      case 3:
        return zh(), E(Wf), E(H), Eh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
      case 5:
        return Bh(b2), null;
      case 13:
        E(L);
        a = b2.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          if (null === b2.alternate)
            throw Error(p$3(340));
          Ig();
        }
        a = b2.flags;
        return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b2.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
  function Lj(a, b2) {
    var c2 = a.ref;
    if (null !== c2)
      if ("function" === typeof c2)
        try {
          c2(null);
        } catch (d2) {
          W(a, b2, d2);
        }
      else
        c2.current = null;
  }
  function Mj(a, b2, c2) {
    try {
      c2();
    } catch (d2) {
      W(a, b2, d2);
    }
  }
  var Nj = false;
  function Oj(a, b2) {
    Cf = dd;
    a = Me();
    if (Ne(a)) {
      if ("selectionStart" in a)
        var c2 = { start: a.selectionStart, end: a.selectionEnd };
      else
        a: {
          c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
          var d2 = c2.getSelection && c2.getSelection();
          if (d2 && 0 !== d2.rangeCount) {
            c2 = d2.anchorNode;
            var e2 = d2.anchorOffset, f2 = d2.focusNode;
            d2 = d2.focusOffset;
            try {
              c2.nodeType, f2.nodeType;
            } catch (F2) {
              c2 = null;
              break a;
            }
            var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
            b:
              for (; ; ) {
                for (var y2; ; ) {
                  q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                  q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                  3 === q2.nodeType && (g2 += q2.nodeValue.length);
                  if (null === (y2 = q2.firstChild))
                    break;
                  r2 = q2;
                  q2 = y2;
                }
                for (; ; ) {
                  if (q2 === a)
                    break b;
                  r2 === c2 && ++l2 === e2 && (h2 = g2);
                  r2 === f2 && ++m2 === d2 && (k2 = g2);
                  if (null !== (y2 = q2.nextSibling))
                    break;
                  q2 = r2;
                  r2 = q2.parentNode;
                }
                q2 = y2;
              }
            c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
          } else
            c2 = null;
        }
      c2 = c2 || { start: 0, end: 0 };
    } else
      c2 = null;
    Df = { focusedElem: a, selectionRange: c2 };
    dd = false;
    for (V = b2; null !== V; )
      if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
        a.return = b2, V = a;
      else
        for (; null !== V; ) {
          b2 = V;
          try {
            var n2 = b2.alternate;
            if (0 !== (b2.flags & 1024))
              switch (b2.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (null !== n2) {
                    var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
                    x2.__reactInternalSnapshotBeforeUpdate = w2;
                  }
                  break;
                case 3:
                  var u2 = b2.stateNode.containerInfo;
                  1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(p$3(163));
              }
          } catch (F2) {
            W(b2, b2.return, F2);
          }
          a = b2.sibling;
          if (null !== a) {
            a.return = b2.return;
            V = a;
            break;
          }
          V = b2.return;
        }
    n2 = Nj;
    Nj = false;
    return n2;
  }
  function Pj(a, b2, c2) {
    var d2 = b2.updateQueue;
    d2 = null !== d2 ? d2.lastEffect : null;
    if (null !== d2) {
      var e2 = d2 = d2.next;
      do {
        if ((e2.tag & a) === a) {
          var f2 = e2.destroy;
          e2.destroy = void 0;
          void 0 !== f2 && Mj(b2, c2, f2);
        }
        e2 = e2.next;
      } while (e2 !== d2);
    }
  }
  function Qj(a, b2) {
    b2 = b2.updateQueue;
    b2 = null !== b2 ? b2.lastEffect : null;
    if (null !== b2) {
      var c2 = b2 = b2.next;
      do {
        if ((c2.tag & a) === a) {
          var d2 = c2.create;
          c2.destroy = d2();
        }
        c2 = c2.next;
      } while (c2 !== b2);
    }
  }
  function Rj(a) {
    var b2 = a.ref;
    if (null !== b2) {
      var c2 = a.stateNode;
      switch (a.tag) {
        case 5:
          a = c2;
          break;
        default:
          a = c2;
      }
      "function" === typeof b2 ? b2(a) : b2.current = a;
    }
  }
  function Sj(a) {
    var b2 = a.alternate;
    null !== b2 && (a.alternate = null, Sj(b2));
    a.child = null;
    a.deletions = null;
    a.sibling = null;
    5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
    a.stateNode = null;
    a.return = null;
    a.dependencies = null;
    a.memoizedProps = null;
    a.memoizedState = null;
    a.pendingProps = null;
    a.stateNode = null;
    a.updateQueue = null;
  }
  function Tj(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }
  function Uj(a) {
    a:
      for (; ; ) {
        for (; null === a.sibling; ) {
          if (null === a.return || Tj(a.return))
            return null;
          a = a.return;
        }
        a.sibling.return = a.return;
        for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
          if (a.flags & 2)
            continue a;
          if (null === a.child || 4 === a.tag)
            continue a;
          else
            a.child.return = a, a = a.child;
        }
        if (!(a.flags & 2))
          return a.stateNode;
      }
  }
  function Vj(a, b2, c2) {
    var d2 = a.tag;
    if (5 === d2 || 6 === d2)
      a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
    else if (4 !== d2 && (a = a.child, null !== a))
      for (Vj(a, b2, c2), a = a.sibling; null !== a; )
        Vj(a, b2, c2), a = a.sibling;
  }
  function Wj(a, b2, c2) {
    var d2 = a.tag;
    if (5 === d2 || 6 === d2)
      a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
    else if (4 !== d2 && (a = a.child, null !== a))
      for (Wj(a, b2, c2), a = a.sibling; null !== a; )
        Wj(a, b2, c2), a = a.sibling;
  }
  var X = null, Xj = false;
  function Yj(a, b2, c2) {
    for (c2 = c2.child; null !== c2; )
      Zj(a, b2, c2), c2 = c2.sibling;
  }
  function Zj(a, b2, c2) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount)
      try {
        lc.onCommitFiberUnmount(kc, c2);
      } catch (h2) {
      }
    switch (c2.tag) {
      case 5:
        U || Lj(c2, b2);
      case 6:
        var d2 = X, e2 = Xj;
        X = null;
        Yj(a, b2, c2);
        X = d2;
        Xj = e2;
        null !== X && (Xj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X.removeChild(c2.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X, c2.stateNode));
        break;
      case 4:
        d2 = X;
        e2 = Xj;
        X = c2.stateNode.containerInfo;
        Xj = true;
        Yj(a, b2, c2);
        X = d2;
        Xj = e2;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
          e2 = d2 = d2.next;
          do {
            var f2 = e2, g2 = f2.destroy;
            f2 = f2.tag;
            void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
            e2 = e2.next;
          } while (e2 !== d2);
        }
        Yj(a, b2, c2);
        break;
      case 1:
        if (!U && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
          try {
            d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
          } catch (h2) {
            W(c2, b2, h2);
          }
        Yj(a, b2, c2);
        break;
      case 21:
        Yj(a, b2, c2);
        break;
      case 22:
        c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Yj(a, b2, c2), U = d2) : Yj(a, b2, c2);
        break;
      default:
        Yj(a, b2, c2);
    }
  }
  function ak(a) {
    var b2 = a.updateQueue;
    if (null !== b2) {
      a.updateQueue = null;
      var c2 = a.stateNode;
      null === c2 && (c2 = a.stateNode = new Kj());
      b2.forEach(function(b3) {
        var d2 = bk.bind(null, a, b3);
        c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
      });
    }
  }
  function ck(a, b2) {
    var c2 = b2.deletions;
    if (null !== c2)
      for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2];
        try {
          var f2 = a, g2 = b2, h2 = g2;
          a:
            for (; null !== h2; ) {
              switch (h2.tag) {
                case 5:
                  X = h2.stateNode;
                  Xj = false;
                  break a;
                case 3:
                  X = h2.stateNode.containerInfo;
                  Xj = true;
                  break a;
                case 4:
                  X = h2.stateNode.containerInfo;
                  Xj = true;
                  break a;
              }
              h2 = h2.return;
            }
          if (null === X)
            throw Error(p$3(160));
          Zj(f2, g2, e2);
          X = null;
          Xj = false;
          var k2 = e2.alternate;
          null !== k2 && (k2.return = null);
          e2.return = null;
        } catch (l2) {
          W(e2, b2, l2);
        }
      }
    if (b2.subtreeFlags & 12854)
      for (b2 = b2.child; null !== b2; )
        dk(b2, a), b2 = b2.sibling;
  }
  function dk(a, b2) {
    var c2 = a.alternate, d2 = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b2, a);
        ek(a);
        if (d2 & 4) {
          try {
            Pj(3, a, a.return), Qj(3, a);
          } catch (t2) {
            W(a, a.return, t2);
          }
          try {
            Pj(5, a, a.return);
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 1:
        ck(b2, a);
        ek(a);
        d2 & 512 && null !== c2 && Lj(c2, c2.return);
        break;
      case 5:
        ck(b2, a);
        ek(a);
        d2 & 512 && null !== c2 && Lj(c2, c2.return);
        if (a.flags & 32) {
          var e2 = a.stateNode;
          try {
            ob(e2, "");
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
          var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
          a.updateQueue = null;
          if (null !== k2)
            try {
              "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
              vb(h2, g2);
              var l2 = vb(h2, f2);
              for (g2 = 0; g2 < k2.length; g2 += 2) {
                var m2 = k2[g2], q2 = k2[g2 + 1];
                "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
              }
              switch (h2) {
                case "input":
                  bb(e2, f2);
                  break;
                case "textarea":
                  ib(e2, f2);
                  break;
                case "select":
                  var r2 = e2._wrapperState.wasMultiple;
                  e2._wrapperState.wasMultiple = !!f2.multiple;
                  var y2 = f2.value;
                  null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                    e2,
                    !!f2.multiple,
                    f2.defaultValue,
                    true
                  ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
              }
              e2[Pf] = f2;
            } catch (t2) {
              W(a, a.return, t2);
            }
        }
        break;
      case 6:
        ck(b2, a);
        ek(a);
        if (d2 & 4) {
          if (null === a.stateNode)
            throw Error(p$3(162));
          e2 = a.stateNode;
          f2 = a.memoizedProps;
          try {
            e2.nodeValue = f2;
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 3:
        ck(b2, a);
        ek(a);
        if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
          try {
            bd(b2.containerInfo);
          } catch (t2) {
            W(a, a.return, t2);
          }
        break;
      case 4:
        ck(b2, a);
        ek(a);
        break;
      case 13:
        ck(b2, a);
        ek(a);
        e2 = a.child;
        e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
        d2 & 4 && ak(a);
        break;
      case 22:
        m2 = null !== c2 && null !== c2.memoizedState;
        a.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a), U = l2) : ck(b2, a);
        ek(a);
        if (d2 & 8192) {
          l2 = null !== a.memoizedState;
          if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
            for (V = a, m2 = a.child; null !== m2; ) {
              for (q2 = V = m2; null !== V; ) {
                r2 = V;
                y2 = r2.child;
                switch (r2.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Pj(4, r2, r2.return);
                    break;
                  case 1:
                    Lj(r2, r2.return);
                    var n2 = r2.stateNode;
                    if ("function" === typeof n2.componentWillUnmount) {
                      d2 = r2;
                      c2 = r2.return;
                      try {
                        b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                      } catch (t2) {
                        W(d2, c2, t2);
                      }
                    }
                    break;
                  case 5:
                    Lj(r2, r2.return);
                    break;
                  case 22:
                    if (null !== r2.memoizedState) {
                      gk(q2);
                      continue;
                    }
                }
                null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
              }
              m2 = m2.sibling;
            }
          a:
            for (m2 = null, q2 = a; ; ) {
              if (5 === q2.tag) {
                if (null === m2) {
                  m2 = q2;
                  try {
                    e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                  } catch (t2) {
                    W(a, a.return, t2);
                  }
                }
              } else if (6 === q2.tag) {
                if (null === m2)
                  try {
                    q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                  } catch (t2) {
                    W(a, a.return, t2);
                  }
              } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
                q2.child.return = q2;
                q2 = q2.child;
                continue;
              }
              if (q2 === a)
                break a;
              for (; null === q2.sibling; ) {
                if (null === q2.return || q2.return === a)
                  break a;
                m2 === q2 && (m2 = null);
                q2 = q2.return;
              }
              m2 === q2 && (m2 = null);
              q2.sibling.return = q2.return;
              q2 = q2.sibling;
            }
        }
        break;
      case 19:
        ck(b2, a);
        ek(a);
        d2 & 4 && ak(a);
        break;
      case 21:
        break;
      default:
        ck(
          b2,
          a
        ), ek(a);
    }
  }
  function ek(a) {
    var b2 = a.flags;
    if (b2 & 2) {
      try {
        a: {
          for (var c2 = a.return; null !== c2; ) {
            if (Tj(c2)) {
              var d2 = c2;
              break a;
            }
            c2 = c2.return;
          }
          throw Error(p$3(160));
        }
        switch (d2.tag) {
          case 5:
            var e2 = d2.stateNode;
            d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
            var f2 = Uj(a);
            Wj(a, f2, e2);
            break;
          case 3:
          case 4:
            var g2 = d2.stateNode.containerInfo, h2 = Uj(a);
            Vj(a, h2, g2);
            break;
          default:
            throw Error(p$3(161));
        }
      } catch (k2) {
        W(a, a.return, k2);
      }
      a.flags &= -3;
    }
    b2 & 4096 && (a.flags &= -4097);
  }
  function hk(a, b2, c2) {
    V = a;
    ik(a);
  }
  function ik(a, b2, c2) {
    for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
      var e2 = V, f2 = e2.child;
      if (22 === e2.tag && d2) {
        var g2 = null !== e2.memoizedState || Jj;
        if (!g2) {
          var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
          h2 = Jj;
          var l2 = U;
          Jj = g2;
          if ((U = k2) && !l2)
            for (V = e2; null !== V; )
              g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V = k2) : jk(e2);
          for (; null !== f2; )
            V = f2, ik(f2), f2 = f2.sibling;
          V = e2;
          Jj = h2;
          U = l2;
        }
        kk(a);
      } else
        0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a);
    }
  }
  function kk(a) {
    for (; null !== V; ) {
      var b2 = V;
      if (0 !== (b2.flags & 8772)) {
        var c2 = b2.alternate;
        try {
          if (0 !== (b2.flags & 8772))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                U || Qj(5, b2);
                break;
              case 1:
                var d2 = b2.stateNode;
                if (b2.flags & 4 && !U)
                  if (null === c2)
                    d2.componentDidMount();
                  else {
                    var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
                    d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                  }
                var f2 = b2.updateQueue;
                null !== f2 && sh(b2, f2, d2);
                break;
              case 3:
                var g2 = b2.updateQueue;
                if (null !== g2) {
                  c2 = null;
                  if (null !== b2.child)
                    switch (b2.child.tag) {
                      case 5:
                        c2 = b2.child.stateNode;
                        break;
                      case 1:
                        c2 = b2.child.stateNode;
                    }
                  sh(b2, g2, c2);
                }
                break;
              case 5:
                var h2 = b2.stateNode;
                if (null === c2 && b2.flags & 4) {
                  c2 = h2;
                  var k2 = b2.memoizedProps;
                  switch (b2.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      k2.autoFocus && c2.focus();
                      break;
                    case "img":
                      k2.src && (c2.src = k2.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (null === b2.memoizedState) {
                  var l2 = b2.alternate;
                  if (null !== l2) {
                    var m2 = l2.memoizedState;
                    if (null !== m2) {
                      var q2 = m2.dehydrated;
                      null !== q2 && bd(q2);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(p$3(163));
            }
          U || b2.flags & 512 && Rj(b2);
        } catch (r2) {
          W(b2, b2.return, r2);
        }
      }
      if (b2 === a) {
        V = null;
        break;
      }
      c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V = c2;
        break;
      }
      V = b2.return;
    }
  }
  function gk(a) {
    for (; null !== V; ) {
      var b2 = V;
      if (b2 === a) {
        V = null;
        break;
      }
      var c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V = c2;
        break;
      }
      V = b2.return;
    }
  }
  function jk(a) {
    for (; null !== V; ) {
      var b2 = V;
      try {
        switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            var c2 = b2.return;
            try {
              Qj(4, b2);
            } catch (k2) {
              W(b2, c2, k2);
            }
            break;
          case 1:
            var d2 = b2.stateNode;
            if ("function" === typeof d2.componentDidMount) {
              var e2 = b2.return;
              try {
                d2.componentDidMount();
              } catch (k2) {
                W(b2, e2, k2);
              }
            }
            var f2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W(b2, f2, k2);
            }
            break;
          case 5:
            var g2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W(b2, g2, k2);
            }
        }
      } catch (k2) {
        W(b2, b2.return, k2);
      }
      if (b2 === a) {
        V = null;
        break;
      }
      var h2 = b2.sibling;
      if (null !== h2) {
        h2.return = b2.return;
        V = h2;
        break;
      }
      V = b2.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a) {
    if (0 === (a.mode & 1))
      return 1;
    if (0 !== (K & 2) && 0 !== Z)
      return Z & -Z;
    if (null !== Kg.transition)
      return 0 === Bk && (Bk = yc()), Bk;
    a = C;
    if (0 !== a)
      return a;
    a = window.event;
    a = void 0 === a ? 16 : jd(a.type);
    return a;
  }
  function gi(a, b2, c2, d2) {
    if (50 < yk)
      throw yk = 0, zk = null, Error(p$3(185));
    Ac(a, c2, d2);
    if (0 === (K & 2) || a !== Q)
      a === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a, Z)), Dk(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a, b2) {
    var c2 = a.callbackNode;
    wc(a, b2);
    var d2 = uc(a, a === Q ? Z : 0);
    if (0 === d2)
      null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
    else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
      null != c2 && bc(c2);
      if (1 === b2)
        0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
          0 === (K & 6) && jg();
        }), c2 = null;
      else {
        switch (Dc(d2)) {
          case 1:
            c2 = fc;
            break;
          case 4:
            c2 = gc;
            break;
          case 16:
            c2 = hc;
            break;
          case 536870912:
            c2 = jc;
            break;
          default:
            c2 = hc;
        }
        c2 = Fk(c2, Gk.bind(null, a));
      }
      a.callbackPriority = b2;
      a.callbackNode = c2;
    }
  }
  function Gk(a, b2) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6))
      throw Error(p$3(327));
    var c2 = a.callbackNode;
    if (Hk() && a.callbackNode !== c2)
      return null;
    var d2 = uc(a, a === Q ? Z : 0);
    if (0 === d2)
      return null;
    if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2)
      b2 = Ik(a, d2);
    else {
      b2 = d2;
      var e2 = K;
      K |= 2;
      var f2 = Jk();
      if (Q !== a || Z !== b2)
        uk = null, Gj = B() + 500, Kk(a, b2);
      do
        try {
          Lk();
          break;
        } catch (h2) {
          Mk(a, h2);
        }
      while (1);
      $g();
      mk.current = f2;
      K = e2;
      null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T);
    }
    if (0 !== b2) {
      2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Nk(a, e2)));
      if (1 === b2)
        throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
      if (6 === b2)
        Ck(a, d2);
      else {
        e2 = a.current.alternate;
        if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Nk(a, f2))), 1 === b2))
          throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
        a.finishedWork = e2;
        a.finishedLanes = d2;
        switch (b2) {
          case 0:
          case 1:
            throw Error(p$3(345));
          case 2:
            Pk(a, tk, uk);
            break;
          case 3:
            Ck(a, d2);
            if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
              if (0 !== uc(a, 0))
                break;
              e2 = a.suspendedLanes;
              if ((e2 & d2) !== d2) {
                R();
                a.pingedLanes |= a.suspendedLanes & e2;
                break;
              }
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b2);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 4:
            Ck(a, d2);
            if ((d2 & 4194240) === d2)
              break;
            b2 = a.eventTimes;
            for (e2 = -1; 0 < d2; ) {
              var g2 = 31 - oc(d2);
              f2 = 1 << g2;
              g2 = b2[g2];
              g2 > e2 && (e2 = g2);
              d2 &= ~f2;
            }
            d2 = e2;
            d2 = B() - d2;
            d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
            if (10 < d2) {
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d2);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 5:
            Pk(a, tk, uk);
            break;
          default:
            throw Error(p$3(329));
        }
      }
    }
    Dk(a, B());
    return a.callbackNode === c2 ? Gk.bind(null, a) : null;
  }
  function Nk(a, b2) {
    var c2 = sk;
    a.current.memoizedState.isDehydrated && (Kk(a, b2).flags |= 256);
    a = Ik(a, b2);
    2 !== a && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
    return a;
  }
  function Fj(a) {
    null === tk ? tk = a : tk.push.apply(tk, a);
  }
  function Ok(a) {
    for (var b2 = a; ; ) {
      if (b2.flags & 16384) {
        var c2 = b2.updateQueue;
        if (null !== c2 && (c2 = c2.stores, null !== c2))
          for (var d2 = 0; d2 < c2.length; d2++) {
            var e2 = c2[d2], f2 = e2.getSnapshot;
            e2 = e2.value;
            try {
              if (!He(f2(), e2))
                return false;
            } catch (g2) {
              return false;
            }
          }
      }
      c2 = b2.child;
      if (b2.subtreeFlags & 16384 && null !== c2)
        c2.return = b2, b2 = c2;
      else {
        if (b2 === a)
          break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a)
            return true;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
    }
    return true;
  }
  function Ck(a, b2) {
    b2 &= ~rk;
    b2 &= ~qk;
    a.suspendedLanes |= b2;
    a.pingedLanes &= ~b2;
    for (a = a.expirationTimes; 0 < b2; ) {
      var c2 = 31 - oc(b2), d2 = 1 << c2;
      a[c2] = -1;
      b2 &= ~d2;
    }
  }
  function Ek(a) {
    if (0 !== (K & 6))
      throw Error(p$3(327));
    Hk();
    var b2 = uc(a, 0);
    if (0 === (b2 & 1))
      return Dk(a, B()), null;
    var c2 = Ik(a, b2);
    if (0 !== a.tag && 2 === c2) {
      var d2 = xc(a);
      0 !== d2 && (b2 = d2, c2 = Nk(a, d2));
    }
    if (1 === c2)
      throw c2 = pk, Kk(a, 0), Ck(a, b2), Dk(a, B()), c2;
    if (6 === c2)
      throw Error(p$3(345));
    a.finishedWork = a.current.alternate;
    a.finishedLanes = b2;
    Pk(a, tk, uk);
    Dk(a, B());
    return null;
  }
  function Qk(a, b2) {
    var c2 = K;
    K |= 1;
    try {
      return a(b2);
    } finally {
      K = c2, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b2 = K;
    K |= 1;
    var c2 = ok.transition, d2 = C;
    try {
      if (ok.transition = null, C = 1, a)
        return a();
    } finally {
      C = d2, ok.transition = c2, K = b2, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a, b2) {
    a.finishedWork = null;
    a.finishedLanes = 0;
    var c2 = a.timeoutHandle;
    -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
    if (null !== Y)
      for (c2 = Y.return; null !== c2; ) {
        var d2 = c2;
        wg(d2);
        switch (d2.tag) {
          case 1:
            d2 = d2.type.childContextTypes;
            null !== d2 && void 0 !== d2 && $f();
            break;
          case 3:
            zh();
            E(Wf);
            E(H);
            Eh();
            break;
          case 5:
            Bh(d2);
            break;
          case 4:
            zh();
            break;
          case 13:
            E(L);
            break;
          case 19:
            E(L);
            break;
          case 10:
            ah(d2.type._context);
            break;
          case 22:
          case 23:
            Hj();
        }
        c2 = c2.return;
      }
    Q = a;
    Y = a = Pg(a.current, null);
    Z = fj = b2;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b2 = 0; b2 < fh.length; b2++)
        if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
          c2.interleaved = null;
          var e2 = d2.next, f2 = c2.pending;
          if (null !== f2) {
            var g2 = f2.next;
            f2.next = e2;
            d2.next = g2;
          }
          c2.pending = d2;
        }
      fh = null;
    }
    return a;
  }
  function Mk(a, b2) {
    do {
      var c2 = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d2 = M.memoizedState; null !== d2; ) {
            var e2 = d2.queue;
            null !== e2 && (e2.pending = null);
            d2 = d2.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N = M = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c2 || null === c2.return) {
          T = 1;
          pk = b2;
          Y = null;
          break;
        }
        a: {
          var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
          b2 = Z;
          h2.flags |= 32768;
          if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
            var l2 = k2, m2 = h2, q2 = m2.tag;
            if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
              var r2 = m2.alternate;
              r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y2 = Ui(g2);
            if (null !== y2) {
              y2.flags &= -257;
              Vi(y2, g2, h2, f2, b2);
              y2.mode & 1 && Si(f2, l2, b2);
              b2 = y2;
              k2 = l2;
              var n2 = b2.updateQueue;
              if (null === n2) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k2);
                b2.updateQueue = t2;
              } else
                n2.add(k2);
              break a;
            } else {
              if (0 === (b2 & 1)) {
                Si(f2, l2, b2);
                tj();
                break a;
              }
              k2 = Error(p$3(426));
            }
          } else if (I && h2.mode & 1) {
            var J2 = Ui(g2);
            if (null !== J2) {
              0 === (J2.flags & 65536) && (J2.flags |= 256);
              Vi(J2, g2, h2, f2, b2);
              Jg(Ji(k2, h2));
              break a;
            }
          }
          f2 = k2 = Ji(k2, h2);
          4 !== T && (T = 2);
          null === sk ? sk = [f2] : sk.push(f2);
          f2 = g2;
          do {
            switch (f2.tag) {
              case 3:
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var x2 = Ni(f2, k2, b2);
                ph(f2, x2);
                break a;
              case 1:
                h2 = k2;
                var w2 = f2.type, u2 = f2.stateNode;
                if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var F2 = Qi(f2, h2, b2);
                  ph(f2, F2);
                  break a;
                }
            }
            f2 = f2.return;
          } while (null !== f2);
        }
        Sk(c2);
      } catch (na) {
        b2 = na;
        Y === c2 && null !== c2 && (Y = c2 = c2.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a = mk.current;
    mk.current = Rh;
    return null === a ? Rh : a;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T)
      T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a, b2) {
    var c2 = K;
    K |= 2;
    var d2 = Jk();
    if (Q !== a || Z !== b2)
      uk = null, Kk(a, b2);
    do
      try {
        Tk();
        break;
      } catch (e2) {
        Mk(a, e2);
      }
    while (1);
    $g();
    K = c2;
    mk.current = d2;
    if (null !== Y)
      throw Error(p$3(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; )
      Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); )
      Uk(Y);
  }
  function Uk(a) {
    var b2 = Vk(a.alternate, a, fj);
    a.memoizedProps = a.pendingProps;
    null === b2 ? Sk(a) : Y = b2;
    nk.current = null;
  }
  function Sk(a) {
    var b2 = a;
    do {
      var c2 = b2.alternate;
      a = b2.return;
      if (0 === (b2.flags & 32768)) {
        if (c2 = Ej(c2, b2, fj), null !== c2) {
          Y = c2;
          return;
        }
      } else {
        c2 = Ij(c2, b2);
        if (null !== c2) {
          c2.flags &= 32767;
          Y = c2;
          return;
        }
        if (null !== a)
          a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b2 = b2.sibling;
      if (null !== b2) {
        Y = b2;
        return;
      }
      Y = b2 = a;
    } while (null !== b2);
    0 === T && (T = 5);
  }
  function Pk(a, b2, c2) {
    var d2 = C, e2 = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a, b2, c2, d2);
    } finally {
      ok.transition = e2, C = d2;
    }
    return null;
  }
  function Wk(a, b2, c2, d2) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6))
      throw Error(p$3(327));
    c2 = a.finishedWork;
    var e2 = a.finishedLanes;
    if (null === c2)
      return null;
    a.finishedWork = null;
    a.finishedLanes = 0;
    if (c2 === a.current)
      throw Error(p$3(177));
    a.callbackNode = null;
    a.callbackPriority = 0;
    var f2 = c2.lanes | c2.childLanes;
    Bc(a, f2);
    a === Q && (Y = Q = null, Z = 0);
    0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f2 = 0 !== (c2.flags & 15990);
    if (0 !== (c2.subtreeFlags & 15990) || f2) {
      f2 = ok.transition;
      ok.transition = null;
      var g2 = C;
      C = 1;
      var h2 = K;
      K |= 4;
      nk.current = null;
      Oj(a, c2);
      dk(c2, a);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a.current = c2;
      hk(c2);
      dc();
      K = h2;
      C = g2;
      ok.transition = f2;
    } else
      a.current = c2;
    vk && (vk = false, wk = a, xk = e2);
    f2 = a.pendingLanes;
    0 === f2 && (Ri = null);
    mc(c2.stateNode);
    Dk(a, B());
    if (null !== b2)
      for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
        e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
    if (Oi)
      throw Oi = false, a = Pi, Pi = null, a;
    0 !== (xk & 1) && 0 !== a.tag && Hk();
    f2 = a.pendingLanes;
    0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a = Dc(xk), b2 = ok.transition, c2 = C;
      try {
        ok.transition = null;
        C = 16 > a ? 16 : a;
        if (null === wk)
          var d2 = false;
        else {
          a = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6))
            throw Error(p$3(331));
          var e2 = K;
          K |= 4;
          for (V = a.current; null !== V; ) {
            var f2 = V, g2 = f2.child;
            if (0 !== (V.flags & 16)) {
              var h2 = f2.deletions;
              if (null !== h2) {
                for (var k2 = 0; k2 < h2.length; k2++) {
                  var l2 = h2[k2];
                  for (V = l2; null !== V; ) {
                    var m2 = V;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m2, f2);
                    }
                    var q2 = m2.child;
                    if (null !== q2)
                      q2.return = m2, V = q2;
                    else
                      for (; null !== V; ) {
                        m2 = V;
                        var r2 = m2.sibling, y2 = m2.return;
                        Sj(m2);
                        if (m2 === l2) {
                          V = null;
                          break;
                        }
                        if (null !== r2) {
                          r2.return = y2;
                          V = r2;
                          break;
                        }
                        V = y2;
                      }
                  }
                }
                var n2 = f2.alternate;
                if (null !== n2) {
                  var t2 = n2.child;
                  if (null !== t2) {
                    n2.child = null;
                    do {
                      var J2 = t2.sibling;
                      t2.sibling = null;
                      t2 = J2;
                    } while (null !== t2);
                  }
                }
                V = f2;
              }
            }
            if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
              g2.return = f2, V = g2;
            else
              b:
                for (; null !== V; ) {
                  f2 = V;
                  if (0 !== (f2.flags & 2048))
                    switch (f2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(9, f2, f2.return);
                    }
                  var x2 = f2.sibling;
                  if (null !== x2) {
                    x2.return = f2.return;
                    V = x2;
                    break b;
                  }
                  V = f2.return;
                }
          }
          var w2 = a.current;
          for (V = w2; null !== V; ) {
            g2 = V;
            var u2 = g2.child;
            if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
              u2.return = g2, V = u2;
            else
              b:
                for (g2 = w2; null !== V; ) {
                  h2 = V;
                  if (0 !== (h2.flags & 2048))
                    try {
                      switch (h2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, h2);
                      }
                    } catch (na) {
                      W(h2, h2.return, na);
                    }
                  if (h2 === g2) {
                    V = null;
                    break b;
                  }
                  var F2 = h2.sibling;
                  if (null !== F2) {
                    F2.return = h2.return;
                    V = F2;
                    break b;
                  }
                  V = h2.return;
                }
          }
          K = e2;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot)
            try {
              lc.onPostCommitFiberRoot(kc, a);
            } catch (na) {
            }
          d2 = true;
        }
        return d2;
      } finally {
        C = c2, ok.transition = b2;
      }
    }
    return false;
  }
  function Xk(a, b2, c2) {
    b2 = Ji(c2, b2);
    b2 = Ni(a, b2, 1);
    a = nh(a, b2, 1);
    b2 = R();
    null !== a && (Ac(a, 1, b2), Dk(a, b2));
  }
  function W(a, b2, c2) {
    if (3 === a.tag)
      Xk(a, a, c2);
    else
      for (; null !== b2; ) {
        if (3 === b2.tag) {
          Xk(b2, a, c2);
          break;
        } else if (1 === b2.tag) {
          var d2 = b2.stateNode;
          if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
            a = Ji(c2, a);
            a = Qi(b2, a, 1);
            b2 = nh(b2, a, 1);
            a = R();
            null !== b2 && (Ac(b2, 1, a), Dk(b2, a));
            break;
          }
        }
        b2 = b2.return;
      }
  }
  function Ti(a, b2, c2) {
    var d2 = a.pingCache;
    null !== d2 && d2.delete(b2);
    b2 = R();
    a.pingedLanes |= a.suspendedLanes & c2;
    Q === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c2);
    Dk(a, b2);
  }
  function Yk(a, b2) {
    0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c2 = R();
    a = ih(a, b2);
    null !== a && (Ac(a, b2, c2), Dk(a, c2));
  }
  function uj(a) {
    var b2 = a.memoizedState, c2 = 0;
    null !== b2 && (c2 = b2.retryLane);
    Yk(a, c2);
  }
  function bk(a, b2) {
    var c2 = 0;
    switch (a.tag) {
      case 13:
        var d2 = a.stateNode;
        var e2 = a.memoizedState;
        null !== e2 && (c2 = e2.retryLane);
        break;
      case 19:
        d2 = a.stateNode;
        break;
      default:
        throw Error(p$3(314));
    }
    null !== d2 && d2.delete(b2);
    Yk(a, c2);
  }
  var Vk;
  Vk = function(a, b2, c2) {
    if (null !== a)
      if (a.memoizedProps !== b2.pendingProps || Wf.current)
        dh = true;
      else {
        if (0 === (a.lanes & c2) && 0 === (b2.flags & 128))
          return dh = false, yj(a, b2, c2);
        dh = 0 !== (a.flags & 131072) ? true : false;
      }
    else
      dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
    b2.lanes = 0;
    switch (b2.tag) {
      case 2:
        var d2 = b2.type;
        ij(a, b2);
        a = b2.pendingProps;
        var e2 = Yf(b2, H.current);
        ch(b2, c2);
        e2 = Nh(null, b2, d2, a, e2, c2);
        var f2 = Sh();
        b2.flags |= 1;
        "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
        return b2;
      case 16:
        d2 = b2.elementType;
        a: {
          ij(a, b2);
          a = b2.pendingProps;
          e2 = d2._init;
          d2 = e2(d2._payload);
          b2.type = d2;
          e2 = b2.tag = Zk(d2);
          a = Ci(d2, a);
          switch (e2) {
            case 0:
              b2 = cj(null, b2, d2, a, c2);
              break a;
            case 1:
              b2 = hj(null, b2, d2, a, c2);
              break a;
            case 11:
              b2 = Yi(null, b2, d2, a, c2);
              break a;
            case 14:
              b2 = $i(null, b2, d2, Ci(d2.type, a), c2);
              break a;
          }
          throw Error(p$3(
            306,
            d2,
            ""
          ));
        }
        return b2;
      case 0:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a, b2, d2, e2, c2);
      case 1:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a, b2, d2, e2, c2);
      case 3:
        a: {
          kj(b2);
          if (null === a)
            throw Error(p$3(387));
          d2 = b2.pendingProps;
          f2 = b2.memoizedState;
          e2 = f2.element;
          lh(a, b2);
          qh(b2, d2, null, c2);
          var g2 = b2.memoizedState;
          d2 = g2.element;
          if (f2.isDehydrated)
            if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
              e2 = Ji(Error(p$3(423)), b2);
              b2 = lj(a, b2, d2, c2, e2);
              break a;
            } else if (d2 !== e2) {
              e2 = Ji(Error(p$3(424)), b2);
              b2 = lj(a, b2, d2, c2, e2);
              break a;
            } else
              for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; )
                c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
          else {
            Ig();
            if (d2 === e2) {
              b2 = Zi(a, b2, c2);
              break a;
            }
            Xi(a, b2, d2, c2);
          }
          b2 = b2.child;
        }
        return b2;
      case 5:
        return Ah(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a, b2), Xi(a, b2, g2, c2), b2.child;
      case 6:
        return null === a && Eg(b2), null;
      case 13:
        return oj(a, b2, c2);
      case 4:
        return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Ug(b2, null, d2, c2) : Xi(a, b2, d2, c2), b2.child;
      case 11:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a, b2, d2, e2, c2);
      case 7:
        return Xi(a, b2, b2.pendingProps, c2), b2.child;
      case 8:
        return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
      case 12:
        return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
      case 10:
        a: {
          d2 = b2.type._context;
          e2 = b2.pendingProps;
          f2 = b2.memoizedProps;
          g2 = e2.value;
          G(Wg, d2._currentValue);
          d2._currentValue = g2;
          if (null !== f2)
            if (He(f2.value, g2)) {
              if (f2.children === e2.children && !Wf.current) {
                b2 = Zi(a, b2, c2);
                break a;
              }
            } else
              for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
                var h2 = f2.dependencies;
                if (null !== h2) {
                  g2 = f2.child;
                  for (var k2 = h2.firstContext; null !== k2; ) {
                    if (k2.context === d2) {
                      if (1 === f2.tag) {
                        k2 = mh(-1, c2 & -c2);
                        k2.tag = 2;
                        var l2 = f2.updateQueue;
                        if (null !== l2) {
                          l2 = l2.shared;
                          var m2 = l2.pending;
                          null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                          l2.pending = k2;
                        }
                      }
                      f2.lanes |= c2;
                      k2 = f2.alternate;
                      null !== k2 && (k2.lanes |= c2);
                      bh(
                        f2.return,
                        c2,
                        b2
                      );
                      h2.lanes |= c2;
                      break;
                    }
                    k2 = k2.next;
                  }
                } else if (10 === f2.tag)
                  g2 = f2.type === b2.type ? null : f2.child;
                else if (18 === f2.tag) {
                  g2 = f2.return;
                  if (null === g2)
                    throw Error(p$3(341));
                  g2.lanes |= c2;
                  h2 = g2.alternate;
                  null !== h2 && (h2.lanes |= c2);
                  bh(g2, c2, b2);
                  g2 = f2.sibling;
                } else
                  g2 = f2.child;
                if (null !== g2)
                  g2.return = f2;
                else
                  for (g2 = f2; null !== g2; ) {
                    if (g2 === b2) {
                      g2 = null;
                      break;
                    }
                    f2 = g2.sibling;
                    if (null !== f2) {
                      f2.return = g2.return;
                      g2 = f2;
                      break;
                    }
                    g2 = g2.return;
                  }
                f2 = g2;
              }
          Xi(a, b2, e2.children, c2);
          b2 = b2.child;
        }
        return b2;
      case 9:
        return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a, b2, d2, c2), b2.child;
      case 14:
        return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a, b2, d2, e2, c2);
      case 15:
        return bj(a, b2, b2.type, b2.pendingProps, c2);
      case 17:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a, c2);
      case 19:
        return xj(a, b2, c2);
      case 22:
        return dj(a, b2, c2);
    }
    throw Error(p$3(156, b2.tag));
  };
  function Fk(a, b2) {
    return ac(a, b2);
  }
  function $k(a, b2, c2, d2) {
    this.tag = a;
    this.key = c2;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b2;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d2;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a, b2, c2, d2) {
    return new $k(a, b2, c2, d2);
  }
  function aj(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }
  function Zk(a) {
    if ("function" === typeof a)
      return aj(a) ? 1 : 0;
    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === Da)
        return 11;
      if (a === Ga)
        return 14;
    }
    return 2;
  }
  function Pg(a, b2) {
    var c2 = a.alternate;
    null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
    c2.flags = a.flags & 14680064;
    c2.childLanes = a.childLanes;
    c2.lanes = a.lanes;
    c2.child = a.child;
    c2.memoizedProps = a.memoizedProps;
    c2.memoizedState = a.memoizedState;
    c2.updateQueue = a.updateQueue;
    b2 = a.dependencies;
    c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
    c2.sibling = a.sibling;
    c2.index = a.index;
    c2.ref = a.ref;
    return c2;
  }
  function Rg(a, b2, c2, d2, e2, f2) {
    var g2 = 2;
    d2 = a;
    if ("function" === typeof a)
      aj(a) && (g2 = 1);
    else if ("string" === typeof a)
      g2 = 5;
    else
      a:
        switch (a) {
          case ya:
            return Tg(c2.children, e2, f2, b2);
          case za:
            g2 = 8;
            e2 |= 8;
            break;
          case Aa:
            return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
          case Ea:
            return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
          case Fa:
            return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
          case Ia:
            return pj(c2, e2, f2, b2);
          default:
            if ("object" === typeof a && null !== a)
              switch (a.$$typeof) {
                case Ba:
                  g2 = 10;
                  break a;
                case Ca:
                  g2 = 9;
                  break a;
                case Da:
                  g2 = 11;
                  break a;
                case Ga:
                  g2 = 14;
                  break a;
                case Ha:
                  g2 = 16;
                  d2 = null;
                  break a;
              }
            throw Error(p$3(130, null == a ? a : typeof a, ""));
        }
    b2 = Bg(g2, c2, b2, e2);
    b2.elementType = a;
    b2.type = d2;
    b2.lanes = f2;
    return b2;
  }
  function Tg(a, b2, c2, d2) {
    a = Bg(7, a, d2, b2);
    a.lanes = c2;
    return a;
  }
  function pj(a, b2, c2, d2) {
    a = Bg(22, a, d2, b2);
    a.elementType = Ia;
    a.lanes = c2;
    a.stateNode = { isHidden: false };
    return a;
  }
  function Qg(a, b2, c2) {
    a = Bg(6, a, null, b2);
    a.lanes = c2;
    return a;
  }
  function Sg(a, b2, c2) {
    b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
    b2.lanes = c2;
    b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
    return b2;
  }
  function al(a, b2, c2, d2, e2) {
    this.tag = b2;
    this.containerInfo = a;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d2;
    this.onRecoverableError = e2;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
    a = new al(a, b2, c2, h2, k2);
    1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
    f2 = Bg(3, null, null, b2);
    a.current = f2;
    f2.stateNode = a;
    f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f2);
    return a;
  }
  function cl(a, b2, c2) {
    var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
  }
  function dl(a) {
    if (!a)
      return Vf;
    a = a._reactInternals;
    a: {
      if (Vb(a) !== a || 1 !== a.tag)
        throw Error(p$3(170));
      var b2 = a;
      do {
        switch (b2.tag) {
          case 3:
            b2 = b2.stateNode.context;
            break a;
          case 1:
            if (Zf(b2.type)) {
              b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b2 = b2.return;
      } while (null !== b2);
      throw Error(p$3(171));
    }
    if (1 === a.tag) {
      var c2 = a.type;
      if (Zf(c2))
        return bg(a, c2, b2);
    }
    return b2;
  }
  function el(a, b2, c2, d2, e2, f2, g2, h2, k2) {
    a = bl(c2, d2, true, a, e2, f2, g2, h2, k2);
    a.context = dl(null);
    c2 = a.current;
    d2 = R();
    e2 = yi(c2);
    f2 = mh(d2, e2);
    f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
    nh(c2, f2, e2);
    a.current.lanes = e2;
    Ac(a, e2, d2);
    Dk(a, d2);
    return a;
  }
  function fl(a, b2, c2, d2) {
    var e2 = b2.current, f2 = R(), g2 = yi(e2);
    c2 = dl(c2);
    null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
    b2 = mh(f2, g2);
    b2.payload = { element: a };
    d2 = void 0 === d2 ? null : d2;
    null !== d2 && (b2.callback = d2);
    a = nh(e2, b2, g2);
    null !== a && (gi(a, e2, g2, f2), oh(a, e2, g2));
    return g2;
  }
  function gl(a) {
    a = a.current;
    if (!a.child)
      return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function hl(a, b2) {
    a = a.memoizedState;
    if (null !== a && null !== a.dehydrated) {
      var c2 = a.retryLane;
      a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
    }
  }
  function il(a, b2) {
    hl(a, b2);
    (a = a.alternate) && hl(a, b2);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a) {
    console.error(a);
  };
  function ll(a) {
    this._internalRoot = a;
  }
  ml.prototype.render = ll.prototype.render = function(a) {
    var b2 = this._internalRoot;
    if (null === b2)
      throw Error(p$3(409));
    fl(a, b2, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a = this._internalRoot;
    if (null !== a) {
      this._internalRoot = null;
      var b2 = a.containerInfo;
      Rk(function() {
        fl(null, a, null, null);
      });
      b2[uf] = null;
    }
  };
  function ml(a) {
    this._internalRoot = a;
  }
  ml.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var b2 = Hc();
      a = { blockedOn: null, target: a, priority: b2 };
      for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
        ;
      Qc.splice(c2, 0, a);
      0 === c2 && Vc(a);
    }
  };
  function nl(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
  }
  function ol(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
  }
  function pl() {
  }
  function ql(a, b2, c2, d2, e2) {
    if (e2) {
      if ("function" === typeof d2) {
        var f2 = d2;
        d2 = function() {
          var a2 = gl(g2);
          f2.call(a2);
        };
      }
      var g2 = el(b2, d2, a, 0, null, false, false, "", pl);
      a._reactRootContainer = g2;
      a[uf] = g2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Rk();
      return g2;
    }
    for (; e2 = a.lastChild; )
      a.removeChild(e2);
    if ("function" === typeof d2) {
      var h2 = d2;
      d2 = function() {
        var a2 = gl(k2);
        h2.call(a2);
      };
    }
    var k2 = bl(a, 0, false, null, null, false, false, "", pl);
    a._reactRootContainer = k2;
    a[uf] = k2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk(function() {
      fl(b2, k2, c2, d2);
    });
    return k2;
  }
  function rl(a, b2, c2, d2, e2) {
    var f2 = c2._reactRootContainer;
    if (f2) {
      var g2 = f2;
      if ("function" === typeof e2) {
        var h2 = e2;
        e2 = function() {
          var a2 = gl(g2);
          h2.call(a2);
        };
      }
      fl(b2, g2, a, e2);
    } else
      g2 = ql(c2, b2, a, e2, d2);
    return gl(g2);
  }
  Ec = function(a) {
    switch (a.tag) {
      case 3:
        var b2 = a.stateNode;
        if (b2.current.memoizedState.isDehydrated) {
          var c2 = tc(b2.pendingLanes);
          0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b3 = ih(a, 1);
          if (null !== b3) {
            var c3 = R();
            gi(b3, a, 1, c3);
          }
        }), il(a, 1);
    }
  };
  Fc = function(a) {
    if (13 === a.tag) {
      var b2 = ih(a, 134217728);
      if (null !== b2) {
        var c2 = R();
        gi(b2, a, 134217728, c2);
      }
      il(a, 134217728);
    }
  };
  Gc = function(a) {
    if (13 === a.tag) {
      var b2 = yi(a), c2 = ih(a, b2);
      if (null !== c2) {
        var d2 = R();
        gi(c2, a, b2, d2);
      }
      il(a, b2);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a, b2) {
    var c2 = C;
    try {
      return C = a, b2();
    } finally {
      C = c2;
    }
  };
  yb = function(a, b2, c2) {
    switch (b2) {
      case "input":
        bb(a, c2);
        b2 = c2.name;
        if ("radio" === c2.type && null != b2) {
          for (c2 = a; c2.parentNode; )
            c2 = c2.parentNode;
          c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
          for (b2 = 0; b2 < c2.length; b2++) {
            var d2 = c2[b2];
            if (d2 !== a && d2.form === a.form) {
              var e2 = Db(d2);
              if (!e2)
                throw Error(p$3(90));
              Wa(d2);
              bb(d2, e2);
            }
          }
        }
        break;
      case "textarea":
        ib(a, c2);
        break;
      case "select":
        b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    a = Zb(a);
    return null === a ? null : a.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber)
      try {
        kc = vl.inject(ul), lc = vl;
      } catch (a) {
      }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a, b2) {
    var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b2))
      throw Error(p$3(200));
    return cl(a, b2, null, c2);
  };
  reactDom_production_min.createRoot = function(a, b2) {
    if (!nl(a))
      throw Error(p$3(299));
    var c2 = false, d2 = "", e2 = kl;
    null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
    b2 = bl(a, 1, false, null, null, c2, false, d2, e2);
    a[uf] = b2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    return new ll(b2);
  };
  reactDom_production_min.findDOMNode = function(a) {
    if (null == a)
      return null;
    if (1 === a.nodeType)
      return a;
    var b2 = a._reactInternals;
    if (void 0 === b2) {
      if ("function" === typeof a.render)
        throw Error(p$3(188));
      a = Object.keys(a).join(",");
      throw Error(p$3(268, a));
    }
    a = Zb(b2);
    a = null === a ? null : a.stateNode;
    return a;
  };
  reactDom_production_min.flushSync = function(a) {
    return Rk(a);
  };
  reactDom_production_min.hydrate = function(a, b2, c2) {
    if (!ol(b2))
      throw Error(p$3(200));
    return rl(null, a, b2, true, c2);
  };
  reactDom_production_min.hydrateRoot = function(a, b2, c2) {
    if (!nl(a))
      throw Error(p$3(405));
    var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
    null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
    b2 = el(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
    a[uf] = b2.current;
    sf(a);
    if (d2)
      for (a = 0; a < d2.length; a++)
        c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
          c2,
          e2
        );
    return new ml(b2);
  };
  reactDom_production_min.render = function(a, b2, c2) {
    if (!ol(b2))
      throw Error(p$3(200));
    return rl(null, a, b2, false, c2);
  };
  reactDom_production_min.unmountComponentAtNode = function(a) {
    if (!ol(a))
      throw Error(p$3(40));
    return a._reactRootContainer ? (Rk(function() {
      rl(null, null, a, false, function() {
        a._reactRootContainer = null;
        a[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
    if (!ol(c2))
      throw Error(p$3(200));
    if (null == a || void 0 === a._reactInternals)
      throw Error(p$3(38));
    return rl(a, b2, c2, false, d2);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = reactDom_production_min;
  }
  var reactDomExports = reactDom.exports;
  const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
  var createRoot;
  var m$3 = reactDomExports;
  {
    createRoot = m$3.createRoot;
    m$3.hydrateRoot;
  }
  function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler == null ? void 0 : originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented) {
        return ourEventHandler == null ? void 0 : ourEventHandler(event);
      }
    };
  }
  function setRef$1(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs(...refs) {
    return (node2) => refs.forEach((ref) => setRef$1(ref, node2));
  }
  function useComposedRefs(...refs) {
    return reactExports.useCallback(composeRefs(...refs), refs);
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var f$2 = reactExports, k$2 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$2 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
  function q$2(c2, a, g2) {
    var b2, d2 = {}, e2 = null, h2 = null;
    void 0 !== g2 && (e2 = "" + g2);
    void 0 !== a.key && (e2 = "" + a.key);
    void 0 !== a.ref && (h2 = a.ref);
    for (b2 in a)
      m$2.call(a, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a[b2]);
    if (c2 && c2.defaultProps)
      for (b2 in a = c2.defaultProps, a)
        void 0 === d2[b2] && (d2[b2] = a[b2]);
    return { $$typeof: k$2, type: c2, key: e2, ref: h2, props: d2, _owner: n$2.current };
  }
  reactJsxRuntime_production_min.Fragment = l$2;
  reactJsxRuntime_production_min.jsx = q$2;
  reactJsxRuntime_production_min.jsxs = q$2;
  {
    jsxRuntime.exports = reactJsxRuntime_production_min;
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  function createContext2(rootComponentName, defaultContext) {
    const Context = reactExports.createContext(defaultContext);
    function Provider(props) {
      const { children, ...context } = props;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    }
    function useContext2(consumerName) {
      const context = reactExports.useContext(Context);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [Provider, useContext2];
  }
  function createContextScope(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function createContext3(rootComponentName, defaultContext) {
      const BaseContext = reactExports.createContext(defaultContext);
      const index = defaultContexts.length;
      defaultContexts = [...defaultContexts, defaultContext];
      function Provider(props) {
        const { scope, children, ...context } = props;
        const Context = (scope == null ? void 0 : scope[scopeName][index]) || BaseContext;
        const value = reactExports.useMemo(() => context, Object.values(context));
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
      }
      function useContext2(consumerName, scope) {
        const Context = (scope == null ? void 0 : scope[scopeName][index]) || BaseContext;
        const context = reactExports.useContext(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [Provider, useContext2];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return reactExports.createContext(defaultContext);
      });
      return function useScope(scope) {
        const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
        return reactExports.useMemo(
          () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
          [scope, contexts]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
  }
  function composeContextScopes(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope = () => {
      const scopeHooks = scopes.map((createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      }));
      return function useComposedScopes(overrideScopes) {
        const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return { ...nextScopes2, ...currentScope };
        }, {});
        return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
      };
    };
    createScope.scopeName = baseScope.scopeName;
    return createScope;
  }
  var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
  };
  var useReactId = React$2["useId".toString()] || (() => void 0);
  var count$1 = 0;
  function useId$1(deterministicId) {
    const [id2, setId] = reactExports.useState(useReactId());
    useLayoutEffect2(() => {
      if (!deterministicId)
        setId((reactId) => reactId ?? String(count$1++));
    }, [deterministicId]);
    return deterministicId || (id2 ? `radix-${id2}` : "");
  }
  function useCallbackRef$1(callback) {
    const callbackRef = reactExports.useRef(callback);
    reactExports.useEffect(() => {
      callbackRef.current = callback;
    });
    return reactExports.useMemo(() => (...args) => {
      var _a;
      return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
    }, []);
  }
  function useControllableState({
    prop,
    defaultProp,
    onChange = () => {
    }
  }) {
    const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
    const isControlled = prop !== void 0;
    const value = isControlled ? prop : uncontrolledProp;
    const handleChange = useCallbackRef$1(onChange);
    const setValue = reactExports.useCallback(
      (nextValue) => {
        if (isControlled) {
          const setter = nextValue;
          const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
          if (value2 !== prop)
            handleChange(value2);
        } else {
          setUncontrolledProp(nextValue);
        }
      },
      [isControlled, prop, setUncontrolledProp, handleChange]
    );
    return [value, setValue];
  }
  function useUncontrolledState({
    defaultProp,
    onChange
  }) {
    const uncontrolledState = reactExports.useState(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = reactExports.useRef(value);
    const handleChange = useCallbackRef$1(onChange);
    reactExports.useEffect(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [value, prevValueRef, handleChange]);
    return uncontrolledState;
  }
  var Slot = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1)
            return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot.displayName = "Slot";
  var SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef$1(children);
      return reactExports.cloneElement(children, {
        ...mergeProps(slotProps, children.props),
        // @ts-ignore
        ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
      });
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = "SlotClone";
  var Slottable = ({ children }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  };
  function isSlottable(child) {
    return reactExports.isValidElement(child) && child.type === Slottable;
  }
  function mergeProps(slotProps, childProps) {
    const overrideProps = { ...childProps };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue) {
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        } else if (slotPropValue) {
          overrideProps[propName] = slotPropValue;
        }
      } else if (propName === "style") {
        overrideProps[propName] = { ...slotPropValue, ...childPropValue };
      } else if (propName === "className") {
        overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
      }
    }
    return { ...slotProps, ...overrideProps };
  }
  function getElementRef$1(element) {
    var _a, _b;
    let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }
  var NODES = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var Primitive = NODES.reduce((primitive, node2) => {
    const Node = reactExports.forwardRef((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? Slot : node2;
      if (typeof window !== "undefined") {
        window[Symbol.for("radix-ui")] = true;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
    });
    Node.displayName = `Primitive.${node2}`;
    return { ...primitive, [node2]: Node };
  }, {});
  function dispatchDiscreteCustomEvent(target, event) {
    if (target)
      reactDomExports.flushSync(() => target.dispatchEvent(event));
  }
  function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument2 = globalThis == null ? void 0 : globalThis.document) {
    const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
    reactExports.useEffect(() => {
      const handleKeyDown2 = (event) => {
        if (event.key === "Escape") {
          onEscapeKeyDown(event);
        }
      };
      ownerDocument2.addEventListener("keydown", handleKeyDown2, { capture: true });
      return () => ownerDocument2.removeEventListener("keydown", handleKeyDown2, { capture: true });
    }, [onEscapeKeyDown, ownerDocument2]);
  }
  var DISMISSABLE_LAYER_NAME = "DismissableLayer";
  var CONTEXT_UPDATE = "dismissableLayer.update";
  var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
  var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
  var originalBodyPointerEvents;
  var DismissableLayerContext = reactExports.createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  var DismissableLayer = reactExports.forwardRef(
    (props, forwardedRef) => {
      const {
        disableOutsidePointerEvents = false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss,
        ...layerProps
      } = props;
      const context = reactExports.useContext(DismissableLayerContext);
      const [node2, setNode] = reactExports.useState(null);
      const ownerDocument2 = (node2 == null ? void 0 : node2.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
      const [, force] = reactExports.useState({});
      const composedRefs = useComposedRefs(forwardedRef, (node22) => setNode(node22));
      const layers = Array.from(context.layers);
      const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
      const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
      const index = node2 ? layers.indexOf(node2) : -1;
      const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
      const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;
      const pointerDownOutside = usePointerDownOutside((event) => {
        const target = event.target;
        const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
        if (!isPointerEventsEnabled || isPointerDownOnBranch)
          return;
        onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
        onInteractOutside == null ? void 0 : onInteractOutside(event);
        if (!event.defaultPrevented)
          onDismiss == null ? void 0 : onDismiss();
      }, ownerDocument2);
      const focusOutside = useFocusOutside((event) => {
        const target = event.target;
        const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
        if (isFocusInBranch)
          return;
        onFocusOutside == null ? void 0 : onFocusOutside(event);
        onInteractOutside == null ? void 0 : onInteractOutside(event);
        if (!event.defaultPrevented)
          onDismiss == null ? void 0 : onDismiss();
      }, ownerDocument2);
      useEscapeKeydown((event) => {
        const isHighestLayer = index === context.layers.size - 1;
        if (!isHighestLayer)
          return;
        onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
        if (!event.defaultPrevented && onDismiss) {
          event.preventDefault();
          onDismiss();
        }
      }, ownerDocument2);
      reactExports.useEffect(() => {
        if (!node2)
          return;
        if (disableOutsidePointerEvents) {
          if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
            originalBodyPointerEvents = ownerDocument2.body.style.pointerEvents;
            ownerDocument2.body.style.pointerEvents = "none";
          }
          context.layersWithOutsidePointerEventsDisabled.add(node2);
        }
        context.layers.add(node2);
        dispatchUpdate();
        return () => {
          if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
            ownerDocument2.body.style.pointerEvents = originalBodyPointerEvents;
          }
        };
      }, [node2, ownerDocument2, disableOutsidePointerEvents, context]);
      reactExports.useEffect(() => {
        return () => {
          if (!node2)
            return;
          context.layers.delete(node2);
          context.layersWithOutsidePointerEventsDisabled.delete(node2);
          dispatchUpdate();
        };
      }, [node2, context]);
      reactExports.useEffect(() => {
        const handleUpdate = () => force({});
        document.addEventListener(CONTEXT_UPDATE, handleUpdate);
        return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          ...layerProps,
          ref: composedRefs,
          style: {
            pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
            ...props.style
          },
          onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
          onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
          onPointerDownCapture: composeEventHandlers(
            props.onPointerDownCapture,
            pointerDownOutside.onPointerDownCapture
          )
        }
      );
    }
  );
  DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
  var BRANCH_NAME = "DismissableLayerBranch";
  var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
    const context = reactExports.useContext(DismissableLayerContext);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      const node2 = ref.current;
      if (node2) {
        context.branches.add(node2);
        return () => {
          context.branches.delete(node2);
        };
      }
    }, [context.branches]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
  });
  DismissableLayerBranch.displayName = BRANCH_NAME;
  function usePointerDownOutside(onPointerDownOutside, ownerDocument2 = globalThis == null ? void 0 : globalThis.document) {
    const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
    const isPointerInsideReactTreeRef = reactExports.useRef(false);
    const handleClickRef = reactExports.useRef(() => {
    });
    reactExports.useEffect(() => {
      const handlePointerDown2 = (event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent2 = function() {
            handleAndDispatchCustomEvent(
              POINTER_DOWN_OUTSIDE,
              handlePointerDownOutside,
              eventDetail,
              { discrete: true }
            );
          };
          const eventDetail = { originalEvent: event };
          if (event.pointerType === "touch") {
            ownerDocument2.removeEventListener("click", handleClickRef.current);
            handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
            ownerDocument2.addEventListener("click", handleClickRef.current, { once: true });
          } else {
            handleAndDispatchPointerDownOutsideEvent2();
          }
        } else {
          ownerDocument2.removeEventListener("click", handleClickRef.current);
        }
        isPointerInsideReactTreeRef.current = false;
      };
      const timerId = window.setTimeout(() => {
        ownerDocument2.addEventListener("pointerdown", handlePointerDown2);
      }, 0);
      return () => {
        window.clearTimeout(timerId);
        ownerDocument2.removeEventListener("pointerdown", handlePointerDown2);
        ownerDocument2.removeEventListener("click", handleClickRef.current);
      };
    }, [ownerDocument2, handlePointerDownOutside]);
    return {
      // ensures we check React component tree (not just DOM tree)
      onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
    };
  }
  function useFocusOutside(onFocusOutside, ownerDocument2 = globalThis == null ? void 0 : globalThis.document) {
    const handleFocusOutside = useCallbackRef$1(onFocusOutside);
    const isFocusInsideReactTreeRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const handleFocus = (event) => {
        if (event.target && !isFocusInsideReactTreeRef.current) {
          const eventDetail = { originalEvent: event };
          handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
            discrete: false
          });
        }
      };
      ownerDocument2.addEventListener("focusin", handleFocus);
      return () => ownerDocument2.removeEventListener("focusin", handleFocus);
    }, [ownerDocument2, handleFocusOutside]);
    return {
      onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
      onBlurCapture: () => isFocusInsideReactTreeRef.current = false
    };
  }
  function dispatchUpdate() {
    const event = new CustomEvent(CONTEXT_UPDATE);
    document.dispatchEvent(event);
  }
  function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
    if (handler)
      target.addEventListener(name, handler, { once: true });
    if (discrete) {
      dispatchDiscreteCustomEvent(target, event);
    } else {
      target.dispatchEvent(event);
    }
  }
  var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
  var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
  var EVENT_OPTIONS = { bubbles: false, cancelable: true };
  var FOCUS_SCOPE_NAME = "FocusScope";
  var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
    const {
      loop = false,
      trapped = false,
      onMountAutoFocus: onMountAutoFocusProp,
      onUnmountAutoFocus: onUnmountAutoFocusProp,
      ...scopeProps
    } = props;
    const [container, setContainer] = reactExports.useState(null);
    const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
    const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
    const lastFocusedElementRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setContainer(node2));
    const focusScope = reactExports.useRef({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }).current;
    reactExports.useEffect(() => {
      if (trapped) {
        let handleFocusIn2 = function(event) {
          if (focusScope.paused || !container)
            return;
          const target = event.target;
          if (container.contains(target)) {
            lastFocusedElementRef.current = target;
          } else {
            focus(lastFocusedElementRef.current, { select: true });
          }
        }, handleFocusOut2 = function(event) {
          if (focusScope.paused || !container)
            return;
          const relatedTarget = event.relatedTarget;
          if (relatedTarget === null)
            return;
          if (!container.contains(relatedTarget)) {
            focus(lastFocusedElementRef.current, { select: true });
          }
        }, handleMutations2 = function(mutations) {
          const focusedElement = document.activeElement;
          if (focusedElement !== document.body)
            return;
          for (const mutation of mutations) {
            if (mutation.removedNodes.length > 0)
              focus(container);
          }
        };
        document.addEventListener("focusin", handleFocusIn2);
        document.addEventListener("focusout", handleFocusOut2);
        const mutationObserver = new MutationObserver(handleMutations2);
        if (container)
          mutationObserver.observe(container, { childList: true, subtree: true });
        return () => {
          document.removeEventListener("focusin", handleFocusIn2);
          document.removeEventListener("focusout", handleFocusOut2);
          mutationObserver.disconnect();
        };
      }
    }, [trapped, container, focusScope.paused]);
    reactExports.useEffect(() => {
      if (container) {
        focusScopesStack.add(focusScope);
        const previouslyFocusedElement = document.activeElement;
        const hasFocusedCandidate = container.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
          const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          container.dispatchEvent(mountEvent);
          if (!mountEvent.defaultPrevented) {
            focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
            if (document.activeElement === previouslyFocusedElement) {
              focus(container);
            }
          }
        }
        return () => {
          container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          setTimeout(() => {
            const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
            container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            container.dispatchEvent(unmountEvent);
            if (!unmountEvent.defaultPrevented) {
              focus(previouslyFocusedElement ?? document.body, { select: true });
            }
            container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            focusScopesStack.remove(focusScope);
          }, 0);
        };
      }
    }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
    const handleKeyDown2 = reactExports.useCallback(
      (event) => {
        if (!loop && !trapped)
          return;
        if (focusScope.paused)
          return;
        const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
        const focusedElement = document.activeElement;
        if (isTabKey && focusedElement) {
          const container2 = event.currentTarget;
          const [first, last] = getTabbableEdges(container2);
          const hasTabbableElementsInside = first && last;
          if (!hasTabbableElementsInside) {
            if (focusedElement === container2)
              event.preventDefault();
          } else {
            if (!event.shiftKey && focusedElement === last) {
              event.preventDefault();
              if (loop)
                focus(first, { select: true });
            } else if (event.shiftKey && focusedElement === first) {
              event.preventDefault();
              if (loop)
                focus(last, { select: true });
            }
          }
        }
      },
      [loop, trapped, focusScope.paused]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown2 });
  });
  FocusScope.displayName = FOCUS_SCOPE_NAME;
  function focusFirst(candidates, { select = false } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates) {
      focus(candidate, { select });
      if (document.activeElement !== previouslyFocusedElement)
        return;
    }
  }
  function getTabbableEdges(container) {
    const candidates = getTabbableCandidates(container);
    const first = findVisible(candidates, container);
    const last = findVisible(candidates.reverse(), container);
    return [first, last];
  }
  function getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node2) => {
        const isHiddenInput = node2.tagName === "INPUT" && node2.type === "hidden";
        if (node2.disabled || node2.hidden || isHiddenInput)
          return NodeFilter.FILTER_SKIP;
        return node2.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode())
      nodes.push(walker.currentNode);
    return nodes;
  }
  function findVisible(elements, container) {
    for (const element of elements) {
      if (!isHidden(element, { upTo: container }))
        return element;
    }
  }
  function isHidden(node2, { upTo }) {
    if (getComputedStyle(node2).visibility === "hidden")
      return true;
    while (node2) {
      if (upTo !== void 0 && node2 === upTo)
        return false;
      if (getComputedStyle(node2).display === "none")
        return true;
      node2 = node2.parentElement;
    }
    return false;
  }
  function isSelectableInput(element) {
    return element instanceof HTMLInputElement && "select" in element;
  }
  function focus(element, { select = false } = {}) {
    if (element && element.focus) {
      const previouslyFocusedElement = document.activeElement;
      element.focus({ preventScroll: true });
      if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
        element.select();
    }
  }
  var focusScopesStack = createFocusScopesStack();
  function createFocusScopesStack() {
    let stack = [];
    return {
      add(focusScope) {
        const activeFocusScope = stack[0];
        if (focusScope !== activeFocusScope) {
          activeFocusScope == null ? void 0 : activeFocusScope.pause();
        }
        stack = arrayRemove(stack, focusScope);
        stack.unshift(focusScope);
      },
      remove(focusScope) {
        var _a;
        stack = arrayRemove(stack, focusScope);
        (_a = stack[0]) == null ? void 0 : _a.resume();
      }
    };
  }
  function arrayRemove(array, item) {
    const updatedArray = [...array];
    const index = updatedArray.indexOf(item);
    if (index !== -1) {
      updatedArray.splice(index, 1);
    }
    return updatedArray;
  }
  function removeLinks(items) {
    return items.filter((item) => item.tagName !== "A");
  }
  var PORTAL_NAME$1 = "Portal";
  var Portal$2 = reactExports.forwardRef((props, forwardedRef) => {
    var _a;
    const { container: containerProp, ...portalProps } = props;
    const [mounted, setMounted] = reactExports.useState(false);
    useLayoutEffect2(() => setMounted(true), []);
    const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
    return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
  });
  Portal$2.displayName = PORTAL_NAME$1;
  function useStateMachine(initialState, machine) {
    return reactExports.useReducer((state, event) => {
      const nextState = machine[state][event];
      return nextState ?? state;
    }, initialState);
  }
  var Presence = (props) => {
    const { present, children } = props;
    const presence = usePresence(present);
    const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
    const ref = useComposedRefs(presence.ref, getElementRef(child));
    const forceMount = typeof children === "function";
    return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
  };
  Presence.displayName = "Presence";
  function usePresence(present) {
    const [node2, setNode] = reactExports.useState();
    const stylesRef = reactExports.useRef({});
    const prevPresentRef = reactExports.useRef(present);
    const prevAnimationNameRef = reactExports.useRef("none");
    const initialState = present ? "mounted" : "unmounted";
    const [state, send] = useStateMachine(initialState, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    reactExports.useEffect(() => {
      const currentAnimationName = getAnimationName(stylesRef.current);
      prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
    }, [state]);
    useLayoutEffect2(() => {
      const styles2 = stylesRef.current;
      const wasPresent = prevPresentRef.current;
      const hasPresentChanged = wasPresent !== present;
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.current;
        const currentAnimationName = getAnimationName(styles2);
        if (present) {
          send("MOUNT");
        } else if (currentAnimationName === "none" || (styles2 == null ? void 0 : styles2.display) === "none") {
          send("UNMOUNT");
        } else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (wasPresent && isAnimating) {
            send("ANIMATION_OUT");
          } else {
            send("UNMOUNT");
          }
        }
        prevPresentRef.current = present;
      }
    }, [present, send]);
    useLayoutEffect2(() => {
      if (node2) {
        const handleAnimationEnd = (event) => {
          const currentAnimationName = getAnimationName(stylesRef.current);
          const isCurrentAnimation = currentAnimationName.includes(event.animationName);
          if (event.target === node2 && isCurrentAnimation) {
            reactDomExports.flushSync(() => send("ANIMATION_END"));
          }
        };
        const handleAnimationStart = (event) => {
          if (event.target === node2) {
            prevAnimationNameRef.current = getAnimationName(stylesRef.current);
          }
        };
        node2.addEventListener("animationstart", handleAnimationStart);
        node2.addEventListener("animationcancel", handleAnimationEnd);
        node2.addEventListener("animationend", handleAnimationEnd);
        return () => {
          node2.removeEventListener("animationstart", handleAnimationStart);
          node2.removeEventListener("animationcancel", handleAnimationEnd);
          node2.removeEventListener("animationend", handleAnimationEnd);
        };
      } else {
        send("ANIMATION_END");
      }
    }, [node2, send]);
    return {
      isPresent: ["mounted", "unmountSuspended"].includes(state),
      ref: reactExports.useCallback((node22) => {
        if (node22)
          stylesRef.current = getComputedStyle(node22);
        setNode(node22);
      }, [])
    };
  }
  function getAnimationName(styles2) {
    return (styles2 == null ? void 0 : styles2.animationName) || "none";
  }
  function getElementRef(element) {
    var _a, _b;
    let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }
  var count = 0;
  function useFocusGuards() {
    reactExports.useEffect(() => {
      const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
      document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
      document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
      count++;
      return () => {
        if (count === 1) {
          document.querySelectorAll("[data-radix-focus-guard]").forEach((node2) => node2.remove());
        }
        count--;
      };
    }, []);
  }
  function createFocusGuard() {
    const element = document.createElement("span");
    element.setAttribute("data-radix-focus-guard", "");
    element.tabIndex = 0;
    element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
    return element;
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t2) {
      for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
        s = arguments[i];
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2))
            t2[p2] = s[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  }
  function __spreadArray(to, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
        if (ar || !(i in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e2 = new Error(message);
    return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
  };
  var zeroRightClassName = "right-scroll-bar-position";
  var fullWidthClassName = "width-before-scroll-bar";
  var noScrollbarsClassName = "with-scroll-bars-hidden";
  var removedBarSizeVariable = "--removed-body-scroll-bar-size";
  function assignRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
    return ref;
  }
  function useCallbackRef(initialValue, callback) {
    var ref = reactExports.useState(function() {
      return {
        // value
        value: initialValue,
        // last callback
        callback,
        // "memoized" public interface
        facade: {
          get current() {
            return ref.value;
          },
          set current(value) {
            var last = ref.value;
            if (last !== value) {
              ref.value = value;
              ref.callback(value, last);
            }
          }
        }
      };
    })[0];
    ref.callback = callback;
    return ref.facade;
  }
  var useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  var currentValues = /* @__PURE__ */ new WeakMap();
  function useMergeRefs(refs, defaultValue) {
    var callbackRef = useCallbackRef(null, function(newValue) {
      return refs.forEach(function(ref) {
        return assignRef(ref, newValue);
      });
    });
    useIsomorphicLayoutEffect(function() {
      var oldValue = currentValues.get(callbackRef);
      if (oldValue) {
        var prevRefs_1 = new Set(oldValue);
        var nextRefs_1 = new Set(refs);
        var current_1 = callbackRef.current;
        prevRefs_1.forEach(function(ref) {
          if (!nextRefs_1.has(ref)) {
            assignRef(ref, null);
          }
        });
        nextRefs_1.forEach(function(ref) {
          if (!prevRefs_1.has(ref)) {
            assignRef(ref, current_1);
          }
        });
      }
      currentValues.set(callbackRef, refs);
    }, [refs]);
    return callbackRef;
  }
  function ItoI(a) {
    return a;
  }
  function innerCreateMedium(defaults2, middleware2) {
    if (middleware2 === void 0) {
      middleware2 = ItoI;
    }
    var buffer = [];
    var assigned = false;
    var medium = {
      read: function() {
        if (assigned) {
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        }
        if (buffer.length) {
          return buffer[buffer.length - 1];
        }
        return defaults2;
      },
      useMedium: function(data) {
        var item = middleware2(data, assigned);
        buffer.push(item);
        return function() {
          buffer = buffer.filter(function(x2) {
            return x2 !== item;
          });
        };
      },
      assignSyncMedium: function(cb2) {
        assigned = true;
        while (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb2);
        }
        buffer = {
          push: function(x2) {
            return cb2(x2);
          },
          filter: function() {
            return buffer;
          }
        };
      },
      assignMedium: function(cb2) {
        assigned = true;
        var pendingQueue = [];
        if (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb2);
          pendingQueue = buffer;
        }
        var executeQueue = function() {
          var cbs2 = pendingQueue;
          pendingQueue = [];
          cbs2.forEach(cb2);
        };
        var cycle = function() {
          return Promise.resolve().then(executeQueue);
        };
        cycle();
        buffer = {
          push: function(x2) {
            pendingQueue.push(x2);
            cycle();
          },
          filter: function(filter) {
            pendingQueue = pendingQueue.filter(filter);
            return buffer;
          }
        };
      }
    };
    return medium;
  }
  function createSidecarMedium(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var medium = innerCreateMedium(null);
    medium.options = __assign({ async: true, ssr: false }, options2);
    return medium;
  }
  var SideCar$1 = function(_a) {
    var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
    if (!sideCar) {
      throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    }
    var Target = sideCar.read();
    if (!Target) {
      throw new Error("Sidecar medium not found");
    }
    return reactExports.createElement(Target, __assign({}, rest));
  };
  SideCar$1.isSideCarExport = true;
  function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar$1;
  }
  var effectCar = createSidecarMedium();
  var nothing = function() {
    return;
  };
  var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
    var ref = reactExports.useRef(null);
    var _a = reactExports.useState({
      onScrollCapture: nothing,
      onWheelCapture: nothing,
      onTouchMoveCapture: nothing
    }), callbacks = _a[0], setCallbacks = _a[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
    var SideCar2 = sideCar;
    var containerRef = useMergeRefs([ref, parentRef]);
    var containerProps = __assign(__assign({}, rest), callbacks);
    return reactExports.createElement(
      reactExports.Fragment,
      null,
      enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
      forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
    );
  });
  RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
  };
  RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
  };
  var getNonce = function() {
    if (typeof __webpack_nonce__ !== "undefined") {
      return __webpack_nonce__;
    }
    return void 0;
  };
  function makeStyleTag() {
    if (!document)
      return null;
    var tag = document.createElement("style");
    tag.type = "text/css";
    var nonce = getNonce();
    if (nonce) {
      tag.setAttribute("nonce", nonce);
    }
    return tag;
  }
  function injectStyles(tag, css2) {
    if (tag.styleSheet) {
      tag.styleSheet.cssText = css2;
    } else {
      tag.appendChild(document.createTextNode(css2));
    }
  }
  function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName("head")[0];
    head.appendChild(tag);
  }
  var stylesheetSingleton = function() {
    var counter = 0;
    var stylesheet = null;
    return {
      add: function(style2) {
        if (counter == 0) {
          if (stylesheet = makeStyleTag()) {
            injectStyles(stylesheet, style2);
            insertStyleTag(stylesheet);
          }
        }
        counter++;
      },
      remove: function() {
        counter--;
        if (!counter && stylesheet) {
          stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
          stylesheet = null;
        }
      }
    };
  };
  var styleHookSingleton = function() {
    var sheet = stylesheetSingleton();
    return function(styles2, isDynamic) {
      reactExports.useEffect(function() {
        sheet.add(styles2);
        return function() {
          sheet.remove();
        };
      }, [styles2 && isDynamic]);
    };
  };
  var styleSingleton = function() {
    var useStyle = styleHookSingleton();
    var Sheet = function(_a) {
      var styles2 = _a.styles, dynamic = _a.dynamic;
      useStyle(styles2, dynamic);
      return null;
    };
    return Sheet;
  };
  var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  };
  var parse$1 = function(x2) {
    return parseInt(x2 || "", 10) || 0;
  };
  var getOffset = function(gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left2 = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
    var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
    var right2 = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
    return [parse$1(left2), parse$1(top2), parse$1(right2)];
  };
  var getGapWidth = function(gapMode) {
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    if (typeof window === "undefined") {
      return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
      left: offsets[0],
      top: offsets[1],
      right: offsets[2],
      gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
    };
  };
  var Style = styleSingleton();
  var lockAttribute = "data-scroll-locked";
  var getStyles = function(_a, allowRelative, gapMode, important) {
    var left2 = _a.left, top2 = _a.top, right2 = _a.right, gap2 = _a.gap;
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap2, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
      allowRelative && "position: relative ".concat(important, ";"),
      gapMode === "margin" && "\n    padding-left: ".concat(left2, "px;\n    padding-top: ").concat(top2, "px;\n    padding-right: ").concat(right2, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap2, "px ").concat(important, ";\n    "),
      gapMode === "padding" && "padding-right: ".concat(gap2, "px ").concat(important, ";")
    ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap2, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap2, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap2, "px;\n  }\n");
  };
  var getCurrentUseCounter = function() {
    var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
    return isFinite(counter) ? counter : 0;
  };
  var useLockAttribute = function() {
    reactExports.useEffect(function() {
      document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
      return function() {
        var newCounter = getCurrentUseCounter() - 1;
        if (newCounter <= 0) {
          document.body.removeAttribute(lockAttribute);
        } else {
          document.body.setAttribute(lockAttribute, newCounter.toString());
        }
      };
    }, []);
  };
  var RemoveScrollBar = function(_a) {
    var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
    useLockAttribute();
    var gap2 = reactExports.useMemo(function() {
      return getGapWidth(gapMode);
    }, [gapMode]);
    return reactExports.createElement(Style, { styles: getStyles(gap2, !noRelative, gapMode, !noImportant ? "!important" : "") });
  };
  var passiveSupported = false;
  if (typeof window !== "undefined") {
    try {
      var options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
          return true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported = false;
    }
  }
  var nonPassive = passiveSupported ? { passive: false } : false;
  var alwaysContainsScroll = function(node2) {
    return node2.tagName === "TEXTAREA";
  };
  var elementCanBeScrolled = function(node2, overflow) {
    var styles2 = window.getComputedStyle(node2);
    return (
      // not-not-scrollable
      styles2[overflow] !== "hidden" && // contains scroll inside self
      !(styles2.overflowY === styles2.overflowX && !alwaysContainsScroll(node2) && styles2[overflow] === "visible")
    );
  };
  var elementCouldBeVScrolled = function(node2) {
    return elementCanBeScrolled(node2, "overflowY");
  };
  var elementCouldBeHScrolled = function(node2) {
    return elementCanBeScrolled(node2, "overflowX");
  };
  var locationCouldBeScrolled = function(axis, node2) {
    var ownerDocument2 = node2.ownerDocument;
    var current = node2;
    do {
      if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
        current = current.host;
      }
      var isScrollable = elementCouldBeScrolled(axis, current);
      if (isScrollable) {
        var _a = getScrollVariables(axis, current), s = _a[1], d2 = _a[2];
        if (s > d2) {
          return true;
        }
      }
      current = current.parentNode;
    } while (current && current !== ownerDocument2.body);
    return false;
  };
  var getVScrollVariables = function(_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [
      scrollTop,
      scrollHeight,
      clientHeight
    ];
  };
  var getHScrollVariables = function(_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [
      scrollLeft,
      scrollWidth,
      clientWidth
    ];
  };
  var elementCouldBeScrolled = function(axis, node2) {
    return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
  };
  var getScrollVariables = function(axis, node2) {
    return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
  };
  var getDirectionFactor = function(axis, direction) {
    return axis === "h" && direction === "rtl" ? -1 : 1;
  };
  var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
      var _a = getScrollVariables(axis, target), position2 = _a[0], scroll_1 = _a[1], capacity = _a[2];
      var elementScroll = scroll_1 - capacity - directionFactor * position2;
      if (position2 || elementScroll) {
        if (elementCouldBeScrolled(axis, target)) {
          availableScroll += elementScroll;
          availableScrollTop += position2;
        }
      }
      if (target instanceof ShadowRoot) {
        target = target.host;
      } else {
        target = target.parentNode;
      }
    } while (
      // portaled content
      !targetInLock && target !== document.body || // self content
      targetInLock && (endTarget.contains(target) || endTarget === target)
    );
    if (isDeltaPositive && (Math.abs(availableScroll) < 1 || !noOverscroll)) {
      shouldCancelScroll = true;
    } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || !noOverscroll)) {
      shouldCancelScroll = true;
    }
    return shouldCancelScroll;
  };
  var getTouchXY = function(event) {
    return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
  };
  var getDeltaXY = function(event) {
    return [event.deltaX, event.deltaY];
  };
  var extractRef = function(ref) {
    return ref && "current" in ref ? ref.current : ref;
  };
  var deltaCompare = function(x2, y2) {
    return x2[0] === y2[0] && x2[1] === y2[1];
  };
  var generateStyle = function(id2) {
    return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
  };
  var idCounter = 0;
  var lockStack = [];
  function RemoveScrollSideCar(props) {
    var shouldPreventQueue = reactExports.useRef([]);
    var touchStartRef = reactExports.useRef([0, 0]);
    var activeAxis = reactExports.useRef();
    var id2 = reactExports.useState(idCounter++)[0];
    var Style2 = reactExports.useState(styleSingleton)[0];
    var lastProps = reactExports.useRef(props);
    reactExports.useEffect(function() {
      lastProps.current = props;
    }, [props]);
    reactExports.useEffect(function() {
      if (props.inert) {
        document.body.classList.add("block-interactivity-".concat(id2));
        var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
        allow_1.forEach(function(el2) {
          return el2.classList.add("allow-interactivity-".concat(id2));
        });
        return function() {
          document.body.classList.remove("block-interactivity-".concat(id2));
          allow_1.forEach(function(el2) {
            return el2.classList.remove("allow-interactivity-".concat(id2));
          });
        };
      }
      return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
      if ("touches" in event && event.touches.length === 2) {
        return !lastProps.current.allowPinchZoom;
      }
      var touch = getTouchXY(event);
      var touchStart = touchStartRef.current;
      var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
      var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
      var currentAxis;
      var target = event.target;
      var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
      if ("touches" in event && moveDirection === "h" && target.type === "range") {
        return false;
      }
      var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      if (!canBeScrolledInMainDirection) {
        return true;
      }
      if (canBeScrolledInMainDirection) {
        currentAxis = moveDirection;
      } else {
        currentAxis = moveDirection === "v" ? "h" : "v";
        canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      }
      if (!canBeScrolledInMainDirection) {
        return false;
      }
      if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
        activeAxis.current = currentAxis;
      }
      if (!currentAxis) {
        return true;
      }
      var cancelingAxis = activeAxis.current || currentAxis;
      return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
    }, []);
    var shouldPrevent = reactExports.useCallback(function(_event) {
      var event = _event;
      if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
        return;
      }
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
      var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
        return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
      })[0];
      if (sourceEvent && sourceEvent.should) {
        if (event.cancelable) {
          event.preventDefault();
        }
        return;
      }
      if (!sourceEvent) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node2) {
          return node2.contains(event.target);
        });
        var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        if (shouldStop) {
          if (event.cancelable) {
            event.preventDefault();
          }
        }
      }
    }, []);
    var shouldCancel = reactExports.useCallback(function(name, delta, target, should) {
      var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
      shouldPreventQueue.current.push(event);
      setTimeout(function() {
        shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
          return e2 !== event;
        });
      }, 1);
    }, []);
    var scrollTouchStart = reactExports.useCallback(function(event) {
      touchStartRef.current = getTouchXY(event);
      activeAxis.current = void 0;
    }, []);
    var scrollWheel = reactExports.useCallback(function(event) {
      shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = reactExports.useCallback(function(event) {
      shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    reactExports.useEffect(function() {
      lockStack.push(Style2);
      props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove
      });
      document.addEventListener("wheel", shouldPrevent, nonPassive);
      document.addEventListener("touchmove", shouldPrevent, nonPassive);
      document.addEventListener("touchstart", scrollTouchStart, nonPassive);
      return function() {
        lockStack = lockStack.filter(function(inst) {
          return inst !== Style2;
        });
        document.removeEventListener("wheel", shouldPrevent, nonPassive);
        document.removeEventListener("touchmove", shouldPrevent, nonPassive);
        document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
      };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return reactExports.createElement(
      reactExports.Fragment,
      null,
      inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
      removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
    );
  }
  function getOutermostShadowParent(node2) {
    var shadowParent = null;
    while (node2 !== null) {
      if (node2 instanceof ShadowRoot) {
        shadowParent = node2.host;
        node2 = node2.host;
      }
      node2 = node2.parentNode;
    }
    return shadowParent;
  }
  const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
  var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
    return reactExports.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
  });
  ReactRemoveScroll.classNames = RemoveScroll.classNames;
  var getDefaultParent = function(originalTarget) {
    if (typeof document === "undefined") {
      return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
  };
  var counterMap = /* @__PURE__ */ new WeakMap();
  var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
  var markerMap = {};
  var lockCount = 0;
  var unwrapHost = function(node2) {
    return node2 && (node2.host || unwrapHost(node2.parentNode));
  };
  var correctTargets = function(parent, targets) {
    return targets.map(function(target) {
      if (parent.contains(target)) {
        return target;
      }
      var correctedTarget = unwrapHost(target);
      if (correctedTarget && parent.contains(correctedTarget)) {
        return correctedTarget;
      }
      console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
      return null;
    }).filter(function(x2) {
      return Boolean(x2);
    });
  };
  var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    if (!markerMap[markerName]) {
      markerMap[markerName] = /* @__PURE__ */ new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = /* @__PURE__ */ new Set();
    var elementsToStop = new Set(targets);
    var keep = function(el2) {
      if (!el2 || elementsToKeep.has(el2)) {
        return;
      }
      elementsToKeep.add(el2);
      keep(el2.parentNode);
    };
    targets.forEach(keep);
    var deep = function(parent) {
      if (!parent || elementsToStop.has(parent)) {
        return;
      }
      Array.prototype.forEach.call(parent.children, function(node2) {
        if (elementsToKeep.has(node2)) {
          deep(node2);
        } else {
          try {
            var attr = node2.getAttribute(controlAttribute);
            var alreadyHidden = attr !== null && attr !== "false";
            var counterValue = (counterMap.get(node2) || 0) + 1;
            var markerValue = (markerCounter.get(node2) || 0) + 1;
            counterMap.set(node2, counterValue);
            markerCounter.set(node2, markerValue);
            hiddenNodes.push(node2);
            if (counterValue === 1 && alreadyHidden) {
              uncontrolledNodes.set(node2, true);
            }
            if (markerValue === 1) {
              node2.setAttribute(markerName, "true");
            }
            if (!alreadyHidden) {
              node2.setAttribute(controlAttribute, "true");
            }
          } catch (e2) {
            console.error("aria-hidden: cannot operate on ", node2, e2);
          }
        }
      });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function() {
      hiddenNodes.forEach(function(node2) {
        var counterValue = counterMap.get(node2) - 1;
        var markerValue = markerCounter.get(node2) - 1;
        counterMap.set(node2, counterValue);
        markerCounter.set(node2, markerValue);
        if (!counterValue) {
          if (!uncontrolledNodes.has(node2)) {
            node2.removeAttribute(controlAttribute);
          }
          uncontrolledNodes.delete(node2);
        }
        if (!markerValue) {
          node2.removeAttribute(markerName);
        }
      });
      lockCount--;
      if (!lockCount) {
        counterMap = /* @__PURE__ */ new WeakMap();
        counterMap = /* @__PURE__ */ new WeakMap();
        uncontrolledNodes = /* @__PURE__ */ new WeakMap();
        markerMap = {};
      }
    };
  };
  var hideOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
      markerName = "data-aria-hidden";
    }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = getDefaultParent(originalTarget);
    if (!activeParentNode) {
      return function() {
        return null;
      };
    }
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
    return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
  };
  var DIALOG_NAME = "Dialog";
  var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
  var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
  var Dialog$1 = (props) => {
    const {
      __scopeDialog,
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      modal = true
    } = props;
    const triggerRef = reactExports.useRef(null);
    const contentRef = reactExports.useRef(null);
    const [open = false, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogProvider,
      {
        scope: __scopeDialog,
        triggerRef,
        contentRef,
        contentId: useId$1(),
        titleId: useId$1(),
        descriptionId: useId$1(),
        open,
        onOpenChange: setOpen,
        onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        modal,
        children
      }
    );
  };
  Dialog$1.displayName = DIALOG_NAME;
  var TRIGGER_NAME = "DialogTrigger";
  var DialogTrigger = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...triggerProps } = props;
      const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
      const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": context.open,
          "aria-controls": context.contentId,
          "data-state": getState(context.open),
          ...triggerProps,
          ref: composedTriggerRef,
          onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
        }
      );
    }
  );
  DialogTrigger.displayName = TRIGGER_NAME;
  var PORTAL_NAME = "DialogPortal";
  var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME, {
    forceMount: void 0
  });
  var DialogPortal = (props) => {
    const { __scopeDialog, forceMount, children, container } = props;
    const context = useDialogContext(PORTAL_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { asChild: true, container, children: child }) })) });
  };
  DialogPortal.displayName = PORTAL_NAME;
  var OVERLAY_NAME = "DialogOverlay";
  var DialogOverlay = reactExports.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
      const { forceMount = portalContext.forceMount, ...overlayProps } = props;
      const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
      return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
    }
  );
  DialogOverlay.displayName = OVERLAY_NAME;
  var DialogOverlayImpl = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...overlayProps } = props;
      const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
      return (
        // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
        // ie. when `Overlay` and `Content` are siblings
        /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            "data-state": getState(context.open),
            ...overlayProps,
            ref: forwardedRef,
            style: { pointerEvents: "auto", ...overlayProps.style }
          }
        ) })
      );
    }
  );
  var CONTENT_NAME = "DialogContent";
  var DialogContent$1 = reactExports.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);
      const { forceMount = portalContext.forceMount, ...contentProps } = props;
      const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
    }
  );
  DialogContent$1.displayName = CONTENT_NAME;
  var DialogContentModal = reactExports.forwardRef(
    (props, forwardedRef) => {
      const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
      const contentRef = reactExports.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
      reactExports.useEffect(() => {
        const content = contentRef.current;
        if (content)
          return hideOthers(content);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogContentImpl,
        {
          ...props,
          ref: composedRefs,
          trapFocus: context.open,
          disableOutsidePointerEvents: true,
          onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
            var _a;
            event.preventDefault();
            (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
          }),
          onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            if (isRightClick)
              event.preventDefault();
          }),
          onFocusOutside: composeEventHandlers(
            props.onFocusOutside,
            (event) => event.preventDefault()
          )
        }
      );
    }
  );
  var DialogContentNonModal = reactExports.forwardRef(
    (props, forwardedRef) => {
      const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
      const hasInteractedOutsideRef = reactExports.useRef(false);
      const hasPointerDownOutsideRef = reactExports.useRef(false);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogContentImpl,
        {
          ...props,
          ref: forwardedRef,
          trapFocus: false,
          disableOutsidePointerEvents: false,
          onCloseAutoFocus: (event) => {
            var _a, _b;
            (_a = props.onCloseAutoFocus) == null ? void 0 : _a.call(props, event);
            if (!event.defaultPrevented) {
              if (!hasInteractedOutsideRef.current)
                (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
              event.preventDefault();
            }
            hasInteractedOutsideRef.current = false;
            hasPointerDownOutsideRef.current = false;
          },
          onInteractOutside: (event) => {
            var _a, _b;
            (_a = props.onInteractOutside) == null ? void 0 : _a.call(props, event);
            if (!event.defaultPrevented) {
              hasInteractedOutsideRef.current = true;
              if (event.detail.originalEvent.type === "pointerdown") {
                hasPointerDownOutsideRef.current = true;
              }
            }
            const target = event.target;
            const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
            if (targetIsTrigger)
              event.preventDefault();
            if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
              event.preventDefault();
            }
          }
        }
      );
    }
  );
  var DialogContentImpl = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
      const context = useDialogContext(CONTENT_NAME, __scopeDialog);
      const contentRef = reactExports.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, contentRef);
      useFocusGuards();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            loop: true,
            trapped: trapFocus,
            onMountAutoFocus: onOpenAutoFocus,
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                role: "dialog",
                id: context.contentId,
                "aria-describedby": context.descriptionId,
                "aria-labelledby": context.titleId,
                "data-state": getState(context.open),
                ...contentProps,
                ref: composedRefs,
                onDismiss: () => context.onOpenChange(false)
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
        ] })
      ] });
    }
  );
  var TITLE_NAME = "DialogTitle";
  var DialogTitle = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...titleProps } = props;
      const context = useDialogContext(TITLE_NAME, __scopeDialog);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
    }
  );
  DialogTitle.displayName = TITLE_NAME;
  var DESCRIPTION_NAME = "DialogDescription";
  var DialogDescription = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...descriptionProps } = props;
      const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
    }
  );
  DialogDescription.displayName = DESCRIPTION_NAME;
  var CLOSE_NAME = "DialogClose";
  var DialogClose = reactExports.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...closeProps } = props;
      const context = useDialogContext(CLOSE_NAME, __scopeDialog);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          ...closeProps,
          ref: forwardedRef,
          onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
        }
      );
    }
  );
  DialogClose.displayName = CLOSE_NAME;
  function getState(open) {
    return open ? "open" : "closed";
  }
  var TITLE_WARNING_NAME = "DialogTitleWarning";
  var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
    contentName: CONTENT_NAME,
    titleName: TITLE_NAME,
    docsSlug: "dialog"
  });
  var TitleWarning = ({ titleId }) => {
    const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
    const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
    reactExports.useEffect(() => {
      if (titleId) {
        const hasTitle = document.getElementById(titleId);
        if (!hasTitle)
          console.error(MESSAGE);
      }
    }, [MESSAGE, titleId]);
    return null;
  };
  var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
  var DescriptionWarning = ({ contentRef, descriptionId }) => {
    const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
    const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
    reactExports.useEffect(() => {
      var _a;
      const describedById = (_a = contentRef.current) == null ? void 0 : _a.getAttribute("aria-describedby");
      if (descriptionId && describedById) {
        const hasDescription = document.getElementById(descriptionId);
        if (!hasDescription)
          console.warn(MESSAGE);
      }
    }, [MESSAGE, contentRef, descriptionId]);
    return null;
  };
  var Root = Dialog$1;
  var Trigger = DialogTrigger;
  var Portal$1 = DialogPortal;
  var Overlay = DialogOverlay;
  var Content = DialogContent$1;
  var Title = DialogTitle;
  var Description = DialogDescription;
  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var _excluded$2s = ["color"];
  var HamburgerMenuIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
    var _ref$color = _ref.color, color2 = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$2s);
    return reactExports.createElement("svg", Object.assign({
      width: "15",
      height: "15",
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, props, {
      ref: forwardedRef
    }), reactExports.createElement("path", {
      d: "M1.5 3C1.22386 3 1 3.22386 1 3.5C1 3.77614 1.22386 4 1.5 4H13.5C13.7761 4 14 3.77614 14 3.5C14 3.22386 13.7761 3 13.5 3H1.5ZM1 7.5C1 7.22386 1.22386 7 1.5 7H13.5C13.7761 7 14 7.22386 14 7.5C14 7.77614 13.7761 8 13.5 8H1.5C1.22386 8 1 7.77614 1 7.5ZM1 11.5C1 11.2239 1.22386 11 1.5 11H13.5C13.7761 11 14 11.2239 14 11.5C14 11.7761 13.7761 12 13.5 12H1.5C1.22386 12 1 11.7761 1 11.5Z",
      fill: color2,
      fillRule: "evenodd",
      clipRule: "evenodd"
    }));
  });
  function _objectWithoutPropertiesLoose(r2, e2) {
    if (null == r2)
      return {};
    var t2 = {};
    for (var n2 in r2)
      if ({}.hasOwnProperty.call(r2, n2)) {
        if (e2.includes(n2))
          continue;
        t2[n2] = r2[n2];
      }
    return t2;
  }
  function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e2 = 1; e2 < arguments.length; e2++) {
        var t2 = arguments[e2];
        for (var r2 in t2)
          ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
      }
      return n2;
    }, _extends$1.apply(null, arguments);
  }
  var propTypes = { exports: {} };
  var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
  var ReactPropTypesSecret = ReactPropTypesSecret_1;
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  var factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  {
    propTypes.exports = factoryWithThrowingShims();
  }
  var propTypesExports = propTypes.exports;
  const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
  function r$1(e2) {
    var t2, f2, n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2)
      n2 += e2;
    else if ("object" == typeof e2)
      if (Array.isArray(e2)) {
        var o = e2.length;
        for (t2 = 0; t2 < o; t2++)
          e2[t2] && (f2 = r$1(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
      } else
        for (f2 in e2)
          e2[f2] && (n2 && (n2 += " "), n2 += f2);
    return n2;
  }
  function clsx() {
    for (var e2, t2, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++)
      (e2 = arguments[f2]) && (t2 = r$1(e2)) && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  const refType = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
  function composeClasses(slots, getUtilityClass, classes = void 0) {
    const output = {};
    Object.keys(slots).forEach(
      // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
      // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
      (slot) => {
        output[slot] = slots[slot].reduce((acc, key) => {
          if (key) {
            const utilityClass = getUtilityClass(key);
            if (utilityClass !== "") {
              acc.push(utilityClass);
            }
            if (classes && classes[key]) {
              acc.push(classes[key]);
            }
          }
          return acc;
        }, []).join(" ");
      }
    );
    return output;
  }
  var colorManipulator = {};
  var interopRequireDefault = { exports: {} };
  (function(module) {
    function _interopRequireDefault2(e2) {
      return e2 && e2.__esModule ? e2 : {
        "default": e2
      };
    }
    module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(interopRequireDefault);
  var interopRequireDefaultExports = interopRequireDefault.exports;
  function formatMuiErrorMessage$1(code) {
    let url = "https://mui.com/production-error/?code=" + code;
    for (let i = 1; i < arguments.length; i += 1) {
      url += "&args[]=" + encodeURIComponent(arguments[i]);
    }
    return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
  }
  const formatMuiErrorMessage = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: formatMuiErrorMessage$1
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(formatMuiErrorMessage);
  function clamp$1(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
    return Math.max(min2, Math.min(val, max2));
  }
  const clamp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: clamp$1
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$2 = /* @__PURE__ */ getAugmentedNamespace(clamp);
  var _interopRequireDefault$1 = interopRequireDefaultExports;
  Object.defineProperty(colorManipulator, "__esModule", {
    value: true
  });
  var alpha_1 = colorManipulator.alpha = alpha$1;
  colorManipulator.blend = blend;
  colorManipulator.colorChannel = void 0;
  var darken_1 = colorManipulator.darken = darken;
  colorManipulator.decomposeColor = decomposeColor$1;
  colorManipulator.emphasize = emphasize;
  var getContrastRatio_1 = colorManipulator.getContrastRatio = getContrastRatio;
  colorManipulator.getLuminance = getLuminance;
  colorManipulator.hexToRgb = hexToRgb$1;
  colorManipulator.hslToRgb = hslToRgb;
  var lighten_1 = colorManipulator.lighten = lighten;
  colorManipulator.private_safeAlpha = private_safeAlpha;
  colorManipulator.private_safeColorChannel = void 0;
  colorManipulator.private_safeDarken = private_safeDarken;
  colorManipulator.private_safeEmphasize = private_safeEmphasize;
  colorManipulator.private_safeLighten = private_safeLighten;
  colorManipulator.recomposeColor = recomposeColor$1;
  colorManipulator.rgbToHex = rgbToHex;
  var _formatMuiErrorMessage2 = _interopRequireDefault$1(require$$1$1);
  var _clamp = _interopRequireDefault$1(require$$2);
  function clampWrapper$1(value, min2 = 0, max2 = 1) {
    return (0, _clamp.default)(value, min2, max2);
  }
  function hexToRgb$1(color2) {
    color2 = color2.slice(1);
    const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
    let colors = color2.match(re2);
    if (colors && colors[0].length === 1) {
      colors = colors.map((n2) => n2 + n2);
    }
    return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index) => {
      return index < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
    }).join(", ")})` : "";
  }
  function intToHex(int) {
    const hex = int.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  }
  function decomposeColor$1(color2) {
    if (color2.type) {
      return color2;
    }
    if (color2.charAt(0) === "#") {
      return decomposeColor$1(hexToRgb$1(color2));
    }
    const marker = color2.indexOf("(");
    const type = color2.substring(0, marker);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
      throw new Error((0, _formatMuiErrorMessage2.default)(9, color2));
    }
    let values2 = color2.substring(marker + 1, color2.length - 1);
    let colorSpace;
    if (type === "color") {
      values2 = values2.split(" ");
      colorSpace = values2.shift();
      if (values2.length === 4 && values2[3].charAt(0) === "/") {
        values2[3] = values2[3].slice(1);
      }
      if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
        throw new Error((0, _formatMuiErrorMessage2.default)(10, colorSpace));
      }
    } else {
      values2 = values2.split(",");
    }
    values2 = values2.map((value) => parseFloat(value));
    return {
      type,
      values: values2,
      colorSpace
    };
  }
  const colorChannel = (color2) => {
    const decomposedColor = decomposeColor$1(color2);
    return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.indexOf("hsl") !== -1 && idx !== 0 ? `${val}%` : val).join(" ");
  };
  colorManipulator.colorChannel = colorChannel;
  const private_safeColorChannel = (color2, warning) => {
    try {
      return colorChannel(color2);
    } catch (error) {
      if (warning && false) {
        console.warn(warning);
      }
      return color2;
    }
  };
  colorManipulator.private_safeColorChannel = private_safeColorChannel;
  function recomposeColor$1(color2) {
    const {
      type,
      colorSpace
    } = color2;
    let {
      values: values2
    } = color2;
    if (type.indexOf("rgb") !== -1) {
      values2 = values2.map((n2, i) => i < 3 ? parseInt(n2, 10) : n2);
    } else if (type.indexOf("hsl") !== -1) {
      values2[1] = `${values2[1]}%`;
      values2[2] = `${values2[2]}%`;
    }
    if (type.indexOf("color") !== -1) {
      values2 = `${colorSpace} ${values2.join(" ")}`;
    } else {
      values2 = `${values2.join(", ")}`;
    }
    return `${type}(${values2})`;
  }
  function rgbToHex(color2) {
    if (color2.indexOf("#") === 0) {
      return color2;
    }
    const {
      values: values2
    } = decomposeColor$1(color2);
    return `#${values2.map((n2, i) => intToHex(i === 3 ? Math.round(255 * n2) : n2)).join("")}`;
  }
  function hslToRgb(color2) {
    color2 = decomposeColor$1(color2);
    const {
      values: values2
    } = color2;
    const h2 = values2[0];
    const s = values2[1] / 100;
    const l2 = values2[2] / 100;
    const a = s * Math.min(l2, 1 - l2);
    const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
    let type = "rgb";
    const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
    if (color2.type === "hsla") {
      type += "a";
      rgb.push(values2[3]);
    }
    return recomposeColor$1({
      type,
      values: rgb
    });
  }
  function getLuminance(color2) {
    color2 = decomposeColor$1(color2);
    let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor$1(hslToRgb(color2)).values : color2.values;
    rgb = rgb.map((val) => {
      if (color2.type !== "color") {
        val /= 255;
      }
      return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
    });
    return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
  }
  function getContrastRatio(foreground, background) {
    const lumA = getLuminance(foreground);
    const lumB = getLuminance(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
  }
  function alpha$1(color2, value) {
    color2 = decomposeColor$1(color2);
    value = clampWrapper$1(value);
    if (color2.type === "rgb" || color2.type === "hsl") {
      color2.type += "a";
    }
    if (color2.type === "color") {
      color2.values[3] = `/${value}`;
    } else {
      color2.values[3] = value;
    }
    return recomposeColor$1(color2);
  }
  function private_safeAlpha(color2, value, warning) {
    try {
      return alpha$1(color2, value);
    } catch (error) {
      if (warning && false) {
        console.warn(warning);
      }
      return color2;
    }
  }
  function darken(color2, coefficient) {
    color2 = decomposeColor$1(color2);
    coefficient = clampWrapper$1(coefficient);
    if (color2.type.indexOf("hsl") !== -1) {
      color2.values[2] *= 1 - coefficient;
    } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] *= 1 - coefficient;
      }
    }
    return recomposeColor$1(color2);
  }
  function private_safeDarken(color2, coefficient, warning) {
    try {
      return darken(color2, coefficient);
    } catch (error) {
      if (warning && false) {
        console.warn(warning);
      }
      return color2;
    }
  }
  function lighten(color2, coefficient) {
    color2 = decomposeColor$1(color2);
    coefficient = clampWrapper$1(coefficient);
    if (color2.type.indexOf("hsl") !== -1) {
      color2.values[2] += (100 - color2.values[2]) * coefficient;
    } else if (color2.type.indexOf("rgb") !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] += (255 - color2.values[i]) * coefficient;
      }
    } else if (color2.type.indexOf("color") !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] += (1 - color2.values[i]) * coefficient;
      }
    }
    return recomposeColor$1(color2);
  }
  function private_safeLighten(color2, coefficient, warning) {
    try {
      return lighten(color2, coefficient);
    } catch (error) {
      if (warning && false) {
        console.warn(warning);
      }
      return color2;
    }
  }
  function emphasize(color2, coefficient = 0.15) {
    return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
  }
  function private_safeEmphasize(color2, coefficient, warning) {
    try {
      return emphasize(color2, coefficient);
    } catch (error) {
      if (warning && false) {
        console.warn(warning);
      }
      return color2;
    }
  }
  function blend(background, overlay, opacity, gamma = 1) {
    const blendChannel = (b2, o) => Math.round((b2 ** (1 / gamma) * (1 - opacity) + o ** (1 / gamma) * opacity) ** gamma);
    const backgroundColor2 = decomposeColor$1(background);
    const overlayColor = decomposeColor$1(overlay);
    const rgb = [blendChannel(backgroundColor2.values[0], overlayColor.values[0]), blendChannel(backgroundColor2.values[1], overlayColor.values[1]), blendChannel(backgroundColor2.values[2], overlayColor.values[2])];
    return recomposeColor$1({
      type: "rgb",
      values: rgb
    });
  }
  function capitalize$1(string) {
    if (typeof string !== "string") {
      throw new Error(formatMuiErrorMessage$1(7));
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  const capitalize = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: capitalize$1
  }, Symbol.toStringTag, { value: "Module" }));
  var createStyled$2 = {};
  var _extends = { exports: {} };
  var hasRequired_extends;
  function require_extends() {
    if (hasRequired_extends)
      return _extends.exports;
    hasRequired_extends = 1;
    (function(module) {
      function _extends3() {
        return module.exports = _extends3 = Object.assign ? Object.assign.bind() : function(n2) {
          for (var e2 = 1; e2 < arguments.length; e2++) {
            var t2 = arguments[e2];
            for (var r2 in t2)
              ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          }
          return n2;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends3.apply(null, arguments);
      }
      module.exports = _extends3, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(_extends);
    return _extends.exports;
  }
  var objectWithoutPropertiesLoose = { exports: {} };
  var hasRequiredObjectWithoutPropertiesLoose;
  function requireObjectWithoutPropertiesLoose() {
    if (hasRequiredObjectWithoutPropertiesLoose)
      return objectWithoutPropertiesLoose.exports;
    hasRequiredObjectWithoutPropertiesLoose = 1;
    (function(module) {
      function _objectWithoutPropertiesLoose3(r2, e2) {
        if (null == r2)
          return {};
        var t2 = {};
        for (var n2 in r2)
          if ({}.hasOwnProperty.call(r2, n2)) {
            if (e2.includes(n2))
              continue;
            t2[n2] = r2[n2];
          }
        return t2;
      }
      module.exports = _objectWithoutPropertiesLoose3, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(objectWithoutPropertiesLoose);
    return objectWithoutPropertiesLoose.exports;
  }
  function memoize$1(fn) {
    var cache2 = /* @__PURE__ */ Object.create(null);
    return function(arg) {
      if (cache2[arg] === void 0)
        cache2[arg] = fn(arg);
      return cache2[arg];
    };
  }
  var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
  var isPropValid = /* @__PURE__ */ memoize$1(
    function(prop) {
      return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
    }
    /* Z+1 */
  );
  var isDevelopment$2 = false;
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        return document.styleSheets[i];
      }
    }
    return void 0;
  }
  function createStyleElement(options2) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options2.key);
    if (options2.nonce !== void 0) {
      tag.setAttribute("nonce", options2.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = /* @__PURE__ */ function() {
    function StyleSheet2(options2) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options2.speedy === void 0 ? !isDevelopment$2 : options2.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options2.nonce;
      this.key = options2.key;
      this.container = options2.container;
      this.prepend = options2.prepend;
      this.insertionPoint = options2.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e2) {
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush() {
      this.tags.forEach(function(tag) {
        var _tag$parentNode;
        return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };
    return StyleSheet2;
  }();
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";
  var abs = Math.abs;
  var from = String.fromCharCode;
  var assign = Object.assign;
  function hash$2(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim$1(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr(value, begin, end2) {
    return value.slice(begin, end2);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine(array, callback) {
    return array.map(callback).join("");
  }
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root, parent, type, props, children, length2) {
    return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy(root, props) {
    return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end2) {
    return substr(characters, begin, end2);
  }
  function token(type) {
    switch (type) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim$1(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index, count2) {
    while (--count2 && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index, caret() + (count2 < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        case type:
          return position;
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index) {
    while (!token(peek()))
      next();
    return slice(index, position);
  }
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset2 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference2 = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        case 123 * variable:
          points[index++] = strlen(characters2) * ampersand;
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            case 0:
            case 125:
              scanning = 0;
            case 59 + offset2:
              if (ampersand == -1)
                characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
            case 59:
              characters2 += ";";
            default:
              append(reference2 = ruleset(characters2, root, parent, index, offset2, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset2 === 0)
                  parse(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                  }
          }
          index = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            case 38:
              ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            case 44:
              points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root, parent, index, offset2, rules, points, type, props, children, length2) {
    var post = offset2 - 1;
    var rule = offset2 === 0 ? rules : [""];
    var size = sizeof(rule);
    for (var i = 0, j = 0, k2 = 0; i < index; ++i)
      for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z2 = value; x2 < size; ++x2)
        if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
          props[k2++] = z2;
    return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root, parent) {
    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root, parent, length2) {
    return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }
  function serialize(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i = 0; i < length2; i++)
      output += callback(children[i], i, children, callback) || "";
    return output;
  }
  function stringify(element, index, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length)
          break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element, index, children, callback) {
      var output = "";
      for (var i = 0; i < length2; i++)
        output += collection[i](element, index, children, callback) || "";
      return output;
    };
  }
  function rulesheet(callback) {
    return function(element) {
      if (!element.root) {
        if (element = element.return)
          callback(element);
      }
    };
  }
  var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek();
      if (previous === 38 && character2 === 12) {
        points[index] = 1;
      }
      if (token(character2)) {
        break;
      }
      next();
    }
    return slice(begin, position);
  };
  var toRules = function toRules2(parsed, points) {
    var index = -1;
    var character2 = 44;
    do {
      switch (token(character2)) {
        case 0:
          if (character2 === 38 && peek() === 12) {
            points[index] = 1;
          }
          parsed[index] += identifierWithPointTracking(position - 1, points, index);
          break;
        case 2:
          parsed[index] += delimit(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed[++index] = peek() === 58 ? "&\f" : "";
            points[index] = parsed[index].length;
            break;
          }
        default:
          parsed[index] += from(character2);
      }
    } while (character2 = next());
    return parsed;
  };
  var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
  };
  var fixedElements = /* @__PURE__ */ new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    element.length < 1) {
      return;
    }
    var value = element.value, parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent)
        return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i = 0, k2 = 0; i < rules.length; i++) {
      for (var j = 0; j < parentRules.length; j++, k2++) {
        element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
        // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  function prefix(value, length2) {
    switch (hash$2(value, length2)) {
      case 5103:
        return WEBKIT + "print-" + value + value;
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
      case 5187:
        return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
      case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
      case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
      case 5548:
        return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
      case 5292:
        return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
      case 6060:
        return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
      case 4554:
        return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
      case 6187:
        return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
      case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
      case 4968:
        return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6)
          switch (charat(value, length2 + 1)) {
            case 109:
              if (charat(value, length2 + 4) !== 45)
                break;
            case 102:
              return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
            case 115:
              return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
          }
        break;
      case 4949:
        if (charat(value, length2 + 1) !== 115)
          break;
      case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
          case 107:
            return replace(value, ":", ":" + WEBKIT) + value;
          case 101:
            return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
      case 5936:
        switch (charat(value, length2 + 11)) {
          case 114:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
          case 108:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
          case 45:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }
  var prefixer = function prefixer2(element, index, children, callback) {
    if (element.length > -1) {
      if (!element["return"])
        switch (element.type) {
          case DECLARATION:
            element["return"] = prefix(element.value, element.length);
            break;
          case KEYFRAMES:
            return serialize([copy(element, {
              value: replace(element.value, "@", "@" + WEBKIT)
            })], callback);
          case RULESET:
            if (element.length)
              return combine(element.props, function(value) {
                switch (match(value, /(::plac\w+|:read-\w+)/)) {
                  case ":read-only":
                  case ":read-write":
                    return serialize([copy(element, {
                      props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                    })], callback);
                  case "::placeholder":
                    return serialize([copy(element, {
                      props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                    }), copy(element, {
                      props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                    })], callback);
                }
                return "";
              });
        }
    }
  };
  var defaultStylisPlugins = [prefixer];
  var createCache = function createCache2(options2) {
    var key = options2.key;
    if (key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    {
      container = options2.container || document.head;
      Array.prototype.forEach.call(
        // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i = 1; i < attrib.length; i++) {
            inserted[attrib[i]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    {
      var currentSheet;
      var finalizingPlugins = [stringify, rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles2) {
        return serialize(compile(styles2), serializer);
      };
      _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache2.inserted[serialized.name] = true;
        }
      };
    }
    var cache2 = {
      key,
      sheet: new StyleSheet({
        key,
        container,
        nonce: options2.nonce,
        speedy: options2.speedy,
        prepend: options2.prepend,
        insertionPoint: options2.insertionPoint
      }),
      nonce: options2.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache2.sheet.hydrate(nodesToHydrate);
    return cache2;
  };
  var reactIs$2 = { exports: {} };
  var reactIs_production_min$1 = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$1 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r = b$1 ? Symbol.for("react.memo") : 60115, t$1 = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w = b$1 ? Symbol.for("react.fundamental") : 60117, x = b$1 ? Symbol.for("react.responder") : 60118, y = b$1 ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u2 = a.$$typeof;
      switch (u2) {
        case c$1:
          switch (a = a.type, a) {
            case l$1:
            case m$1:
            case e$1:
            case g$1:
            case f$1:
            case p$1:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k$1:
                case n$1:
                case t$1:
                case r:
                case h$1:
                  return a;
                default:
                  return u2;
              }
          }
        case d$1:
          return u2;
      }
    }
  }
  function A(a) {
    return z(a) === m$1;
  }
  reactIs_production_min$1.AsyncMode = l$1;
  reactIs_production_min$1.ConcurrentMode = m$1;
  reactIs_production_min$1.ContextConsumer = k$1;
  reactIs_production_min$1.ContextProvider = h$1;
  reactIs_production_min$1.Element = c$1;
  reactIs_production_min$1.ForwardRef = n$1;
  reactIs_production_min$1.Fragment = e$1;
  reactIs_production_min$1.Lazy = t$1;
  reactIs_production_min$1.Memo = r;
  reactIs_production_min$1.Portal = d$1;
  reactIs_production_min$1.Profiler = g$1;
  reactIs_production_min$1.StrictMode = f$1;
  reactIs_production_min$1.Suspense = p$1;
  reactIs_production_min$1.isAsyncMode = function(a) {
    return A(a) || z(a) === l$1;
  };
  reactIs_production_min$1.isConcurrentMode = A;
  reactIs_production_min$1.isContextConsumer = function(a) {
    return z(a) === k$1;
  };
  reactIs_production_min$1.isContextProvider = function(a) {
    return z(a) === h$1;
  };
  reactIs_production_min$1.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c$1;
  };
  reactIs_production_min$1.isForwardRef = function(a) {
    return z(a) === n$1;
  };
  reactIs_production_min$1.isFragment = function(a) {
    return z(a) === e$1;
  };
  reactIs_production_min$1.isLazy = function(a) {
    return z(a) === t$1;
  };
  reactIs_production_min$1.isMemo = function(a) {
    return z(a) === r;
  };
  reactIs_production_min$1.isPortal = function(a) {
    return z(a) === d$1;
  };
  reactIs_production_min$1.isProfiler = function(a) {
    return z(a) === g$1;
  };
  reactIs_production_min$1.isStrictMode = function(a) {
    return z(a) === f$1;
  };
  reactIs_production_min$1.isSuspense = function(a) {
    return z(a) === p$1;
  };
  reactIs_production_min$1.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e$1 || a === m$1 || a === g$1 || a === f$1 || a === p$1 || a === q$1 || "object" === typeof a && null !== a && (a.$$typeof === t$1 || a.$$typeof === r || a.$$typeof === h$1 || a.$$typeof === k$1 || a.$$typeof === n$1 || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v$1);
  };
  reactIs_production_min$1.typeOf = z;
  {
    reactIs$2.exports = reactIs_production_min$1;
  }
  var reactIsExports$1 = reactIs$2.exports;
  var reactIs$1 = reactIsExports$1;
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
  var isBrowser = true;
  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache2, serialized, isStringTag2) {
    var className = cache2.key + "-" + serialized.name;
    if (
      // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag2 === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser === false) && cache2.registered[className] === void 0
    ) {
      cache2.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache2, serialized, isStringTag2) {
    registerStyles(cache2, serialized, isStringTag2);
    var className = cache2.key + "-" + serialized.name;
    if (cache2.inserted[serialized.name] === void 0) {
      var current = serialized;
      do {
        cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
        current = current.next;
      } while (current !== void 0);
    }
  };
  function murmur2(str) {
    var h2 = 0;
    var k2, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
      k2 ^= /* k >>> r: */
      k2 >>> 24;
      h2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i) & 255;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 = /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var isDevelopment$1 = false;
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match2, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    var componentSelector = interpolation;
    if (componentSelector.__emotion_styles !== void 0) {
      return componentSelector;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        var keyframes2 = interpolation;
        if (keyframes2.anim === 1) {
          cursor = {
            name: keyframes2.name,
            styles: keyframes2.styles,
            next: cursor
          };
          return keyframes2.name;
        }
        var serializedStyles = interpolation;
        if (serializedStyles.styles !== void 0) {
          var next2 = serializedStyles.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles2 = serializedStyles.styles + ";";
          return styles2;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }
        break;
      }
    }
    var asString = interpolation;
    if (registered == null) {
      return asString;
    }
    var cached = registered[asString];
    return cached !== void 0 ? cached : asString;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
      }
    } else {
      for (var key in obj) {
        var value = obj[key];
        if (typeof value !== "object") {
          var asString = value;
          if (registered != null && registered[asString] !== void 0) {
            string += key + "{" + registered[asString] + "}";
          } else if (isProcessableValue(asString)) {
            string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
          }
        } else {
          if (key === "NO_COMPONENT_SELECTOR" && isDevelopment$1) {
            throw new Error(noComponentSelectorMessage);
          }
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (key) {
              case "animation":
              case "animationName": {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string += key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
  var cursor;
  function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles2 = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles2 += handleInterpolation(mergedProps, registered, strings);
    } else {
      var asTemplateStringsArr = strings;
      styles2 += asTemplateStringsArr[0];
    }
    for (var i = 1; i < args.length; i++) {
      styles2 += handleInterpolation(mergedProps, registered, args[i]);
      if (stringMode) {
        var templateStringsArr = strings;
        styles2 += templateStringsArr[i];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles2)) !== null) {
      identifierName += "-" + match2[1];
    }
    var name = murmur2(styles2) + identifierName;
    return {
      name,
      styles: styles2,
      next: cursor
    };
  }
  var syncFallback = function syncFallback2(create) {
    return create();
  };
  var useInsertionEffect = React$2["useInsertionEffect"] ? React$2["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
  var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
  var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
      key: "css"
    }) : null
  );
  var CacheProvider = EmotionCacheContext.Provider;
  var withEmotionCache = function withEmotionCache2(func) {
    return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var cache2 = reactExports.useContext(EmotionCacheContext);
      return func(props, cache2, ref);
    });
  };
  var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
  require_extends();
  var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
    var styles2 = props.styles;
    var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
    var sheetRef = reactExports.useRef();
    useInsertionEffectWithLayoutFallback(function() {
      var key = cache2.key + "-global";
      var sheet = new cache2.sheet.constructor({
        key,
        nonce: cache2.sheet.nonce,
        container: cache2.sheet.container,
        speedy: cache2.sheet.isSpeedy
      });
      var rehydrating = false;
      var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
      if (cache2.sheet.tags.length) {
        sheet.before = cache2.sheet.tags[0];
      }
      if (node2 !== null) {
        rehydrating = true;
        node2.setAttribute("data-emotion", key);
        sheet.hydrate([node2]);
      }
      sheetRef.current = [sheet, rehydrating];
      return function() {
        sheet.flush();
      };
    }, [cache2]);
    useInsertionEffectWithLayoutFallback(function() {
      var sheetRefCurrent = sheetRef.current;
      var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
      if (rehydrating) {
        sheetRefCurrent[1] = false;
        return;
      }
      if (serialized.next !== void 0) {
        insertStyles(cache2, serialized.next, true);
      }
      if (sheet.tags.length) {
        var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
        sheet.before = element;
        sheet.flush();
      }
      cache2.insert("", serialized, sheet, false);
    }, [cache2, serialized.name]);
    return null;
  });
  function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return serializeStyles(args);
  }
  var keyframes = function keyframes2() {
    var insertable = css.apply(void 0, arguments);
    var name = "animation-" + insertable.name;
    return {
      name,
      styles: "@keyframes " + name + "{" + insertable.styles + "}",
      anim: 1,
      toString: function toString2() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  };
  var testOmitPropsOnStringTag = isPropValid;
  var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
    return key !== "theme";
  };
  var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
  };
  var composeShouldForwardProps = function composeShouldForwardProps2(tag, options2, isReal) {
    var shouldForwardProp2;
    if (options2) {
      var optionsShouldForwardProp = options2.shouldForwardProp;
      shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
        return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
      } : optionsShouldForwardProp;
    }
    if (typeof shouldForwardProp2 !== "function" && isReal) {
      shouldForwardProp2 = tag.__emotion_forwardProp;
    }
    return shouldForwardProp2;
  };
  var isDevelopment = false;
  var Insertion = function Insertion2(_ref) {
    var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
    registerStyles(cache2, serialized, isStringTag2);
    useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache2, serialized, isStringTag2);
    });
    return null;
  };
  var createStyled$1 = function createStyled2(tag, options2) {
    var isReal = tag.__emotion_real === tag;
    var baseTag = isReal && tag.__emotion_base || tag;
    var identifierName;
    var targetClassName;
    if (options2 !== void 0) {
      identifierName = options2.label;
      targetClassName = options2.target;
    }
    var shouldForwardProp2 = composeShouldForwardProps(tag, options2, isReal);
    var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
    var shouldUseAs = !defaultShouldForwardProp("as");
    return function() {
      var args = arguments;
      var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
      if (identifierName !== void 0) {
        styles2.push("label:" + identifierName + ";");
      }
      if (args[0] == null || args[0].raw === void 0) {
        styles2.push.apply(styles2, args);
      } else {
        styles2.push(args[0][0]);
        var len = args.length;
        var i = 1;
        for (; i < len; i++) {
          styles2.push(args[i], args[0][i]);
        }
      }
      var Styled = withEmotionCache(function(props, cache2, ref) {
        var FinalTag = shouldUseAs && props.as || baseTag;
        var className = "";
        var classInterpolations = [];
        var mergedProps = props;
        if (props.theme == null) {
          mergedProps = {};
          for (var key in props) {
            mergedProps[key] = props[key];
          }
          mergedProps.theme = reactExports.useContext(ThemeContext);
        }
        if (typeof props.className === "string") {
          className = getRegisteredStyles(cache2.registered, classInterpolations, props.className);
        } else if (props.className != null) {
          className = props.className + " ";
        }
        var serialized = serializeStyles(styles2.concat(classInterpolations), cache2.registered, mergedProps);
        className += cache2.key + "-" + serialized.name;
        if (targetClassName !== void 0) {
          className += " " + targetClassName;
        }
        var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
        var newProps = {};
        for (var _key in props) {
          if (shouldUseAs && _key === "as")
            continue;
          if (finalShouldForwardProp(_key)) {
            newProps[_key] = props[_key];
          }
        }
        newProps.className = className;
        if (ref) {
          newProps.ref = ref;
        }
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
          cache: cache2,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
      });
      Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
      Styled.defaultProps = tag.defaultProps;
      Styled.__emotion_real = Styled;
      Styled.__emotion_base = baseTag;
      Styled.__emotion_styles = styles2;
      Styled.__emotion_forwardProp = shouldForwardProp2;
      Object.defineProperty(Styled, "toString", {
        value: function value() {
          if (targetClassName === void 0 && isDevelopment) {
            return "NO_COMPONENT_SELECTOR";
          }
          return "." + targetClassName;
        }
      });
      Styled.withComponent = function(nextTag, nextOptions) {
        return createStyled2(nextTag, _extends$1({}, options2, nextOptions, {
          shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
        })).apply(void 0, styles2);
      };
      return Styled;
    };
  };
  var tags = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ];
  var newStyled = createStyled$1.bind();
  tags.forEach(function(tagName) {
    newStyled[tagName] = newStyled(tagName);
  });
  let cache;
  if (typeof document === "object") {
    cache = createCache({
      key: "css",
      prepend: true
    });
  }
  function StyledEngineProvider(props) {
    const {
      injectFirst,
      children
    } = props;
    return injectFirst && cache ? /* @__PURE__ */ jsxRuntimeExports.jsx(CacheProvider, {
      value: cache,
      children
    }) : children;
  }
  function isEmpty$3(obj) {
    return obj === void 0 || obj === null || Object.keys(obj).length === 0;
  }
  function GlobalStyles$2(props) {
    const {
      styles: styles2,
      defaultTheme: defaultTheme2 = {}
    } = props;
    const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$3(themeInput) ? defaultTheme2 : themeInput) : styles2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
      styles: globalStyles
    });
  }
  function styled$1(tag, options2) {
    const stylesFactory = newStyled(tag, options2);
    return stylesFactory;
  }
  const internal_processStyles = (tag, processor) => {
    if (Array.isArray(tag.__emotion_styles)) {
      tag.__emotion_styles = processor(tag.__emotion_styles);
    }
  };
  const styledEngine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    GlobalStyles: GlobalStyles$2,
    StyledEngineProvider,
    ThemeContext,
    css,
    default: styled$1,
    internal_processStyles,
    keyframes
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$1 = /* @__PURE__ */ getAugmentedNamespace(styledEngine);
  function isPlainObject$1(item) {
    if (typeof item !== "object" || item === null) {
      return false;
    }
    const prototype2 = Object.getPrototypeOf(item);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
  }
  function deepClone(source) {
    if (!isPlainObject$1(source)) {
      return source;
    }
    const output = {};
    Object.keys(source).forEach((key) => {
      output[key] = deepClone(source[key]);
    });
    return output;
  }
  function deepmerge$1(target, source, options2 = {
    clone: true
  }) {
    const output = options2.clone ? _extends$1({}, target) : target;
    if (isPlainObject$1(target) && isPlainObject$1(source)) {
      Object.keys(source).forEach((key) => {
        if (isPlainObject$1(source[key]) && // Avoid prototype pollution
        Object.prototype.hasOwnProperty.call(target, key) && isPlainObject$1(target[key])) {
          output[key] = deepmerge$1(target[key], source[key], options2);
        } else if (options2.clone) {
          output[key] = isPlainObject$1(source[key]) ? deepClone(source[key]) : source[key];
        } else {
          output[key] = source[key];
        }
      });
    }
    return output;
  }
  const deepmerge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: deepmerge$1,
    isPlainObject: isPlainObject$1
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$4 = /* @__PURE__ */ getAugmentedNamespace(deepmerge);
  const require$$5 = /* @__PURE__ */ getAugmentedNamespace(capitalize);
  var reactIs = { exports: {} };
  var reactIs_production_min = {};
  /**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
  u = Symbol.for("react.module.reference");
  function v(a) {
    if ("object" === typeof a && null !== a) {
      var r2 = a.$$typeof;
      switch (r2) {
        case b:
          switch (a = a.type, a) {
            case d:
            case f:
            case e:
            case m:
            case n:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case h:
                case l:
                case q:
                case p:
                case g:
                  return a;
                default:
                  return r2;
              }
          }
        case c:
          return r2;
      }
    }
  }
  reactIs_production_min.ContextConsumer = h;
  reactIs_production_min.ContextProvider = g;
  reactIs_production_min.Element = b;
  reactIs_production_min.ForwardRef = l;
  reactIs_production_min.Fragment = d;
  reactIs_production_min.Lazy = q;
  reactIs_production_min.Memo = p;
  reactIs_production_min.Portal = c;
  reactIs_production_min.Profiler = f;
  reactIs_production_min.StrictMode = e;
  reactIs_production_min.Suspense = m;
  reactIs_production_min.SuspenseList = n;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a) {
    return v(a) === h;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return v(a) === g;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === b;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return v(a) === l;
  };
  reactIs_production_min.isFragment = function(a) {
    return v(a) === d;
  };
  reactIs_production_min.isLazy = function(a) {
    return v(a) === q;
  };
  reactIs_production_min.isMemo = function(a) {
    return v(a) === p;
  };
  reactIs_production_min.isPortal = function(a) {
    return v(a) === c;
  };
  reactIs_production_min.isProfiler = function(a) {
    return v(a) === f;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return v(a) === e;
  };
  reactIs_production_min.isSuspense = function(a) {
    return v(a) === m;
  };
  reactIs_production_min.isSuspenseList = function(a) {
    return v(a) === n;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? true : false;
  };
  reactIs_production_min.typeOf = v;
  {
    reactIs.exports = reactIs_production_min;
  }
  var reactIsExports = reactIs.exports;
  const fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
  function getFunctionName(fn) {
    const match2 = `${fn}`.match(fnNameMatchRegex);
    const name = match2 && match2[1];
    return name || "";
  }
  function getFunctionComponentName(Component, fallback = "") {
    return Component.displayName || Component.name || getFunctionName(Component) || fallback;
  }
  function getWrappedName(outerType, innerType, wrapperName) {
    const functionName = getFunctionComponentName(innerType);
    return outerType.displayName || (functionName !== "" ? `${wrapperName}(${functionName})` : wrapperName);
  }
  function getDisplayName$1(Component) {
    if (Component == null) {
      return void 0;
    }
    if (typeof Component === "string") {
      return Component;
    }
    if (typeof Component === "function") {
      return getFunctionComponentName(Component, "Component");
    }
    if (typeof Component === "object") {
      switch (Component.$$typeof) {
        case reactIsExports.ForwardRef:
          return getWrappedName(Component, Component.render, "ForwardRef");
        case reactIsExports.Memo:
          return getWrappedName(Component, Component.type, "memo");
        default:
          return void 0;
      }
    }
    return void 0;
  }
  const getDisplayName = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: getDisplayName$1,
    getFunctionName
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$6 = /* @__PURE__ */ getAugmentedNamespace(getDisplayName);
  const _excluded$1y = ["values", "unit", "step"];
  const sortBreakpointsValues = (values2) => {
    const breakpointsAsArray = Object.keys(values2).map((key) => ({
      key,
      val: values2[key]
    })) || [];
    breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
    return breakpointsAsArray.reduce((acc, obj) => {
      return _extends$1({}, acc, {
        [obj.key]: obj.val
      });
    }, {});
  };
  function createBreakpoints(breakpoints) {
    const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values: values2 = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536
        // large screen
      },
      unit = "px",
      step = 5
    } = breakpoints, other = _objectWithoutPropertiesLoose(breakpoints, _excluded$1y);
    const sortedValues = sortBreakpointsValues(values2);
    const keys = Object.keys(sortedValues);
    function up(key) {
      const value = typeof values2[key] === "number" ? values2[key] : key;
      return `@media (min-width:${value}${unit})`;
    }
    function down(key) {
      const value = typeof values2[key] === "number" ? values2[key] : key;
      return `@media (max-width:${value - step / 100}${unit})`;
    }
    function between(start2, end2) {
      const endIndex = keys.indexOf(end2);
      return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end2) - step / 100}${unit})`;
    }
    function only(key) {
      if (keys.indexOf(key) + 1 < keys.length) {
        return between(key, keys[keys.indexOf(key) + 1]);
      }
      return up(key);
    }
    function not(key) {
      const keyIndex = keys.indexOf(key);
      if (keyIndex === 0) {
        return up(keys[1]);
      }
      if (keyIndex === keys.length - 1) {
        return down(keys[keyIndex]);
      }
      return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
    }
    return _extends$1({
      keys,
      values: sortedValues,
      up,
      down,
      between,
      only,
      not,
      unit
    }, other);
  }
  const shape = {
    borderRadius: 4
  };
  function merge$1(acc, item) {
    if (!item) {
      return acc;
    }
    return deepmerge$1(acc, item, {
      clone: false
      // No need to clone deep, it's way faster.
    });
  }
  const values$1 = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536
    // large screen
  };
  const defaultBreakpoints = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (key) => `@media (min-width:${values$1[key]}px)`
  };
  function handleBreakpoints(props, propValue, styleFromPropValue) {
    const theme = props.theme || {};
    if (Array.isArray(propValue)) {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return propValue.reduce((acc, item, index) => {
        acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
        return acc;
      }, {});
    }
    if (typeof propValue === "object") {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return Object.keys(propValue).reduce((acc, breakpoint) => {
        if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
          const mediaKey = themeBreakpoints.up(breakpoint);
          acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        } else {
          const cssKey = breakpoint;
          acc[cssKey] = propValue[cssKey];
        }
        return acc;
      }, {});
    }
    const output = styleFromPropValue(propValue);
    return output;
  }
  function createEmptyBreakpointObject(breakpointsInput = {}) {
    var _breakpointsInput$key;
    const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
      const breakpointStyleKey = breakpointsInput.up(key);
      acc[breakpointStyleKey] = {};
      return acc;
    }, {});
    return breakpointsInOrder || {};
  }
  function removeUnusedBreakpoints(breakpointKeys, style2) {
    return breakpointKeys.reduce((acc, key) => {
      const breakpointOutput = acc[key];
      const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
      if (isBreakpointUnused) {
        delete acc[key];
      }
      return acc;
    }, style2);
  }
  function getPath(obj, path, checkVars = true) {
    if (!path || typeof path !== "string") {
      return null;
    }
    if (obj && obj.vars && checkVars) {
      const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
      if (val != null) {
        return val;
      }
    }
    return path.split(".").reduce((acc, item) => {
      if (acc && acc[item] != null) {
        return acc[item];
      }
      return null;
    }, obj);
  }
  function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
    let value;
    if (typeof themeMapping === "function") {
      value = themeMapping(propValueFinal);
    } else if (Array.isArray(themeMapping)) {
      value = themeMapping[propValueFinal] || userValue;
    } else {
      value = getPath(themeMapping, propValueFinal) || userValue;
    }
    if (transform) {
      value = transform(value, userValue, themeMapping);
    }
    return value;
  }
  function style$1(options2) {
    const {
      prop,
      cssProperty = options2.prop,
      themeKey,
      transform
    } = options2;
    const fn = (props) => {
      if (props[prop] == null) {
        return null;
      }
      const propValue = props[prop];
      const theme = props.theme;
      const themeMapping = getPath(theme, themeKey) || {};
      const styleFromPropValue = (propValueFinal) => {
        let value = getStyleValue$1(themeMapping, transform, propValueFinal);
        if (propValueFinal === value && typeof propValueFinal === "string") {
          value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
        }
        if (cssProperty === false) {
          return value;
        }
        return {
          [cssProperty]: value
        };
      };
      return handleBreakpoints(props, propValue, styleFromPropValue);
    };
    fn.propTypes = {};
    fn.filterProps = [prop];
    return fn;
  }
  function memoize(fn) {
    const cache2 = {};
    return (arg) => {
      if (cache2[arg] === void 0) {
        cache2[arg] = fn(arg);
      }
      return cache2[arg];
    };
  }
  const properties = {
    m: "margin",
    p: "padding"
  };
  const directions = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
  };
  const aliases = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
  };
  const getCssProperties = memoize((prop) => {
    if (prop.length > 2) {
      if (aliases[prop]) {
        prop = aliases[prop];
      } else {
        return [prop];
      }
    }
    const [a, b2] = prop.split("");
    const property = properties[a];
    const direction = directions[b2] || "";
    return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
  });
  const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
  const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
  [...marginKeys, ...paddingKeys];
  function createUnaryUnit(theme, themeKey, defaultValue, propName) {
    var _getPath;
    const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
    if (typeof themeSpacing === "number") {
      return (abs2) => {
        if (typeof abs2 === "string") {
          return abs2;
        }
        return themeSpacing * abs2;
      };
    }
    if (Array.isArray(themeSpacing)) {
      return (abs2) => {
        if (typeof abs2 === "string") {
          return abs2;
        }
        return themeSpacing[abs2];
      };
    }
    if (typeof themeSpacing === "function") {
      return themeSpacing;
    }
    return () => void 0;
  }
  function createUnarySpacing(theme) {
    return createUnaryUnit(theme, "spacing", 8);
  }
  function getValue(transformer, propValue) {
    if (typeof propValue === "string" || propValue == null) {
      return propValue;
    }
    const abs2 = Math.abs(propValue);
    const transformed = transformer(abs2);
    if (propValue >= 0) {
      return transformed;
    }
    if (typeof transformed === "number") {
      return -transformed;
    }
    return `-${transformed}`;
  }
  function getStyleFromPropValue(cssProperties, transformer) {
    return (propValue) => cssProperties.reduce((acc, cssProperty) => {
      acc[cssProperty] = getValue(transformer, propValue);
      return acc;
    }, {});
  }
  function resolveCssProperty(props, keys, prop, transformer) {
    if (keys.indexOf(prop) === -1) {
      return null;
    }
    const cssProperties = getCssProperties(prop);
    const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
    const propValue = props[prop];
    return handleBreakpoints(props, propValue, styleFromPropValue);
  }
  function style(props, keys) {
    const transformer = createUnarySpacing(props.theme);
    return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge$1, {});
  }
  function margin(props) {
    return style(props, marginKeys);
  }
  margin.propTypes = {};
  margin.filterProps = marginKeys;
  function padding(props) {
    return style(props, paddingKeys);
  }
  padding.propTypes = {};
  padding.filterProps = paddingKeys;
  function createSpacing(spacingInput = 8) {
    if (spacingInput.mui) {
      return spacingInput;
    }
    const transform = createUnarySpacing({
      spacing: spacingInput
    });
    const spacing = (...argsInput) => {
      const args = argsInput.length === 0 ? [1] : argsInput;
      return args.map((argument) => {
        const output = transform(argument);
        return typeof output === "number" ? `${output}px` : output;
      }).join(" ");
    };
    spacing.mui = true;
    return spacing;
  }
  function compose(...styles2) {
    const handlers = styles2.reduce((acc, style2) => {
      style2.filterProps.forEach((prop) => {
        acc[prop] = style2;
      });
      return acc;
    }, {});
    const fn = (props) => {
      return Object.keys(props).reduce((acc, prop) => {
        if (handlers[prop]) {
          return merge$1(acc, handlers[prop](props));
        }
        return acc;
      }, {});
    };
    fn.propTypes = {};
    fn.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
    return fn;
  }
  function borderTransform(value) {
    if (typeof value !== "number") {
      return value;
    }
    return `${value}px solid`;
  }
  function createBorderStyle(prop, transform) {
    return style$1({
      prop,
      themeKey: "borders",
      transform
    });
  }
  const border = createBorderStyle("border", borderTransform);
  const borderTop = createBorderStyle("borderTop", borderTransform);
  const borderRight = createBorderStyle("borderRight", borderTransform);
  const borderBottom = createBorderStyle("borderBottom", borderTransform);
  const borderLeft = createBorderStyle("borderLeft", borderTransform);
  const borderColor = createBorderStyle("borderColor");
  const borderTopColor = createBorderStyle("borderTopColor");
  const borderRightColor = createBorderStyle("borderRightColor");
  const borderBottomColor = createBorderStyle("borderBottomColor");
  const borderLeftColor = createBorderStyle("borderLeftColor");
  const outline = createBorderStyle("outline", borderTransform);
  const outlineColor = createBorderStyle("outlineColor");
  const borderRadius = (props) => {
    if (props.borderRadius !== void 0 && props.borderRadius !== null) {
      const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
      const styleFromPropValue = (propValue) => ({
        borderRadius: getValue(transformer, propValue)
      });
      return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
    }
    return null;
  };
  borderRadius.propTypes = {};
  borderRadius.filterProps = ["borderRadius"];
  compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
  const gap = (props) => {
    if (props.gap !== void 0 && props.gap !== null) {
      const transformer = createUnaryUnit(props.theme, "spacing", 8);
      const styleFromPropValue = (propValue) => ({
        gap: getValue(transformer, propValue)
      });
      return handleBreakpoints(props, props.gap, styleFromPropValue);
    }
    return null;
  };
  gap.propTypes = {};
  gap.filterProps = ["gap"];
  const columnGap = (props) => {
    if (props.columnGap !== void 0 && props.columnGap !== null) {
      const transformer = createUnaryUnit(props.theme, "spacing", 8);
      const styleFromPropValue = (propValue) => ({
        columnGap: getValue(transformer, propValue)
      });
      return handleBreakpoints(props, props.columnGap, styleFromPropValue);
    }
    return null;
  };
  columnGap.propTypes = {};
  columnGap.filterProps = ["columnGap"];
  const rowGap = (props) => {
    if (props.rowGap !== void 0 && props.rowGap !== null) {
      const transformer = createUnaryUnit(props.theme, "spacing", 8);
      const styleFromPropValue = (propValue) => ({
        rowGap: getValue(transformer, propValue)
      });
      return handleBreakpoints(props, props.rowGap, styleFromPropValue);
    }
    return null;
  };
  rowGap.propTypes = {};
  rowGap.filterProps = ["rowGap"];
  const gridColumn = style$1({
    prop: "gridColumn"
  });
  const gridRow = style$1({
    prop: "gridRow"
  });
  const gridAutoFlow = style$1({
    prop: "gridAutoFlow"
  });
  const gridAutoColumns = style$1({
    prop: "gridAutoColumns"
  });
  const gridAutoRows = style$1({
    prop: "gridAutoRows"
  });
  const gridTemplateColumns = style$1({
    prop: "gridTemplateColumns"
  });
  const gridTemplateRows = style$1({
    prop: "gridTemplateRows"
  });
  const gridTemplateAreas = style$1({
    prop: "gridTemplateAreas"
  });
  const gridArea = style$1({
    prop: "gridArea"
  });
  compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
  function paletteTransform(value, userValue) {
    if (userValue === "grey") {
      return userValue;
    }
    return value;
  }
  const color = style$1({
    prop: "color",
    themeKey: "palette",
    transform: paletteTransform
  });
  const bgcolor = style$1({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
  });
  const backgroundColor = style$1({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
  });
  compose(color, bgcolor, backgroundColor);
  function sizingTransform(value) {
    return value <= 1 && value !== 0 ? `${value * 100}%` : value;
  }
  const width = style$1({
    prop: "width",
    transform: sizingTransform
  });
  const maxWidth = (props) => {
    if (props.maxWidth !== void 0 && props.maxWidth !== null) {
      const styleFromPropValue = (propValue) => {
        var _props$theme, _props$theme2;
        const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
        if (!breakpoint) {
          return {
            maxWidth: sizingTransform(propValue)
          };
        }
        if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== "px") {
          return {
            maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
          };
        }
        return {
          maxWidth: breakpoint
        };
      };
      return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
    }
    return null;
  };
  maxWidth.filterProps = ["maxWidth"];
  const minWidth = style$1({
    prop: "minWidth",
    transform: sizingTransform
  });
  const height = style$1({
    prop: "height",
    transform: sizingTransform
  });
  const maxHeight = style$1({
    prop: "maxHeight",
    transform: sizingTransform
  });
  const minHeight = style$1({
    prop: "minHeight",
    transform: sizingTransform
  });
  style$1({
    prop: "size",
    cssProperty: "width",
    transform: sizingTransform
  });
  style$1({
    prop: "size",
    cssProperty: "height",
    transform: sizingTransform
  });
  const boxSizing = style$1({
    prop: "boxSizing"
  });
  compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
  const defaultSxConfig = {
    // borders
    border: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderTop: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderRight: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderBottom: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderLeft: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderColor: {
      themeKey: "palette"
    },
    borderTopColor: {
      themeKey: "palette"
    },
    borderRightColor: {
      themeKey: "palette"
    },
    borderBottomColor: {
      themeKey: "palette"
    },
    borderLeftColor: {
      themeKey: "palette"
    },
    outline: {
      themeKey: "borders",
      transform: borderTransform
    },
    outlineColor: {
      themeKey: "palette"
    },
    borderRadius: {
      themeKey: "shape.borderRadius",
      style: borderRadius
    },
    // palette
    color: {
      themeKey: "palette",
      transform: paletteTransform
    },
    bgcolor: {
      themeKey: "palette",
      cssProperty: "backgroundColor",
      transform: paletteTransform
    },
    backgroundColor: {
      themeKey: "palette",
      transform: paletteTransform
    },
    // spacing
    p: {
      style: padding
    },
    pt: {
      style: padding
    },
    pr: {
      style: padding
    },
    pb: {
      style: padding
    },
    pl: {
      style: padding
    },
    px: {
      style: padding
    },
    py: {
      style: padding
    },
    padding: {
      style: padding
    },
    paddingTop: {
      style: padding
    },
    paddingRight: {
      style: padding
    },
    paddingBottom: {
      style: padding
    },
    paddingLeft: {
      style: padding
    },
    paddingX: {
      style: padding
    },
    paddingY: {
      style: padding
    },
    paddingInline: {
      style: padding
    },
    paddingInlineStart: {
      style: padding
    },
    paddingInlineEnd: {
      style: padding
    },
    paddingBlock: {
      style: padding
    },
    paddingBlockStart: {
      style: padding
    },
    paddingBlockEnd: {
      style: padding
    },
    m: {
      style: margin
    },
    mt: {
      style: margin
    },
    mr: {
      style: margin
    },
    mb: {
      style: margin
    },
    ml: {
      style: margin
    },
    mx: {
      style: margin
    },
    my: {
      style: margin
    },
    margin: {
      style: margin
    },
    marginTop: {
      style: margin
    },
    marginRight: {
      style: margin
    },
    marginBottom: {
      style: margin
    },
    marginLeft: {
      style: margin
    },
    marginX: {
      style: margin
    },
    marginY: {
      style: margin
    },
    marginInline: {
      style: margin
    },
    marginInlineStart: {
      style: margin
    },
    marginInlineEnd: {
      style: margin
    },
    marginBlock: {
      style: margin
    },
    marginBlockStart: {
      style: margin
    },
    marginBlockEnd: {
      style: margin
    },
    // display
    displayPrint: {
      cssProperty: false,
      transform: (value) => ({
        "@media print": {
          display: value
        }
      })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    // flexbox
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    // grid
    gap: {
      style: gap
    },
    rowGap: {
      style: rowGap
    },
    columnGap: {
      style: columnGap
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    // positions
    position: {},
    zIndex: {
      themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    // shadows
    boxShadow: {
      themeKey: "shadows"
    },
    // sizing
    width: {
      transform: sizingTransform
    },
    maxWidth: {
      style: maxWidth
    },
    minWidth: {
      transform: sizingTransform
    },
    height: {
      transform: sizingTransform
    },
    maxHeight: {
      transform: sizingTransform
    },
    minHeight: {
      transform: sizingTransform
    },
    boxSizing: {},
    // typography
    fontFamily: {
      themeKey: "typography"
    },
    fontSize: {
      themeKey: "typography"
    },
    fontStyle: {
      themeKey: "typography"
    },
    fontWeight: {
      themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
      cssProperty: false,
      themeKey: "typography"
    }
  };
  function objectsHaveSameKeys(...objects) {
    const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
    const union = new Set(allKeys);
    return objects.every((object) => union.size === Object.keys(object).length);
  }
  function callIfFn(maybeFn, arg) {
    return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
  }
  function unstable_createStyleFunctionSx() {
    function getThemeValue(prop, val, theme, config2) {
      const props = {
        [prop]: val,
        theme
      };
      const options2 = config2[prop];
      if (!options2) {
        return {
          [prop]: val
        };
      }
      const {
        cssProperty = prop,
        themeKey,
        transform,
        style: style2
      } = options2;
      if (val == null) {
        return null;
      }
      if (themeKey === "typography" && val === "inherit") {
        return {
          [prop]: val
        };
      }
      const themeMapping = getPath(theme, themeKey) || {};
      if (style2) {
        return style2(props);
      }
      const styleFromPropValue = (propValueFinal) => {
        let value = getStyleValue$1(themeMapping, transform, propValueFinal);
        if (propValueFinal === value && typeof propValueFinal === "string") {
          value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
        }
        if (cssProperty === false) {
          return value;
        }
        return {
          [cssProperty]: value
        };
      };
      return handleBreakpoints(props, val, styleFromPropValue);
    }
    function styleFunctionSx2(props) {
      var _theme$unstable_sxCon;
      const {
        sx,
        theme = {}
      } = props || {};
      if (!sx) {
        return null;
      }
      const config2 = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig;
      function traverse(sxInput) {
        let sxObject = sxInput;
        if (typeof sxInput === "function") {
          sxObject = sxInput(theme);
        } else if (typeof sxInput !== "object") {
          return sxInput;
        }
        if (!sxObject) {
          return null;
        }
        const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
        const breakpointsKeys = Object.keys(emptyBreakpoints);
        let css2 = emptyBreakpoints;
        Object.keys(sxObject).forEach((styleKey) => {
          const value = callIfFn(sxObject[styleKey], theme);
          if (value !== null && value !== void 0) {
            if (typeof value === "object") {
              if (config2[styleKey]) {
                css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
              } else {
                const breakpointsValues = handleBreakpoints({
                  theme
                }, value, (x2) => ({
                  [styleKey]: x2
                }));
                if (objectsHaveSameKeys(breakpointsValues, value)) {
                  css2[styleKey] = styleFunctionSx2({
                    sx: value,
                    theme
                  });
                } else {
                  css2 = merge$1(css2, breakpointsValues);
                }
              }
            } else {
              css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
            }
          }
        });
        return removeUnusedBreakpoints(breakpointsKeys, css2);
      }
      return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
    }
    return styleFunctionSx2;
  }
  const styleFunctionSx$1 = unstable_createStyleFunctionSx();
  styleFunctionSx$1.filterProps = ["sx"];
  function applyStyles$2(key, styles2) {
    const theme = this;
    if (theme.vars && typeof theme.getColorSchemeSelector === "function") {
      const selector = theme.getColorSchemeSelector(key).replace(/(\[[^\]]+\])/, "*:where($1)");
      return {
        [selector]: styles2
      };
    }
    if (theme.palette.mode === key) {
      return styles2;
    }
    return {};
  }
  const _excluded$1x = ["breakpoints", "palette", "spacing", "shape"];
  function createTheme$2(options2 = {}, ...args) {
    const {
      breakpoints: breakpointsInput = {},
      palette: paletteInput = {},
      spacing: spacingInput,
      shape: shapeInput = {}
    } = options2, other = _objectWithoutPropertiesLoose(options2, _excluded$1x);
    const breakpoints = createBreakpoints(breakpointsInput);
    const spacing = createSpacing(spacingInput);
    let muiTheme = deepmerge$1({
      breakpoints,
      direction: "ltr",
      components: {},
      // Inject component definitions.
      palette: _extends$1({
        mode: "light"
      }, paletteInput),
      spacing,
      shape: _extends$1({}, shape, shapeInput)
    }, other);
    muiTheme.applyStyles = applyStyles$2;
    muiTheme = args.reduce((acc, argument) => deepmerge$1(acc, argument), muiTheme);
    muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig, other == null ? void 0 : other.unstable_sxConfig);
    muiTheme.unstable_sx = function sx(props) {
      return styleFunctionSx$1({
        sx: props,
        theme: this
      });
    };
    return muiTheme;
  }
  const createTheme$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: createTheme$2,
    private_createBreakpoints: createBreakpoints,
    unstable_applyStyles: applyStyles$2
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$7 = /* @__PURE__ */ getAugmentedNamespace(createTheme$1);
  const _excluded$1w = ["sx"];
  const splitProps = (props) => {
    var _props$theme$unstable, _props$theme;
    const result = {
      systemProps: {},
      otherProps: {}
    };
    const config2 = (_props$theme$unstable = props == null || (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig;
    Object.keys(props).forEach((prop) => {
      if (config2[prop]) {
        result.systemProps[prop] = props[prop];
      } else {
        result.otherProps[prop] = props[prop];
      }
    });
    return result;
  };
  function extendSxProp(props) {
    const {
      sx: inSx
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1w);
    const {
      systemProps,
      otherProps
    } = splitProps(other);
    let finalSx;
    if (Array.isArray(inSx)) {
      finalSx = [systemProps, ...inSx];
    } else if (typeof inSx === "function") {
      finalSx = (...args) => {
        const result = inSx(...args);
        if (!isPlainObject$1(result)) {
          return systemProps;
        }
        return _extends$1({}, systemProps, result);
      };
    } else {
      finalSx = _extends$1({}, systemProps, inSx);
    }
    return _extends$1({}, otherProps, {
      sx: finalSx
    });
  }
  const styleFunctionSx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: styleFunctionSx$1,
    extendSxProp,
    unstable_createStyleFunctionSx,
    unstable_defaultSxConfig: defaultSxConfig
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$8 = /* @__PURE__ */ getAugmentedNamespace(styleFunctionSx);
  var _interopRequireDefault = interopRequireDefaultExports;
  Object.defineProperty(createStyled$2, "__esModule", {
    value: true
  });
  var _default = createStyled$2.default = createStyled;
  createStyled$2.shouldForwardProp = shouldForwardProp$1;
  createStyled$2.systemDefaultTheme = void 0;
  var _extends2 = _interopRequireDefault(require_extends());
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(requireObjectWithoutPropertiesLoose());
  var _styledEngine$1 = _interopRequireWildcard$1(require$$1);
  var _deepmerge = require$$4;
  _interopRequireDefault(require$$5);
  _interopRequireDefault(require$$6);
  var _createTheme = _interopRequireDefault(require$$7);
  var _styleFunctionSx = _interopRequireDefault(require$$8);
  const _excluded$1v = ["ownerState"], _excluded2$c = ["variants"], _excluded3$4 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
  function _getRequireWildcardCache$1(e2) {
    if ("function" != typeof WeakMap)
      return null;
    var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache$1 = function(e22) {
      return e22 ? t2 : r2;
    })(e2);
  }
  function _interopRequireWildcard$1(e2, r2) {
    if (e2 && e2.__esModule)
      return e2;
    if (null === e2 || "object" != typeof e2 && "function" != typeof e2)
      return { default: e2 };
    var t2 = _getRequireWildcardCache$1(r2);
    if (t2 && t2.has(e2))
      return t2.get(e2);
    var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u2 in e2)
      if ("default" !== u2 && Object.prototype.hasOwnProperty.call(e2, u2)) {
        var i = a ? Object.getOwnPropertyDescriptor(e2, u2) : null;
        i && (i.get || i.set) ? Object.defineProperty(n2, u2, i) : n2[u2] = e2[u2];
      }
    return n2.default = e2, t2 && t2.set(e2, n2), n2;
  }
  function isEmpty$2(obj) {
    return Object.keys(obj).length === 0;
  }
  function isStringTag(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96;
  }
  function shouldForwardProp$1(prop) {
    return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
  }
  const systemDefaultTheme$1 = createStyled$2.systemDefaultTheme = (0, _createTheme.default)();
  const lowercaseFirstLetter = (string) => {
    if (!string) {
      return string;
    }
    return string.charAt(0).toLowerCase() + string.slice(1);
  };
  function resolveTheme({
    defaultTheme: defaultTheme2,
    theme,
    themeId
  }) {
    return isEmpty$2(theme) ? defaultTheme2 : theme[themeId] || theme;
  }
  function defaultOverridesResolver(slot) {
    if (!slot) {
      return null;
    }
    return (props, styles2) => styles2[slot];
  }
  function processStyleArg(callableStyle, _ref) {
    let {
      ownerState
    } = _ref, props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded$1v);
    const resolvedStylesArg = typeof callableStyle === "function" ? callableStyle((0, _extends2.default)({
      ownerState
    }, props)) : callableStyle;
    if (Array.isArray(resolvedStylesArg)) {
      return resolvedStylesArg.flatMap((resolvedStyle) => processStyleArg(resolvedStyle, (0, _extends2.default)({
        ownerState
      }, props)));
    }
    if (!!resolvedStylesArg && typeof resolvedStylesArg === "object" && Array.isArray(resolvedStylesArg.variants)) {
      const {
        variants = []
      } = resolvedStylesArg, otherStyles = (0, _objectWithoutPropertiesLoose2.default)(resolvedStylesArg, _excluded2$c);
      let result = otherStyles;
      variants.forEach((variant) => {
        let isMatch = true;
        if (typeof variant.props === "function") {
          isMatch = variant.props((0, _extends2.default)({
            ownerState
          }, props, ownerState));
        } else {
          Object.keys(variant.props).forEach((key) => {
            if ((ownerState == null ? void 0 : ownerState[key]) !== variant.props[key] && props[key] !== variant.props[key]) {
              isMatch = false;
            }
          });
        }
        if (isMatch) {
          if (!Array.isArray(result)) {
            result = [result];
          }
          result.push(typeof variant.style === "function" ? variant.style((0, _extends2.default)({
            ownerState
          }, props, ownerState)) : variant.style);
        }
      });
      return result;
    }
    return resolvedStylesArg;
  }
  function createStyled(input = {}) {
    const {
      themeId,
      defaultTheme: defaultTheme2 = systemDefaultTheme$1,
      rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp$1,
      slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp$1
    } = input;
    const systemSx = (props) => {
      return (0, _styleFunctionSx.default)((0, _extends2.default)({}, props, {
        theme: resolveTheme((0, _extends2.default)({}, props, {
          defaultTheme: defaultTheme2,
          themeId
        }))
      }));
    };
    systemSx.__mui_systemSx = true;
    return (tag, inputOptions = {}) => {
      (0, _styledEngine$1.internal_processStyles)(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
      const {
        name: componentName,
        slot: componentSlot,
        skipVariantsResolver: inputSkipVariantsResolver,
        skipSx: inputSkipSx,
        // TODO v6: remove `lowercaseFirstLetter()` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
      } = inputOptions, options2 = (0, _objectWithoutPropertiesLoose2.default)(inputOptions, _excluded3$4);
      const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
        // TODO v6: remove `Root` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
      );
      const skipSx = inputSkipSx || false;
      let label;
      let shouldForwardPropOption = shouldForwardProp$1;
      if (componentSlot === "Root" || componentSlot === "root") {
        shouldForwardPropOption = rootShouldForwardProp2;
      } else if (componentSlot) {
        shouldForwardPropOption = slotShouldForwardProp2;
      } else if (isStringTag(tag)) {
        shouldForwardPropOption = void 0;
      }
      const defaultStyledResolver = (0, _styledEngine$1.default)(tag, (0, _extends2.default)({
        shouldForwardProp: shouldForwardPropOption,
        label
      }, options2));
      const transformStyleArg = (stylesArg) => {
        if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg || (0, _deepmerge.isPlainObject)(stylesArg)) {
          return (props) => processStyleArg(stylesArg, (0, _extends2.default)({}, props, {
            theme: resolveTheme({
              theme: props.theme,
              defaultTheme: defaultTheme2,
              themeId
            })
          }));
        }
        return stylesArg;
      };
      const muiStyledResolver = (styleArg2, ...expressions) => {
        let transformedStyleArg = transformStyleArg(styleArg2);
        const expressionsWithDefaultTheme = expressions ? expressions.map(transformStyleArg) : [];
        if (componentName && overridesResolver2) {
          expressionsWithDefaultTheme.push((props) => {
            const theme = resolveTheme((0, _extends2.default)({}, props, {
              defaultTheme: defaultTheme2,
              themeId
            }));
            if (!theme.components || !theme.components[componentName] || !theme.components[componentName].styleOverrides) {
              return null;
            }
            const styleOverrides = theme.components[componentName].styleOverrides;
            const resolvedStyleOverrides = {};
            Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
              resolvedStyleOverrides[slotKey] = processStyleArg(slotStyle, (0, _extends2.default)({}, props, {
                theme
              }));
            });
            return overridesResolver2(props, resolvedStyleOverrides);
          });
        }
        if (componentName && !skipVariantsResolver) {
          expressionsWithDefaultTheme.push((props) => {
            var _theme$components;
            const theme = resolveTheme((0, _extends2.default)({}, props, {
              defaultTheme: defaultTheme2,
              themeId
            }));
            const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[componentName]) == null ? void 0 : _theme$components.variants;
            return processStyleArg({
              variants: themeVariants
            }, (0, _extends2.default)({}, props, {
              theme
            }));
          });
        }
        if (!skipSx) {
          expressionsWithDefaultTheme.push(systemSx);
        }
        const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
        if (Array.isArray(styleArg2) && numOfCustomFnsApplied > 0) {
          const placeholders = new Array(numOfCustomFnsApplied).fill("");
          transformedStyleArg = [...styleArg2, ...placeholders];
          transformedStyleArg.raw = [...styleArg2.raw, ...placeholders];
        }
        const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
        if (tag.muiName) {
          Component.muiName = tag.muiName;
        }
        return Component;
      };
      if (defaultStyledResolver.withConfig) {
        muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
      }
      return muiStyledResolver;
    };
  }
  const defaultGenerator = (componentName) => componentName;
  const createClassNameGenerator = () => {
    let generate = defaultGenerator;
    return {
      configure(generator) {
        generate = generator;
      },
      generate(componentName) {
        return generate(componentName);
      },
      reset() {
        generate = defaultGenerator;
      }
    };
  };
  const ClassNameGenerator = createClassNameGenerator();
  const globalStateClasses = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
  };
  function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
    const globalStateClass = globalStateClasses[slot];
    return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
  }
  function createMixins(breakpoints, mixins) {
    return _extends$1({
      toolbar: {
        minHeight: 56,
        [breakpoints.up("xs")]: {
          "@media (orientation: landscape)": {
            minHeight: 48
          }
        },
        [breakpoints.up("sm")]: {
          minHeight: 64
        }
      }
    }, mixins);
  }
  const common = {
    black: "#000",
    white: "#fff"
  };
  const grey = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
  };
  const purple = {
    50: "#f3e5f5",
    100: "#e1bee7",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    600: "#8e24aa",
    700: "#7b1fa2",
    800: "#6a1b9a",
    900: "#4a148c",
    A100: "#ea80fc",
    A200: "#e040fb",
    A400: "#d500f9",
    A700: "#aa00ff"
  };
  const red = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000"
  };
  const orange = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    A100: "#ffd180",
    A200: "#ffab40",
    A400: "#ff9100",
    A700: "#ff6d00"
  };
  const blue = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    A100: "#82b1ff",
    A200: "#448aff",
    A400: "#2979ff",
    A700: "#2962ff"
  };
  const lightBlue = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    A100: "#80d8ff",
    A200: "#40c4ff",
    A400: "#00b0ff",
    A700: "#0091ea"
  };
  const green = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    A100: "#b9f6ca",
    A200: "#69f0ae",
    A400: "#00e676",
    A700: "#00c853"
  };
  const _excluded$1u = ["mode", "contrastThreshold", "tonalOffset"];
  const light = {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common.white,
      default: common.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
  const dark = {
    text: {
      primary: common.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: common.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
  function addLightOrDark(intent, direction, shade, tonalOffset) {
    const tonalOffsetLight = tonalOffset.light || tonalOffset;
    const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
    if (!intent[direction]) {
      if (intent.hasOwnProperty(shade)) {
        intent[direction] = intent[shade];
      } else if (direction === "light") {
        intent.light = lighten_1(intent.main, tonalOffsetLight);
      } else if (direction === "dark") {
        intent.dark = darken_1(intent.main, tonalOffsetDark);
      }
    }
  }
  function getDefaultPrimary(mode = "light") {
    if (mode === "dark") {
      return {
        main: blue[200],
        light: blue[50],
        dark: blue[400]
      };
    }
    return {
      main: blue[700],
      light: blue[400],
      dark: blue[800]
    };
  }
  function getDefaultSecondary(mode = "light") {
    if (mode === "dark") {
      return {
        main: purple[200],
        light: purple[50],
        dark: purple[400]
      };
    }
    return {
      main: purple[500],
      light: purple[300],
      dark: purple[700]
    };
  }
  function getDefaultError(mode = "light") {
    if (mode === "dark") {
      return {
        main: red[500],
        light: red[300],
        dark: red[700]
      };
    }
    return {
      main: red[700],
      light: red[400],
      dark: red[800]
    };
  }
  function getDefaultInfo(mode = "light") {
    if (mode === "dark") {
      return {
        main: lightBlue[400],
        light: lightBlue[300],
        dark: lightBlue[700]
      };
    }
    return {
      main: lightBlue[700],
      light: lightBlue[500],
      dark: lightBlue[900]
    };
  }
  function getDefaultSuccess(mode = "light") {
    if (mode === "dark") {
      return {
        main: green[400],
        light: green[300],
        dark: green[700]
      };
    }
    return {
      main: green[800],
      light: green[500],
      dark: green[900]
    };
  }
  function getDefaultWarning(mode = "light") {
    if (mode === "dark") {
      return {
        main: orange[400],
        light: orange[300],
        dark: orange[700]
      };
    }
    return {
      main: "#ed6c02",
      // closest to orange[800] that pass 3:1.
      light: orange[500],
      dark: orange[900]
    };
  }
  function createPalette(palette) {
    const {
      mode = "light",
      contrastThreshold = 3,
      tonalOffset = 0.2
    } = palette, other = _objectWithoutPropertiesLoose(palette, _excluded$1u);
    const primary = palette.primary || getDefaultPrimary(mode);
    const secondary = palette.secondary || getDefaultSecondary(mode);
    const error = palette.error || getDefaultError(mode);
    const info = palette.info || getDefaultInfo(mode);
    const success = palette.success || getDefaultSuccess(mode);
    const warning = palette.warning || getDefaultWarning(mode);
    function getContrastText(background) {
      const contrastText = getContrastRatio_1(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
      return contrastText;
    }
    const augmentColor = ({
      color: color2,
      name,
      mainShade = 500,
      lightShade = 300,
      darkShade = 700
    }) => {
      color2 = _extends$1({}, color2);
      if (!color2.main && color2[mainShade]) {
        color2.main = color2[mainShade];
      }
      if (!color2.hasOwnProperty("main")) {
        throw new Error(formatMuiErrorMessage$1(11, name ? ` (${name})` : "", mainShade));
      }
      if (typeof color2.main !== "string") {
        throw new Error(formatMuiErrorMessage$1(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
      }
      addLightOrDark(color2, "light", lightShade, tonalOffset);
      addLightOrDark(color2, "dark", darkShade, tonalOffset);
      if (!color2.contrastText) {
        color2.contrastText = getContrastText(color2.main);
      }
      return color2;
    };
    const modes = {
      dark,
      light
    };
    const paletteOutput = deepmerge$1(_extends$1({
      // A collection of common colors.
      common: _extends$1({}, common),
      // prevent mutable object.
      // The palette mode, can be light or dark.
      mode,
      // The colors used to represent primary interface elements for a user.
      primary: augmentColor({
        color: primary,
        name: "primary"
      }),
      // The colors used to represent secondary interface elements for a user.
      secondary: augmentColor({
        color: secondary,
        name: "secondary",
        mainShade: "A400",
        lightShade: "A200",
        darkShade: "A700"
      }),
      // The colors used to represent interface elements that the user should be made aware of.
      error: augmentColor({
        color: error,
        name: "error"
      }),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: augmentColor({
        color: warning,
        name: "warning"
      }),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: augmentColor({
        color: info,
        name: "info"
      }),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: augmentColor({
        color: success,
        name: "success"
      }),
      // The grey colors.
      grey,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText,
      // Generate a rich color object.
      augmentColor,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset
    }, modes[mode]), other);
    return paletteOutput;
  }
  const _excluded$1t = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
  function round$2(value) {
    return Math.round(value * 1e5) / 1e5;
  }
  const caseAllCaps = {
    textTransform: "uppercase"
  };
  const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
  function createTypography(palette, typography) {
    const _ref = typeof typography === "function" ? typography(palette) : typography, {
      fontFamily = defaultFontFamily,
      // The default font size of the Material Specification.
      fontSize = 14,
      // px
      fontWeightLight = 300,
      fontWeightRegular = 400,
      fontWeightMedium = 500,
      fontWeightBold = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize = 16,
      // Apply the CSS properties to all the variants.
      allVariants,
      pxToRem: pxToRem2
    } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$1t);
    const coef = fontSize / 14;
    const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
    const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends$1({
      fontFamily,
      fontWeight,
      fontSize: pxToRem(size),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight
    }, fontFamily === defaultFontFamily ? {
      letterSpacing: `${round$2(letterSpacing / size)}em`
    } : {}, casing, allVariants);
    const variants = {
      h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
      h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
      h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
      h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
      h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
      h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
      subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
      subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
      body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
      body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
      button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
      caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
      overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
      // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    };
    return deepmerge$1(_extends$1({
      htmlFontSize,
      pxToRem,
      fontFamily,
      fontSize,
      fontWeightLight,
      fontWeightRegular,
      fontWeightMedium,
      fontWeightBold
    }, variants), other, {
      clone: false
      // No need to clone deep
    });
  }
  const shadowKeyUmbraOpacity = 0.2;
  const shadowKeyPenumbraOpacity = 0.14;
  const shadowAmbientShadowOpacity = 0.12;
  function createShadow(...px) {
    return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
  }
  const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
  const _excluded$1s = ["duration", "easing", "delay"];
  const easing = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
  };
  const duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };
  function formatMs(milliseconds) {
    return `${Math.round(milliseconds)}ms`;
  }
  function getAutoHeightDuration(height2) {
    if (!height2) {
      return 0;
    }
    const constant = height2 / 36;
    return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
  }
  function createTransitions(inputTransitions) {
    const mergedEasing = _extends$1({}, easing, inputTransitions.easing);
    const mergedDuration = _extends$1({}, duration, inputTransitions.duration);
    const create = (props = ["all"], options2 = {}) => {
      const {
        duration: durationOption = mergedDuration.standard,
        easing: easingOption = mergedEasing.easeInOut,
        delay = 0
      } = options2;
      _objectWithoutPropertiesLoose(options2, _excluded$1s);
      return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
    };
    return _extends$1({
      getAutoHeightDuration,
      create
    }, inputTransitions, {
      easing: mergedEasing,
      duration: mergedDuration
    });
  }
  const zIndex = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  };
  const _excluded$1r = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
  function createTheme(options2 = {}, ...args) {
    const {
      mixins: mixinsInput = {},
      palette: paletteInput = {},
      transitions: transitionsInput = {},
      typography: typographyInput = {}
    } = options2, other = _objectWithoutPropertiesLoose(options2, _excluded$1r);
    if (options2.vars) {
      throw new Error(formatMuiErrorMessage$1(18));
    }
    const palette = createPalette(paletteInput);
    const systemTheme = createTheme$2(options2);
    let muiTheme = deepmerge$1(systemTheme, {
      mixins: createMixins(systemTheme.breakpoints, mixinsInput),
      palette,
      // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
      shadows: shadows.slice(),
      typography: createTypography(palette, typographyInput),
      transitions: createTransitions(transitionsInput),
      zIndex: _extends$1({}, zIndex)
    });
    muiTheme = deepmerge$1(muiTheme, other);
    muiTheme = args.reduce((acc, argument) => deepmerge$1(acc, argument), muiTheme);
    muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig, other == null ? void 0 : other.unstable_sxConfig);
    muiTheme.unstable_sx = function sx(props) {
      return styleFunctionSx$1({
        sx: props,
        theme: this
      });
    };
    return muiTheme;
  }
  const defaultTheme = createTheme();
  const THEME_ID = "$$material";
  function slotShouldForwardProp(prop) {
    return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
  }
  const rootShouldForwardProp = (prop) => slotShouldForwardProp(prop) && prop !== "classes";
  const styled = _default({
    themeId: THEME_ID,
    defaultTheme,
    rootShouldForwardProp
  });
  function useControlled({
    controlled,
    default: defaultProp,
    name,
    state = "value"
  }) {
    const {
      current: isControlled
    } = reactExports.useRef(controlled !== void 0);
    const [valueState, setValue] = reactExports.useState(defaultProp);
    const value = isControlled ? controlled : valueState;
    const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
      if (!isControlled) {
        setValue(newValue);
      }
    }, []);
    return [value, setValueIfUncontrolled];
  }
  const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
  function useFormControl() {
    return reactExports.useContext(FormControlContext);
  }
  function resolveProps(defaultProps2, props) {
    const output = _extends$1({}, props);
    Object.keys(defaultProps2).forEach((propName) => {
      if (propName.toString().match(/^(components|slots)$/)) {
        output[propName] = _extends$1({}, defaultProps2[propName], output[propName]);
      } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
        const defaultSlotProps = defaultProps2[propName] || {};
        const slotProps = props[propName];
        output[propName] = {};
        if (!slotProps || !Object.keys(slotProps)) {
          output[propName] = defaultSlotProps;
        } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
          output[propName] = slotProps;
        } else {
          output[propName] = _extends$1({}, slotProps);
          Object.keys(defaultSlotProps).forEach((slotPropName) => {
            output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
          });
        }
      } else if (output[propName] === void 0) {
        output[propName] = defaultProps2[propName];
      }
    });
    return output;
  }
  const PropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
  function getThemeProps$1(params) {
    const {
      theme,
      name,
      props
    } = params;
    if (!theme || !theme.components || !theme.components[name]) {
      return props;
    }
    const config2 = theme.components[name];
    if (config2.defaultProps) {
      return resolveProps(config2.defaultProps, props);
    }
    if (!config2.styleOverrides && !config2.variants) {
      return resolveProps(config2, props);
    }
    return props;
  }
  function useDefaultProps$1({
    props,
    name
  }) {
    const ctx = reactExports.useContext(PropsContext);
    return getThemeProps$1({
      props,
      name,
      theme: {
        components: ctx
      }
    });
  }
  function useDefaultProps(params) {
    return useDefaultProps$1(params);
  }
  function setRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
  }
  function useForkRef(...refs) {
    return reactExports.useMemo(() => {
      if (refs.every((ref) => ref == null)) {
        return null;
      }
      return (instance) => {
        refs.forEach((ref) => {
          setRef(ref, instance);
        });
      };
    }, refs);
  }
  const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  function useEventCallback(fn) {
    const ref = reactExports.useRef(fn);
    useEnhancedEffect(() => {
      ref.current = fn;
    });
    return reactExports.useRef((...args) => (
      // @ts-expect-error hide `this`
      (0, ref.current)(...args)
    )).current;
  }
  const UNINITIALIZED = {};
  function useLazyRef(init, initArg) {
    const ref = reactExports.useRef(UNINITIALIZED);
    if (ref.current === UNINITIALIZED) {
      ref.current = init(initArg);
    }
    return ref;
  }
  const EMPTY = [];
  function useOnMount(fn) {
    reactExports.useEffect(fn, EMPTY);
  }
  class Timeout {
    constructor() {
      this.currentId = null;
      this.clear = () => {
        if (this.currentId !== null) {
          clearTimeout(this.currentId);
          this.currentId = null;
        }
      };
      this.disposeEffect = () => {
        return this.clear;
      };
    }
    static create() {
      return new Timeout();
    }
    /**
     * Executes `fn` after `delay`, clearing any previously scheduled call.
     */
    start(delay, fn) {
      this.clear();
      this.currentId = setTimeout(() => {
        this.currentId = null;
        fn();
      }, delay);
    }
  }
  function useTimeout() {
    const timeout = useLazyRef(Timeout.create).current;
    useOnMount(timeout.disposeEffect);
    return timeout;
  }
  let hadKeyboardEvent = true;
  let hadFocusVisibleRecently = false;
  const hadFocusVisibleRecentlyTimeout = new Timeout();
  const inputTypesWhitelist = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    "datetime-local": true
  };
  function focusTriggersKeyboardModality(node2) {
    const {
      type,
      tagName
    } = node2;
    if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
      return true;
    }
    if (tagName === "TEXTAREA" && !node2.readOnly) {
      return true;
    }
    if (node2.isContentEditable) {
      return true;
    }
    return false;
  }
  function handleKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) {
      return;
    }
    hadKeyboardEvent = true;
  }
  function handlePointerDown() {
    hadKeyboardEvent = false;
  }
  function handleVisibilityChange() {
    if (this.visibilityState === "hidden") {
      if (hadFocusVisibleRecently) {
        hadKeyboardEvent = true;
      }
    }
  }
  function prepare(doc) {
    doc.addEventListener("keydown", handleKeyDown, true);
    doc.addEventListener("mousedown", handlePointerDown, true);
    doc.addEventListener("pointerdown", handlePointerDown, true);
    doc.addEventListener("touchstart", handlePointerDown, true);
    doc.addEventListener("visibilitychange", handleVisibilityChange, true);
  }
  function isFocusVisible(event) {
    const {
      target
    } = event;
    try {
      return target.matches(":focus-visible");
    } catch (error) {
    }
    return hadKeyboardEvent || focusTriggersKeyboardModality(target);
  }
  function useIsFocusVisible() {
    const ref = reactExports.useCallback((node2) => {
      if (node2 != null) {
        prepare(node2.ownerDocument);
      }
    }, []);
    const isFocusVisibleRef = reactExports.useRef(false);
    function handleBlurVisible() {
      if (isFocusVisibleRef.current) {
        hadFocusVisibleRecently = true;
        hadFocusVisibleRecentlyTimeout.start(100, () => {
          hadFocusVisibleRecently = false;
        });
        isFocusVisibleRef.current = false;
        return true;
      }
      return false;
    }
    function handleFocusVisible(event) {
      if (isFocusVisible(event)) {
        isFocusVisibleRef.current = true;
        return true;
      }
      return false;
    }
    return {
      isFocusVisibleRef,
      onFocus: handleFocusVisible,
      onBlur: handleBlurVisible,
      ref
    };
  }
  function _setPrototypeOf(t2, e2) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
      return t3.__proto__ = e3, t3;
    }, _setPrototypeOf(t2, e2);
  }
  function _inheritsLoose(t2, o) {
    t2.prototype = Object.create(o.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o);
  }
  function hasClass(element, className) {
    if (element.classList)
      return !!className && element.classList.contains(className);
    return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
  }
  function addClass(element, className) {
    if (element.classList)
      element.classList.add(className);
    else if (!hasClass(element, className))
      if (typeof element.className === "string")
        element.className = element.className + " " + className;
      else
        element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
  }
  function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
  }
  function removeClass$1(element, className) {
    if (element.classList) {
      element.classList.remove(className);
    } else if (typeof element.className === "string") {
      element.className = replaceClassName(element.className, className);
    } else {
      element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
    }
  }
  const config = {
    disabled: false
  };
  const TransitionGroupContext = React$1.createContext(null);
  var forceReflow = function forceReflow2(node2) {
    return node2.scrollTop;
  };
  var UNMOUNTED = "unmounted";
  var EXITED = "exited";
  var ENTERING = "entering";
  var ENTERED = "entered";
  var EXITING = "exiting";
  var Transition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(Transition2, _React$Component);
    function Transition2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context;
      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;
      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }
      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }
    Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;
      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }
      return null;
    };
    var _proto = Transition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;
      if (prevProps !== this.props) {
        var status = this.state.status;
        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }
      this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
      var timeout2 = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout2;
      if (timeout2 != null && typeof timeout2 !== "number") {
        exit = timeout2.exit;
        enter = timeout2.enter;
        appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
      }
      return {
        exit,
        enter,
        appear
      };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }
      if (nextStatus !== null) {
        this.cancelNextCallback();
        if (nextStatus === ENTERING) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
            if (node2)
              forceReflow(node2);
          }
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };
    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;
      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
      var timeouts = this.getTimeouts();
      var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
      if (!mounting && !enter || config.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }
      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function() {
        _this2.props.onEntering(maybeNode, maybeAppearing);
        _this2.onTransitionEnd(enterTimeout, function() {
          _this2.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };
    _proto.performExit = function performExit() {
      var _this3 = this;
      var exit = this.props.exit;
      var timeouts = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
      if (!exit || config.disabled) {
        this.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
        return;
      }
      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function() {
        _this3.props.onExiting(maybeNode);
        _this3.onTransitionEnd(timeouts.exit, function() {
          _this3.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;
      var active = true;
      this.nextCallback = function(event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };
      this.nextCallback.cancel = function() {
        active = false;
      };
      return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
      this.setNextCallback(handler);
      var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
      if (!node2 || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
        this.props.addEndListener(maybeNode, maybeNextCallback);
      }
      if (timeout2 != null) {
        setTimeout(this.nextCallback, timeout2);
      }
    };
    _proto.render = function render() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }
      var _this$props = this.props, children = _this$props.children;
      _this$props.in;
      _this$props.mountOnEnter;
      _this$props.unmountOnExit;
      _this$props.appear;
      _this$props.enter;
      _this$props.exit;
      _this$props.timeout;
      _this$props.addEndListener;
      _this$props.onEnter;
      _this$props.onEntering;
      _this$props.onEntered;
      _this$props.onExit;
      _this$props.onExiting;
      _this$props.onExited;
      _this$props.nodeRef;
      var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
          value: null
        }, typeof children === "function" ? children(status, childProps) : React$1.cloneElement(React$1.Children.only(children), childProps))
      );
    };
    return Transition2;
  }(React$1.Component);
  Transition.contextType = TransitionGroupContext;
  Transition.propTypes = {};
  function noop$2() {
  }
  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop$2,
    onEntering: noop$2,
    onEntered: noop$2,
    onExit: noop$2,
    onExiting: noop$2,
    onExited: noop$2
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  var _addClass = function addClass$1(node2, classes) {
    return node2 && classes && classes.split(" ").forEach(function(c2) {
      return addClass(node2, c2);
    });
  };
  var removeClass = function removeClass2(node2, classes) {
    return node2 && classes && classes.split(" ").forEach(function(c2) {
      return removeClass$1(node2, c2);
    });
  };
  var CSSTransition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(CSSTransition2, _React$Component);
    function CSSTransition2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.appliedClasses = {
        appear: {},
        enter: {},
        exit: {}
      };
      _this.onEnter = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
        _this.removeClasses(node2, "exit");
        _this.addClass(node2, appearing ? "appear" : "enter", "base");
        if (_this.props.onEnter) {
          _this.props.onEnter(maybeNode, maybeAppearing);
        }
      };
      _this.onEntering = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
        var type = appearing ? "appear" : "enter";
        _this.addClass(node2, type, "active");
        if (_this.props.onEntering) {
          _this.props.onEntering(maybeNode, maybeAppearing);
        }
      };
      _this.onEntered = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
        var type = appearing ? "appear" : "enter";
        _this.removeClasses(node2, type);
        _this.addClass(node2, type, "done");
        if (_this.props.onEntered) {
          _this.props.onEntered(maybeNode, maybeAppearing);
        }
      };
      _this.onExit = function(maybeNode) {
        var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument4[0];
        _this.removeClasses(node2, "appear");
        _this.removeClasses(node2, "enter");
        _this.addClass(node2, "exit", "base");
        if (_this.props.onExit) {
          _this.props.onExit(maybeNode);
        }
      };
      _this.onExiting = function(maybeNode) {
        var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument5[0];
        _this.addClass(node2, "exit", "active");
        if (_this.props.onExiting) {
          _this.props.onExiting(maybeNode);
        }
      };
      _this.onExited = function(maybeNode) {
        var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument6[0];
        _this.removeClasses(node2, "exit");
        _this.addClass(node2, "exit", "done");
        if (_this.props.onExited) {
          _this.props.onExited(maybeNode);
        }
      };
      _this.resolveArguments = function(maybeNode, maybeAppearing) {
        return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
      };
      _this.getClassNames = function(type) {
        var classNames = _this.props.classNames;
        var isStringClassNames = typeof classNames === "string";
        var prefix2 = isStringClassNames && classNames ? classNames + "-" : "";
        var baseClassName = isStringClassNames ? "" + prefix2 + type : classNames[type];
        var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
        var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
        return {
          baseClassName,
          activeClassName,
          doneClassName
        };
      };
      return _this;
    }
    var _proto = CSSTransition2.prototype;
    _proto.addClass = function addClass2(node2, type, phase) {
      var className = this.getClassNames(type)[phase + "ClassName"];
      var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
      if (type === "appear" && phase === "done" && doneClassName) {
        className += " " + doneClassName;
      }
      if (phase === "active") {
        if (node2)
          forceReflow(node2);
      }
      if (className) {
        this.appliedClasses[type][phase] = className;
        _addClass(node2, className);
      }
    };
    _proto.removeClasses = function removeClasses(node2, type) {
      var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
      this.appliedClasses[type] = {};
      if (baseClassName) {
        removeClass(node2, baseClassName);
      }
      if (activeClassName) {
        removeClass(node2, activeClassName);
      }
      if (doneClassName) {
        removeClass(node2, doneClassName);
      }
    };
    _proto.render = function render() {
      var _this$props = this.props;
      _this$props.classNames;
      var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
      return /* @__PURE__ */ React$1.createElement(Transition, _extends$1({}, props, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };
    return CSSTransition2;
  }(React$1.Component);
  CSSTransition.defaultProps = {
    classNames: ""
  };
  CSSTransition.propTypes = {};
  function _assertThisInitialized(e2) {
    if (void 0 === e2)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e2;
  }
  function getChildMapping(children, mapFn) {
    var mapper = function mapper2(child) {
      return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
    };
    var result = /* @__PURE__ */ Object.create(null);
    if (children)
      reactExports.Children.map(children, function(c2) {
        return c2;
      }).forEach(function(child) {
        result[child.key] = mapper(child);
      });
    return result;
  }
  function mergeChildMappings(prev2, next2) {
    prev2 = prev2 || {};
    next2 = next2 || {};
    function getValueForKey(key) {
      return key in next2 ? next2[key] : prev2[key];
    }
    var nextKeysPending = /* @__PURE__ */ Object.create(null);
    var pendingKeys = [];
    for (var prevKey in prev2) {
      if (prevKey in next2) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }
    var i;
    var childMapping = {};
    for (var nextKey in next2) {
      if (nextKeysPending[nextKey]) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    }
    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }
    return childMapping;
  }
  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }
  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function(child) {
      return reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, "appear", props),
        enter: getProp(child, "enter", props),
        exit: getProp(child, "exit", props)
      });
    });
  }
  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function(key) {
      var child = children[key];
      if (!reactExports.isValidElement(child))
        return;
      var hasPrev = key in prevChildMapping;
      var hasNext = key in nextChildMapping;
      var prevChild = prevChildMapping[key];
      var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
      if (hasNext && (!hasPrev || isLeaving)) {
        children[key] = reactExports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        children[key] = reactExports.cloneElement(child, {
          in: false
        });
      } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
        children[key] = reactExports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      }
    });
    return children;
  }
  var values = Object.values || function(obj) {
    return Object.keys(obj).map(function(k2) {
      return obj[k2];
    });
  };
  var defaultProps = {
    component: "div",
    childFactory: function childFactory(child) {
      return child;
    }
  };
  var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(TransitionGroup2, _React$Component);
    function TransitionGroup2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
      _this.state = {
        contextValue: {
          isMounting: true
        },
        handleExited,
        firstRender: true
      };
      return _this;
    }
    var _proto = TransitionGroup2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.mounted = true;
      this.setState({
        contextValue: {
          isMounting: false
        }
      });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };
    TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
      return {
        children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    };
    _proto.handleExited = function handleExited(child, node2) {
      var currentChildMapping = getChildMapping(this.props.children);
      if (child.key in currentChildMapping)
        return;
      if (child.props.onExited) {
        child.props.onExited(node2);
      }
      if (this.mounted) {
        this.setState(function(state) {
          var children = _extends$1({}, state.children);
          delete children[child.key];
          return {
            children
          };
        });
      }
    };
    _proto.render = function render() {
      var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
      var contextValue = this.state.contextValue;
      var children = values(this.state.children).map(childFactory2);
      delete props.appear;
      delete props.enter;
      delete props.exit;
      if (Component === null) {
        return /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, children);
      }
      return /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, /* @__PURE__ */ React$1.createElement(Component, props, children));
    };
    return TransitionGroup2;
  }(React$1.Component);
  TransitionGroup.propTypes = {};
  TransitionGroup.defaultProps = defaultProps;
  function isObjectEmpty$1(obj) {
    return Object.keys(obj).length === 0;
  }
  function useTheme$3(defaultTheme2 = null) {
    const contextTheme = reactExports.useContext(ThemeContext);
    return !contextTheme || isObjectEmpty$1(contextTheme) ? defaultTheme2 : contextTheme;
  }
  const systemDefaultTheme = createTheme$2();
  function useTheme$2(defaultTheme2 = systemDefaultTheme) {
    return useTheme$3(defaultTheme2);
  }
  function GlobalStyles$1({
    styles: styles2,
    themeId,
    defaultTheme: defaultTheme2 = {}
  }) {
    const upperTheme = useTheme$2(defaultTheme2);
    const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
      styles: globalStyles
    });
  }
  function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
    const result = {};
    slots.forEach((slot) => {
      result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
    });
    return result;
  }
  function shouldForwardProp(prop) {
    return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
  }
  createTheme$2();
  function getThemeProps(params) {
    const {
      theme,
      name,
      props
    } = params;
    if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
      return props;
    }
    return resolveProps(theme.components[name].defaultProps, props);
  }
  function useThemeProps$1({
    props,
    name,
    defaultTheme: defaultTheme2,
    themeId
  }) {
    let theme = useTheme$2(defaultTheme2);
    if (themeId) {
      theme = theme[themeId] || theme;
    }
    const mergedProps = getThemeProps({
      theme,
      name,
      props
    });
    return mergedProps;
  }
  function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
    const [match2, setMatch] = reactExports.useState(() => {
      if (noSsr && matchMedia) {
        return matchMedia(query).matches;
      }
      if (ssrMatchMedia) {
        return ssrMatchMedia(query).matches;
      }
      return defaultMatches;
    });
    useEnhancedEffect(() => {
      let active = true;
      if (!matchMedia) {
        return void 0;
      }
      const queryList = matchMedia(query);
      const updateMatch = () => {
        if (active) {
          setMatch(queryList.matches);
        }
      };
      updateMatch();
      queryList.addListener(updateMatch);
      return () => {
        active = false;
        queryList.removeListener(updateMatch);
      };
    }, [query, matchMedia]);
    return match2;
  }
  const maybeReactUseSyncExternalStore = reactExports.useSyncExternalStore;
  function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
    const getDefaultSnapshot = reactExports.useCallback(() => defaultMatches, [defaultMatches]);
    const getServerSnapshot = reactExports.useMemo(() => {
      if (noSsr && matchMedia) {
        return () => matchMedia(query).matches;
      }
      if (ssrMatchMedia !== null) {
        const {
          matches
        } = ssrMatchMedia(query);
        return () => matches;
      }
      return getDefaultSnapshot;
    }, [getDefaultSnapshot, query, ssrMatchMedia, noSsr, matchMedia]);
    const [getSnapshot, subscribe] = reactExports.useMemo(() => {
      if (matchMedia === null) {
        return [getDefaultSnapshot, () => () => {
        }];
      }
      const mediaQueryList = matchMedia(query);
      return [() => mediaQueryList.matches, (notify) => {
        mediaQueryList.addListener(notify);
        return () => {
          mediaQueryList.removeListener(notify);
        };
      }];
    }, [getDefaultSnapshot, matchMedia, query]);
    const match2 = maybeReactUseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    return match2;
  }
  function useMediaQuery(queryInput, options2 = {}) {
    const theme = useTheme$3();
    const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
    const {
      defaultMatches = false,
      matchMedia = supportMatchMedia ? window.matchMedia : null,
      ssrMatchMedia = null,
      noSsr = false
    } = getThemeProps({
      name: "MuiUseMediaQuery",
      props: options2,
      theme
    });
    let query = typeof queryInput === "function" ? queryInput(theme) : queryInput;
    query = query.replace(/^@media( ?)/m, "");
    const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
    const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
    return match2;
  }
  function clampWrapper(value, min2 = 0, max2 = 1) {
    return clamp$1(value, min2, max2);
  }
  function hexToRgb(color2) {
    color2 = color2.slice(1);
    const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
    let colors = color2.match(re2);
    if (colors && colors[0].length === 1) {
      colors = colors.map((n2) => n2 + n2);
    }
    return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index) => {
      return index < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
    }).join(", ")})` : "";
  }
  function decomposeColor(color2) {
    if (color2.type) {
      return color2;
    }
    if (color2.charAt(0) === "#") {
      return decomposeColor(hexToRgb(color2));
    }
    const marker = color2.indexOf("(");
    const type = color2.substring(0, marker);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
      throw new Error(formatMuiErrorMessage$1(9, color2));
    }
    let values2 = color2.substring(marker + 1, color2.length - 1);
    let colorSpace;
    if (type === "color") {
      values2 = values2.split(" ");
      colorSpace = values2.shift();
      if (values2.length === 4 && values2[3].charAt(0) === "/") {
        values2[3] = values2[3].slice(1);
      }
      if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
        throw new Error(formatMuiErrorMessage$1(10, colorSpace));
      }
    } else {
      values2 = values2.split(",");
    }
    values2 = values2.map((value) => parseFloat(value));
    return {
      type,
      values: values2,
      colorSpace
    };
  }
  function recomposeColor(color2) {
    const {
      type,
      colorSpace
    } = color2;
    let {
      values: values2
    } = color2;
    if (type.indexOf("rgb") !== -1) {
      values2 = values2.map((n2, i) => i < 3 ? parseInt(n2, 10) : n2);
    } else if (type.indexOf("hsl") !== -1) {
      values2[1] = `${values2[1]}%`;
      values2[2] = `${values2[2]}%`;
    }
    if (type.indexOf("color") !== -1) {
      values2 = `${colorSpace} ${values2.join(" ")}`;
    } else {
      values2 = `${values2.join(", ")}`;
    }
    return `${type}(${values2})`;
  }
  function alpha(color2, value) {
    color2 = decomposeColor(color2);
    value = clampWrapper(value);
    if (color2.type === "rgb" || color2.type === "hsl") {
      color2.type += "a";
    }
    if (color2.type === "color") {
      color2.values[3] = `/${value}`;
    } else {
      color2.values[3] = value;
    }
    return recomposeColor(color2);
  }
  function createChainedFunction(...funcs) {
    return funcs.reduce((acc, func) => {
      if (func == null) {
        return acc;
      }
      return function chainedFunction(...args) {
        acc.apply(this, args);
        func.apply(this, args);
      };
    }, () => {
    });
  }
  function debounce$1(func, wait = 166) {
    let timeout;
    function debounced(...args) {
      const later = () => {
        func.apply(this, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    }
    debounced.clear = () => {
      clearTimeout(timeout);
    };
    return debounced;
  }
  function isMuiElement(element, muiNames) {
    var _muiName, _element$type;
    return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(
      // For server components `muiName` is avaialble in element.type._payload.value.muiName
      // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
      // eslint-disable-next-line no-underscore-dangle
      (_muiName = element.type.muiName) != null ? _muiName : (_element$type = element.type) == null || (_element$type = _element$type._payload) == null || (_element$type = _element$type.value) == null ? void 0 : _element$type.muiName
    ) !== -1;
  }
  function ownerDocument(node2) {
    return node2 && node2.ownerDocument || document;
  }
  function ownerWindow(node2) {
    const doc = ownerDocument(node2);
    return doc.defaultView || window;
  }
  let globalId = 0;
  function useGlobalId(idOverride) {
    const [defaultId, setDefaultId] = reactExports.useState(idOverride);
    const id2 = idOverride || defaultId;
    reactExports.useEffect(() => {
      if (defaultId == null) {
        globalId += 1;
        setDefaultId(`mui-${globalId}`);
      }
    }, [defaultId]);
    return id2;
  }
  const maybeReactUseId = React$2["useId".toString()];
  function useId(idOverride) {
    if (maybeReactUseId !== void 0) {
      const reactId = maybeReactUseId();
      return idOverride != null ? idOverride : reactId;
    }
    return useGlobalId(idOverride);
  }
  function getScrollbarSize(doc) {
    const documentWidth = doc.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }
  let cachedType;
  function detectScrollType() {
    if (cachedType) {
      return cachedType;
    }
    const dummy = document.createElement("div");
    const container = document.createElement("div");
    container.style.width = "10px";
    container.style.height = "1px";
    dummy.appendChild(container);
    dummy.dir = "rtl";
    dummy.style.fontSize = "14px";
    dummy.style.width = "4px";
    dummy.style.height = "1px";
    dummy.style.position = "absolute";
    dummy.style.top = "-1000px";
    dummy.style.overflow = "scroll";
    document.body.appendChild(dummy);
    cachedType = "reverse";
    if (dummy.scrollLeft > 0) {
      cachedType = "default";
    } else {
      dummy.scrollLeft = 1;
      if (dummy.scrollLeft === 0) {
        cachedType = "negative";
      }
    }
    document.body.removeChild(dummy);
    return cachedType;
  }
  function getNormalizedScrollLeft(element, direction) {
    const scrollLeft = element.scrollLeft;
    if (direction !== "rtl") {
      return scrollLeft;
    }
    const type = detectScrollType();
    switch (type) {
      case "negative":
        return element.scrollWidth - element.clientWidth + scrollLeft;
      case "reverse":
        return element.scrollWidth - element.clientWidth - scrollLeft;
      default:
        return scrollLeft;
    }
  }
  const visuallyHidden = {
    border: 0,
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  };
  function isHostComponent(element) {
    return typeof element === "string";
  }
  function appendOwnerState(elementType, otherProps, ownerState) {
    if (elementType === void 0 || isHostComponent(elementType)) {
      return otherProps;
    }
    return _extends$1({}, otherProps, {
      ownerState: _extends$1({}, otherProps.ownerState, ownerState)
    });
  }
  function extractEventHandlers(object, excludeKeys = []) {
    if (object === void 0) {
      return {};
    }
    const result = {};
    Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
      result[prop] = object[prop];
    });
    return result;
  }
  function omitEventHandlers(object) {
    if (object === void 0) {
      return {};
    }
    const result = {};
    Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
      result[prop] = object[prop];
    });
    return result;
  }
  function mergeSlotProps(parameters) {
    const {
      getSlotProps,
      additionalProps,
      externalSlotProps,
      externalForwardedProps,
      className
    } = parameters;
    if (!getSlotProps) {
      const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
      const mergedStyle2 = _extends$1({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
      const props2 = _extends$1({}, additionalProps, externalForwardedProps, externalSlotProps);
      if (joinedClasses2.length > 0) {
        props2.className = joinedClasses2;
      }
      if (Object.keys(mergedStyle2).length > 0) {
        props2.style = mergedStyle2;
      }
      return {
        props: props2,
        internalRef: void 0
      };
    }
    const eventHandlers = extractEventHandlers(_extends$1({}, externalForwardedProps, externalSlotProps));
    const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
    const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
    const internalSlotProps = getSlotProps(eventHandlers);
    const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle = _extends$1({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props = _extends$1({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
    if (joinedClasses.length > 0) {
      props.className = joinedClasses;
    }
    if (Object.keys(mergedStyle).length > 0) {
      props.style = mergedStyle;
    }
    return {
      props,
      internalRef: internalSlotProps.ref
    };
  }
  function resolveComponentProps(componentProps, ownerState, slotState) {
    if (typeof componentProps === "function") {
      return componentProps(ownerState, slotState);
    }
    return componentProps;
  }
  const _excluded$1q = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
  function useSlotProps(parameters) {
    var _parameters$additiona;
    const {
      elementType,
      externalSlotProps,
      ownerState,
      skipResolvingSlotProps = false
    } = parameters, rest = _objectWithoutPropertiesLoose(parameters, _excluded$1q);
    const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
    const {
      props: mergedProps,
      internalRef
    } = mergeSlotProps(_extends$1({}, rest, {
      externalSlotProps: resolvedComponentsProps
    }));
    const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
    const props = appendOwnerState(elementType, _extends$1({}, mergedProps, {
      ref
    }), ownerState);
    return props;
  }
  const RtlContext = /* @__PURE__ */ reactExports.createContext();
  const useRtl = () => {
    const value = reactExports.useContext(RtlContext);
    return value != null ? value : false;
  };
  function Ripple(props) {
    const {
      className,
      classes,
      pulsate = false,
      rippleX,
      rippleY,
      rippleSize,
      in: inProp,
      onExited,
      timeout
    } = props;
    const [leaving, setLeaving] = reactExports.useState(false);
    const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
    const rippleStyles = {
      width: rippleSize,
      height: rippleSize,
      top: -(rippleSize / 2) + rippleY,
      left: -(rippleSize / 2) + rippleX
    };
    const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
    if (!inProp && !leaving) {
      setLeaving(true);
    }
    reactExports.useEffect(() => {
      if (!inProp && onExited != null) {
        const timeoutId = setTimeout(onExited, timeout);
        return () => {
          clearTimeout(timeoutId);
        };
      }
      return void 0;
    }, [onExited, inProp, timeout]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: rippleClassName,
      style: rippleStyles,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: childClassName
      })
    });
  }
  const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
  const _excluded$1p = ["center", "classes", "className"];
  let _ = (t2) => t2, _t, _t2, _t3, _t4;
  const DURATION = 550;
  const DELAY_RIPPLE = 80;
  const enterKeyframe = keyframes(_t || (_t = _`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
  const exitKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
  const pulsateKeyframe = keyframes(_t3 || (_t3 = _`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
  const TouchRippleRoot = styled("span", {
    name: "MuiTouchRipple",
    slot: "Root"
  })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
  });
  const TouchRippleRipple = styled(Ripple, {
    name: "MuiTouchRipple",
    slot: "Ripple"
  })(_t4 || (_t4 = _`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses.rippleVisible, enterKeyframe, DURATION, ({
    theme
  }) => theme.transitions.easing.easeInOut, touchRippleClasses.ripplePulsate, ({
    theme
  }) => theme.transitions.duration.shorter, touchRippleClasses.child, touchRippleClasses.childLeaving, exitKeyframe, DURATION, ({
    theme
  }) => theme.transitions.easing.easeInOut, touchRippleClasses.childPulsate, pulsateKeyframe, ({
    theme
  }) => theme.transitions.easing.easeInOut);
  const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTouchRipple"
    });
    const {
      center: centerProp = false,
      classes = {},
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1p);
    const [ripples, setRipples] = reactExports.useState([]);
    const nextKey = reactExports.useRef(0);
    const rippleCallback = reactExports.useRef(null);
    reactExports.useEffect(() => {
      if (rippleCallback.current) {
        rippleCallback.current();
        rippleCallback.current = null;
      }
    }, [ripples]);
    const ignoringMouseDown = reactExports.useRef(false);
    const startTimer = useTimeout();
    const startTimerCommit = reactExports.useRef(null);
    const container = reactExports.useRef(null);
    const startCommit = reactExports.useCallback((params) => {
      const {
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      } = params;
      setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
        classes: {
          ripple: clsx(classes.ripple, touchRippleClasses.ripple),
          rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
          ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
          child: clsx(classes.child, touchRippleClasses.child),
          childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
          childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
        },
        timeout: DURATION,
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize
      }, nextKey.current)]);
      nextKey.current += 1;
      rippleCallback.current = cb2;
    }, [classes]);
    const start2 = reactExports.useCallback((event = {}, options2 = {}, cb2 = () => {
    }) => {
      const {
        pulsate: pulsate2 = false,
        center = centerProp || options2.pulsate,
        fakeElement = false
        // For test purposes
      } = options2;
      if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
        ignoringMouseDown.current = false;
        return;
      }
      if ((event == null ? void 0 : event.type) === "touchstart") {
        ignoringMouseDown.current = true;
      }
      const element = fakeElement ? null : container.current;
      const rect = element ? element.getBoundingClientRect() : {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      };
      let rippleX;
      let rippleY;
      let rippleSize;
      if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
        rippleX = Math.round(rect.width / 2);
        rippleY = Math.round(rect.height / 2);
      } else {
        const {
          clientX,
          clientY
        } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
        rippleX = Math.round(clientX - rect.left);
        rippleY = Math.round(clientY - rect.top);
      }
      if (center) {
        rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
        if (rippleSize % 2 === 0) {
          rippleSize += 1;
        }
      } else {
        const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
        const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
        rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
      }
      if (event != null && event.touches) {
        if (startTimerCommit.current === null) {
          startTimerCommit.current = () => {
            startCommit({
              pulsate: pulsate2,
              rippleX,
              rippleY,
              rippleSize,
              cb: cb2
            });
          };
          startTimer.start(DELAY_RIPPLE, () => {
            if (startTimerCommit.current) {
              startTimerCommit.current();
              startTimerCommit.current = null;
            }
          });
        }
      } else {
        startCommit({
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize,
          cb: cb2
        });
      }
    }, [centerProp, startCommit, startTimer]);
    const pulsate = reactExports.useCallback(() => {
      start2({}, {
        pulsate: true
      });
    }, [start2]);
    const stop = reactExports.useCallback((event, cb2) => {
      startTimer.clear();
      if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
        startTimerCommit.current();
        startTimerCommit.current = null;
        startTimer.start(0, () => {
          stop(event, cb2);
        });
        return;
      }
      startTimerCommit.current = null;
      setRipples((oldRipples) => {
        if (oldRipples.length > 0) {
          return oldRipples.slice(1);
        }
        return oldRipples;
      });
      rippleCallback.current = cb2;
    }, [startTimer]);
    reactExports.useImperativeHandle(ref, () => ({
      pulsate,
      start: start2,
      stop
    }), [pulsate, start2, stop]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends$1({
      className: clsx(touchRippleClasses.root, classes.root, className),
      ref: container
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup, {
        component: null,
        exit: true,
        children: ripples
      })
    }));
  });
  function getButtonBaseUtilityClass(slot) {
    return generateUtilityClass("MuiButtonBase", slot);
  }
  const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
  const _excluded$1o = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
  const useUtilityClasses$16 = (ownerState) => {
    const {
      disabled,
      focusVisible,
      focusVisibleClassName,
      classes
    } = ownerState;
    const slots = {
      root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
    };
    const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
    if (focusVisible && focusVisibleClassName) {
      composedClasses.root += ` ${focusVisibleClassName}`;
    }
    return composedClasses;
  };
  const ButtonBaseRoot = styled("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    textDecoration: "none",
    // So we take precedent over the style of a native <a /> element.
    color: "inherit",
    "&::-moz-focus-inner": {
      borderStyle: "none"
      // Remove Firefox dotted outline.
    },
    [`&.${buttonBaseClasses.disabled}`]: {
      pointerEvents: "none",
      // Disable link interactions
      cursor: "default"
    },
    "@media print": {
      colorAdjust: "exact"
    }
  });
  const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiButtonBase"
    });
    const {
      action,
      centerRipple = false,
      children,
      className,
      component = "button",
      disabled = false,
      disableRipple = false,
      disableTouchRipple = false,
      focusRipple = false,
      LinkComponent = "a",
      onBlur,
      onClick,
      onContextMenu,
      onDragLeave,
      onFocus,
      onFocusVisible,
      onKeyDown,
      onKeyUp,
      onMouseDown,
      onMouseLeave,
      onMouseUp,
      onTouchEnd,
      onTouchMove,
      onTouchStart,
      tabIndex = 0,
      TouchRippleProps,
      touchRippleRef,
      type
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1o);
    const buttonRef = reactExports.useRef(null);
    const rippleRef = reactExports.useRef(null);
    const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
    const {
      isFocusVisibleRef,
      onFocus: handleFocusVisible,
      onBlur: handleBlurVisible,
      ref: focusVisibleRef
    } = useIsFocusVisible();
    const [focusVisible, setFocusVisible] = reactExports.useState(false);
    if (disabled && focusVisible) {
      setFocusVisible(false);
    }
    reactExports.useImperativeHandle(action, () => ({
      focusVisible: () => {
        setFocusVisible(true);
        buttonRef.current.focus();
      }
    }), []);
    const [mountedState, setMountedState] = reactExports.useState(false);
    reactExports.useEffect(() => {
      setMountedState(true);
    }, []);
    const enableTouchRipple = mountedState && !disableRipple && !disabled;
    reactExports.useEffect(() => {
      if (focusVisible && focusRipple && !disableRipple && mountedState) {
        rippleRef.current.pulsate();
      }
    }, [disableRipple, focusRipple, focusVisible, mountedState]);
    function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
      return useEventCallback((event) => {
        if (eventCallback) {
          eventCallback(event);
        }
        const ignore = skipRippleAction;
        if (!ignore && rippleRef.current) {
          rippleRef.current[rippleAction](event);
        }
        return true;
      });
    }
    const handleMouseDown = useRippleHandler("start", onMouseDown);
    const handleContextMenu = useRippleHandler("stop", onContextMenu);
    const handleDragLeave = useRippleHandler("stop", onDragLeave);
    const handleMouseUp = useRippleHandler("stop", onMouseUp);
    const handleMouseLeave = useRippleHandler("stop", (event) => {
      if (focusVisible) {
        event.preventDefault();
      }
      if (onMouseLeave) {
        onMouseLeave(event);
      }
    });
    const handleTouchStart = useRippleHandler("start", onTouchStart);
    const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
    const handleTouchMove = useRippleHandler("stop", onTouchMove);
    const handleBlur = useRippleHandler("stop", (event) => {
      handleBlurVisible(event);
      if (isFocusVisibleRef.current === false) {
        setFocusVisible(false);
      }
      if (onBlur) {
        onBlur(event);
      }
    }, false);
    const handleFocus = useEventCallback((event) => {
      if (!buttonRef.current) {
        buttonRef.current = event.currentTarget;
      }
      handleFocusVisible(event);
      if (isFocusVisibleRef.current === true) {
        setFocusVisible(true);
        if (onFocusVisible) {
          onFocusVisible(event);
        }
      }
      if (onFocus) {
        onFocus(event);
      }
    });
    const isNonNativeButton = () => {
      const button = buttonRef.current;
      return component && component !== "button" && !(button.tagName === "A" && button.href);
    };
    const keydownRef = reactExports.useRef(false);
    const handleKeyDown2 = useEventCallback((event) => {
      if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
        keydownRef.current = true;
        rippleRef.current.stop(event, () => {
          rippleRef.current.start(event);
        });
      }
      if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
        event.preventDefault();
      }
      if (onKeyDown) {
        onKeyDown(event);
      }
      if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
        event.preventDefault();
        if (onClick) {
          onClick(event);
        }
      }
    });
    const handleKeyUp = useEventCallback((event) => {
      if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
        keydownRef.current = false;
        rippleRef.current.stop(event, () => {
          rippleRef.current.pulsate(event);
        });
      }
      if (onKeyUp) {
        onKeyUp(event);
      }
      if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
        onClick(event);
      }
    });
    let ComponentProp = component;
    if (ComponentProp === "button" && (other.href || other.to)) {
      ComponentProp = LinkComponent;
    }
    const buttonProps = {};
    if (ComponentProp === "button") {
      buttonProps.type = type === void 0 ? "button" : type;
      buttonProps.disabled = disabled;
    } else {
      if (!other.href && !other.to) {
        buttonProps.role = "button";
      }
      if (disabled) {
        buttonProps["aria-disabled"] = disabled;
      }
    }
    const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
    const ownerState = _extends$1({}, props, {
      centerRipple,
      component,
      disabled,
      disableRipple,
      disableTouchRipple,
      focusRipple,
      tabIndex,
      focusVisible
    });
    const classes = useUtilityClasses$16(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$1({
      as: ComponentProp,
      className: clsx(classes.root, className),
      ownerState,
      onBlur: handleBlur,
      onClick,
      onContextMenu: handleContextMenu,
      onFocus: handleFocus,
      onKeyDown: handleKeyDown2,
      onKeyUp: handleKeyUp,
      onMouseDown: handleMouseDown,
      onMouseLeave: handleMouseLeave,
      onMouseUp: handleMouseUp,
      onDragLeave: handleDragLeave,
      onTouchEnd: handleTouchEnd,
      onTouchMove: handleTouchMove,
      onTouchStart: handleTouchStart,
      ref: handleRef,
      tabIndex: disabled ? -1 : tabIndex,
      type
    }, buttonProps, other, {
      children: [children, enableTouchRipple ? (
        /* TouchRipple is only needed client-side, x2 boost on the server. */
        /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple, _extends$1({
          ref: handleRippleRef,
          center: centerRipple
        }, TouchRippleProps))
      ) : null]
    }));
  });
  function getSwitchBaseUtilityClass(slot) {
    return generateUtilityClass("PrivateSwitchBase", slot);
  }
  generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
  const _excluded$1n = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"];
  const useUtilityClasses$15 = (ownerState) => {
    const {
      classes,
      checked,
      disabled,
      edge
    } = ownerState;
    const slots = {
      root: ["root", checked && "checked", disabled && "disabled", edge && `edge${capitalize$1(edge)}`],
      input: ["input"]
    };
    return composeClasses(slots, getSwitchBaseUtilityClass, classes);
  };
  const SwitchBaseRoot = styled(ButtonBase)(({
    ownerState
  }) => _extends$1({
    padding: 9,
    borderRadius: "50%"
  }, ownerState.edge === "start" && {
    marginLeft: ownerState.size === "small" ? -3 : -12
  }, ownerState.edge === "end" && {
    marginRight: ownerState.size === "small" ? -3 : -12
  }));
  const SwitchBaseInput = styled("input", {
    shouldForwardProp: rootShouldForwardProp
  })({
    cursor: "inherit",
    position: "absolute",
    opacity: 0,
    width: "100%",
    height: "100%",
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1
  });
  const SwitchBase = /* @__PURE__ */ reactExports.forwardRef(function SwitchBase2(props, ref) {
    const {
      autoFocus,
      checked: checkedProp,
      checkedIcon,
      className,
      defaultChecked,
      disabled: disabledProp,
      disableFocusRipple = false,
      edge = false,
      icon,
      id: id2,
      inputProps,
      inputRef,
      name,
      onBlur,
      onChange,
      onFocus,
      readOnly,
      required = false,
      tabIndex,
      type,
      value
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1n);
    const [checked, setCheckedState] = useControlled({
      controlled: checkedProp,
      default: Boolean(defaultChecked),
      name: "SwitchBase",
      state: "checked"
    });
    const muiFormControl = useFormControl();
    const handleFocus = (event) => {
      if (onFocus) {
        onFocus(event);
      }
      if (muiFormControl && muiFormControl.onFocus) {
        muiFormControl.onFocus(event);
      }
    };
    const handleBlur = (event) => {
      if (onBlur) {
        onBlur(event);
      }
      if (muiFormControl && muiFormControl.onBlur) {
        muiFormControl.onBlur(event);
      }
    };
    const handleInputChange = (event) => {
      if (event.nativeEvent.defaultPrevented) {
        return;
      }
      const newChecked = event.target.checked;
      setCheckedState(newChecked);
      if (onChange) {
        onChange(event, newChecked);
      }
    };
    let disabled = disabledProp;
    if (muiFormControl) {
      if (typeof disabled === "undefined") {
        disabled = muiFormControl.disabled;
      }
    }
    const hasLabelFor = type === "checkbox" || type === "radio";
    const ownerState = _extends$1({}, props, {
      checked,
      disabled,
      disableFocusRipple,
      edge
    });
    const classes = useUtilityClasses$15(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchBaseRoot, _extends$1({
      component: "span",
      className: clsx(classes.root, className),
      centerRipple: true,
      focusRipple: !disableFocusRipple,
      disabled,
      tabIndex: null,
      role: void 0,
      onFocus: handleFocus,
      onBlur: handleBlur,
      ownerState,
      ref
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchBaseInput, _extends$1({
        autoFocus,
        checked: checkedProp,
        defaultChecked,
        className: classes.input,
        disabled,
        id: hasLabelFor ? id2 : void 0,
        name,
        onChange: handleInputChange,
        readOnly,
        ref: inputRef,
        required,
        ownerState,
        tabIndex,
        type
      }, type === "checkbox" && value === void 0 ? {} : {
        value
      }, inputProps)), checked ? checkedIcon : icon]
    }));
  });
  function useThemeProps({
    props,
    name
  }) {
    return useThemeProps$1({
      props,
      name,
      defaultTheme,
      themeId: THEME_ID
    });
  }
  function getSwitchUtilityClass(slot) {
    return generateUtilityClass("MuiSwitch", slot);
  }
  const switchClasses = generateUtilityClasses("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"]);
  const _excluded$1m = ["className", "color", "edge", "size", "sx"];
  const useUtilityClasses$14 = (ownerState) => {
    const {
      classes,
      edge,
      size,
      color: color2,
      checked,
      disabled
    } = ownerState;
    const slots = {
      root: ["root", edge && `edge${capitalize$1(edge)}`, `size${capitalize$1(size)}`],
      switchBase: ["switchBase", `color${capitalize$1(color2)}`, checked && "checked", disabled && "disabled"],
      thumb: ["thumb"],
      track: ["track"],
      input: ["input"]
    };
    const composedClasses = composeClasses(slots, getSwitchUtilityClass, classes);
    return _extends$1({}, classes, composedClasses);
  };
  const SwitchRoot = styled("span", {
    name: "MuiSwitch",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.edge && styles2[`edge${capitalize$1(ownerState.edge)}`], styles2[`size${capitalize$1(ownerState.size)}`]];
    }
  })({
    display: "inline-flex",
    width: 34 + 12 * 2,
    height: 14 + 12 * 2,
    overflow: "hidden",
    padding: 12,
    boxSizing: "border-box",
    position: "relative",
    flexShrink: 0,
    zIndex: 0,
    // Reset the stacking context.
    verticalAlign: "middle",
    // For correct alignment with the text.
    "@media print": {
      colorAdjust: "exact"
    },
    variants: [{
      props: {
        edge: "start"
      },
      style: {
        marginLeft: -8
      }
    }, {
      props: {
        edge: "end"
      },
      style: {
        marginRight: -8
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        width: 40,
        height: 24,
        padding: 7,
        [`& .${switchClasses.thumb}`]: {
          width: 16,
          height: 16
        },
        [`& .${switchClasses.switchBase}`]: {
          padding: 4,
          [`&.${switchClasses.checked}`]: {
            transform: "translateX(16px)"
          }
        }
      }
    }]
  });
  const SwitchSwitchBase = styled(SwitchBase, {
    name: "MuiSwitch",
    slot: "SwitchBase",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.switchBase, {
        [`& .${switchClasses.input}`]: styles2.input
      }, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`]];
    }
  })(({
    theme
  }) => ({
    position: "absolute",
    top: 0,
    left: 0,
    zIndex: 1,
    // Render above the focus ripple.
    color: theme.vars ? theme.vars.palette.Switch.defaultColor : `${theme.palette.mode === "light" ? theme.palette.common.white : theme.palette.grey[300]}`,
    transition: theme.transitions.create(["left", "transform"], {
      duration: theme.transitions.duration.shortest
    }),
    [`&.${switchClasses.checked}`]: {
      transform: "translateX(20px)"
    },
    [`&.${switchClasses.disabled}`]: {
      color: theme.vars ? theme.vars.palette.Switch.defaultDisabledColor : `${theme.palette.mode === "light" ? theme.palette.grey[100] : theme.palette.grey[600]}`
    },
    [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
      opacity: 0.5
    },
    [`&.${switchClasses.disabled} + .${switchClasses.track}`]: {
      opacity: theme.vars ? theme.vars.opacity.switchTrackDisabled : `${theme.palette.mode === "light" ? 0.12 : 0.2}`
    },
    [`& .${switchClasses.input}`]: {
      left: "-100%",
      width: "300%"
    }
  }), ({
    theme
  }) => ({
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette.action.active, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    variants: [...Object.entries(theme.palette).filter(([, value]) => value.main && value.light).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        [`&.${switchClasses.checked}`]: {
          color: (theme.vars || theme).palette[color2].main,
          "&:hover": {
            backgroundColor: theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette[color2].main, theme.palette.action.hoverOpacity),
            "@media (hover: none)": {
              backgroundColor: "transparent"
            }
          },
          [`&.${switchClasses.disabled}`]: {
            color: theme.vars ? theme.vars.palette.Switch[`${color2}DisabledColor`] : `${theme.palette.mode === "light" ? lighten_1(theme.palette[color2].main, 0.62) : darken_1(theme.palette[color2].main, 0.55)}`
          }
        },
        [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
          backgroundColor: (theme.vars || theme).palette[color2].main
        }
      }
    }))]
  }));
  const SwitchTrack = styled("span", {
    name: "MuiSwitch",
    slot: "Track",
    overridesResolver: (props, styles2) => styles2.track
  })(({
    theme
  }) => ({
    height: "100%",
    width: "100%",
    borderRadius: 14 / 2,
    zIndex: -1,
    transition: theme.transitions.create(["opacity", "background-color"], {
      duration: theme.transitions.duration.shortest
    }),
    backgroundColor: theme.vars ? theme.vars.palette.common.onBackground : `${theme.palette.mode === "light" ? theme.palette.common.black : theme.palette.common.white}`,
    opacity: theme.vars ? theme.vars.opacity.switchTrack : `${theme.palette.mode === "light" ? 0.38 : 0.3}`
  }));
  const SwitchThumb = styled("span", {
    name: "MuiSwitch",
    slot: "Thumb",
    overridesResolver: (props, styles2) => styles2.thumb
  })(({
    theme
  }) => ({
    boxShadow: (theme.vars || theme).shadows[1],
    backgroundColor: "currentColor",
    width: 20,
    height: 20,
    borderRadius: "50%"
  }));
  const Switch = /* @__PURE__ */ reactExports.forwardRef(function Switch2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiSwitch"
    });
    const {
      className,
      color: color2 = "primary",
      edge = false,
      size = "medium",
      sx
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1m);
    const ownerState = _extends$1({}, props, {
      color: color2,
      edge,
      size
    });
    const classes = useUtilityClasses$14(ownerState);
    const icon = /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumb, {
      className: classes.thumb,
      ownerState
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchRoot, {
      className: clsx(classes.root, className),
      sx,
      ownerState,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchSwitchBase, _extends$1({
        type: "checkbox",
        icon,
        checkedIcon: icon,
        ref,
        ownerState
      }, other, {
        classes: _extends$1({}, classes, {
          root: classes.switchBase
        })
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchTrack, {
        className: classes.track,
        ownerState
      })]
    });
  });
  function useTheme$1() {
    const theme = useTheme$2(defaultTheme);
    return theme[THEME_ID] || theme;
  }
  const getOverlayAlpha = (elevation) => {
    let alphaValue;
    if (elevation < 1) {
      alphaValue = 5.11916 * elevation ** 2;
    } else {
      alphaValue = 4.5 * Math.log(elevation + 1) + 2;
    }
    return (alphaValue / 100).toFixed(2);
  };
  function getDividerUtilityClass(slot) {
    return generateUtilityClass("MuiDivider", slot);
  }
  const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
  const _excluded$1l = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"];
  const useUtilityClasses$13 = (ownerState) => {
    const {
      absolute,
      children,
      classes,
      flexItem,
      light: light2,
      orientation,
      textAlign,
      variant
    } = ownerState;
    const slots = {
      root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign === "right" && orientation !== "vertical" && "textAlignRight", textAlign === "left" && orientation !== "vertical" && "textAlignLeft"],
      wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
    };
    return composeClasses(slots, getDividerUtilityClass, classes);
  };
  const DividerRoot = styled("div", {
    name: "MuiDivider",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
    }
  })(({
    theme,
    ownerState
  }) => _extends$1({
    margin: 0,
    // Reset browser default style.
    flexShrink: 0,
    borderWidth: 0,
    borderStyle: "solid",
    borderColor: (theme.vars || theme).palette.divider,
    borderBottomWidth: "thin"
  }, ownerState.absolute && {
    position: "absolute",
    bottom: 0,
    left: 0,
    width: "100%"
  }, ownerState.light && {
    borderColor: theme.vars ? `rgba(${theme.vars.palette.dividerChannel} / 0.08)` : alpha_1(theme.palette.divider, 0.08)
  }, ownerState.variant === "inset" && {
    marginLeft: 72
  }, ownerState.variant === "middle" && ownerState.orientation === "horizontal" && {
    marginLeft: theme.spacing(2),
    marginRight: theme.spacing(2)
  }, ownerState.variant === "middle" && ownerState.orientation === "vertical" && {
    marginTop: theme.spacing(1),
    marginBottom: theme.spacing(1)
  }, ownerState.orientation === "vertical" && {
    height: "100%",
    borderBottomWidth: 0,
    borderRightWidth: "thin"
  }, ownerState.flexItem && {
    alignSelf: "stretch",
    height: "auto"
  }), ({
    ownerState
  }) => _extends$1({}, ownerState.children && {
    display: "flex",
    whiteSpace: "nowrap",
    textAlign: "center",
    border: 0,
    borderTopStyle: "solid",
    borderLeftStyle: "solid",
    "&::before, &::after": {
      content: '""',
      alignSelf: "center"
    }
  }), ({
    theme,
    ownerState
  }) => _extends$1({}, ownerState.children && ownerState.orientation !== "vertical" && {
    "&::before, &::after": {
      width: "100%",
      borderTop: `thin solid ${(theme.vars || theme).palette.divider}`,
      borderTopStyle: "inherit"
    }
  }), ({
    theme,
    ownerState
  }) => _extends$1({}, ownerState.children && ownerState.orientation === "vertical" && {
    flexDirection: "column",
    "&::before, &::after": {
      height: "100%",
      borderLeft: `thin solid ${(theme.vars || theme).palette.divider}`,
      borderLeftStyle: "inherit"
    }
  }), ({
    ownerState
  }) => _extends$1({}, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && {
    "&::before": {
      width: "90%"
    },
    "&::after": {
      width: "10%"
    }
  }, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && {
    "&::before": {
      width: "10%"
    },
    "&::after": {
      width: "90%"
    }
  }));
  const DividerWrapper = styled("span", {
    name: "MuiDivider",
    slot: "Wrapper",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
    }
  })(({
    theme,
    ownerState
  }) => _extends$1({
    display: "inline-block",
    paddingLeft: `calc(${theme.spacing(1)} * 1.2)`,
    paddingRight: `calc(${theme.spacing(1)} * 1.2)`
  }, ownerState.orientation === "vertical" && {
    paddingTop: `calc(${theme.spacing(1)} * 1.2)`,
    paddingBottom: `calc(${theme.spacing(1)} * 1.2)`
  }));
  const Divider = /* @__PURE__ */ reactExports.forwardRef(function Divider2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiDivider"
    });
    const {
      absolute = false,
      children,
      className,
      component = children ? "div" : "hr",
      flexItem = false,
      light: light2 = false,
      orientation = "horizontal",
      role = component !== "hr" ? "separator" : void 0,
      textAlign = "center",
      variant = "fullWidth"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1l);
    const ownerState = _extends$1({}, props, {
      absolute,
      component,
      flexItem,
      light: light2,
      orientation,
      role,
      textAlign,
      variant
    });
    const classes = useUtilityClasses$13(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DividerRoot, _extends$1({
      as: component,
      className: clsx(classes.root, className),
      role,
      ref,
      ownerState
    }, other, {
      children: children ? /* @__PURE__ */ jsxRuntimeExports.jsx(DividerWrapper, {
        className: classes.wrapper,
        ownerState,
        children
      }) : null
    }));
  });
  Divider.muiSkipListHighlight = true;
  const areViewsEqual = (views, expectedViews) => {
    if (views.length !== expectedViews.length) {
      return false;
    }
    return expectedViews.every((expectedView) => views.includes(expectedView));
  };
  const applyDefaultViewProps = ({
    openTo,
    defaultOpenTo,
    views,
    defaultViews
  }) => {
    const viewsWithDefault = views ?? defaultViews;
    let openToWithDefault;
    if (openTo != null) {
      openToWithDefault = openTo;
    } else if (viewsWithDefault.includes(defaultOpenTo)) {
      openToWithDefault = defaultOpenTo;
    } else if (viewsWithDefault.length > 0) {
      openToWithDefault = viewsWithDefault[0];
    } else {
      throw new Error("MUI X: The `views` prop must contain at least one view.");
    }
    return {
      views: viewsWithDefault,
      openTo: openToWithDefault
    };
  };
  const mergeDateAndTime = (utils2, dateParam, timeParam) => {
    let mergedDate = dateParam;
    mergedDate = utils2.setHours(mergedDate, utils2.getHours(timeParam));
    mergedDate = utils2.setMinutes(mergedDate, utils2.getMinutes(timeParam));
    mergedDate = utils2.setSeconds(mergedDate, utils2.getSeconds(timeParam));
    mergedDate = utils2.setMilliseconds(mergedDate, utils2.getMilliseconds(timeParam));
    return mergedDate;
  };
  const findClosestEnabledDate = ({
    date,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    isDateDisabled,
    utils: utils2,
    timezone
  }) => {
    const today = mergeDateAndTime(utils2, utils2.date(void 0, timezone), date);
    if (disablePast && utils2.isBefore(minDate, today)) {
      minDate = today;
    }
    if (disableFuture && utils2.isAfter(maxDate, today)) {
      maxDate = today;
    }
    let forward = date;
    let backward = date;
    if (utils2.isBefore(date, minDate)) {
      forward = minDate;
      backward = null;
    }
    if (utils2.isAfter(date, maxDate)) {
      if (backward) {
        backward = maxDate;
      }
      forward = null;
    }
    while (forward || backward) {
      if (forward && utils2.isAfter(forward, maxDate)) {
        forward = null;
      }
      if (backward && utils2.isBefore(backward, minDate)) {
        backward = null;
      }
      if (forward) {
        if (!isDateDisabled(forward)) {
          return forward;
        }
        forward = utils2.addDays(forward, 1);
      }
      if (backward) {
        if (!isDateDisabled(backward)) {
          return backward;
        }
        backward = utils2.addDays(backward, -1);
      }
    }
    return null;
  };
  const replaceInvalidDateByNull = (utils2, value) => value == null || !utils2.isValid(value) ? null : value;
  const applyDefaultDate = (utils2, value, defaultValue) => {
    if (value == null || !utils2.isValid(value)) {
      return defaultValue;
    }
    return value;
  };
  const areDatesEqual = (utils2, a, b2) => {
    if (!utils2.isValid(a) && a != null && !utils2.isValid(b2) && b2 != null) {
      return true;
    }
    return utils2.isEqual(a, b2);
  };
  const getMonthsInYear = (utils2, year) => {
    const firstMonth = utils2.startOfYear(year);
    const months = [firstMonth];
    while (months.length < 12) {
      const prevMonth = months[months.length - 1];
      months.push(utils2.addMonths(prevMonth, 1));
    }
    return months;
  };
  const getTodayDate = (utils2, timezone, valueType) => valueType === "date" ? utils2.startOfDay(utils2.date(void 0, timezone)) : utils2.date(void 0, timezone);
  const formatMeridiem = (utils2, meridiem) => {
    const date = utils2.setHours(utils2.date(), meridiem === "am" ? 2 : 14);
    return utils2.format(date, "meridiem");
  };
  const dateViews = ["year", "month", "day"];
  const isDatePickerView = (view) => dateViews.includes(view);
  const resolveDateFormat = (utils2, {
    format,
    views
  }, isInToolbar) => {
    if (format != null) {
      return format;
    }
    const formats = utils2.formats;
    if (areViewsEqual(views, ["year"])) {
      return formats.year;
    }
    if (areViewsEqual(views, ["month"])) {
      return formats.month;
    }
    if (areViewsEqual(views, ["day"])) {
      return formats.dayOfMonth;
    }
    if (areViewsEqual(views, ["month", "year"])) {
      return `${formats.month} ${formats.year}`;
    }
    if (areViewsEqual(views, ["day", "month"])) {
      return `${formats.month} ${formats.dayOfMonth}`;
    }
    return formats.keyboardDate;
  };
  const getWeekdays = (utils2, date) => {
    const start2 = utils2.startOfWeek(date);
    return [0, 1, 2, 3, 4, 5, 6].map((diff) => utils2.addDays(start2, diff));
  };
  const timeViews = ["hours", "minutes", "seconds"];
  const isTimeView = (view) => timeViews.includes(view);
  const isInternalTimeView = (view) => timeViews.includes(view) || view === "meridiem";
  const getMeridiem = (date, utils2) => {
    if (!date) {
      return null;
    }
    return utils2.getHours(date) >= 12 ? "pm" : "am";
  };
  const convertValueToMeridiem = (value, meridiem, ampm) => {
    if (ampm) {
      const currentMeridiem = value >= 12 ? "pm" : "am";
      if (currentMeridiem !== meridiem) {
        return meridiem === "am" ? value - 12 : value + 12;
      }
    }
    return value;
  };
  const convertToMeridiem = (time, meridiem, ampm, utils2) => {
    const newHoursAmount = convertValueToMeridiem(utils2.getHours(time), meridiem, ampm);
    return utils2.setHours(time, newHoursAmount);
  };
  const getSecondsInDay = (date, utils2) => {
    return utils2.getHours(date) * 3600 + utils2.getMinutes(date) * 60 + utils2.getSeconds(date);
  };
  const createIsAfterIgnoreDatePart = (disableIgnoringDatePartForTimeValidation, utils2) => (dateLeft, dateRight) => {
    if (disableIgnoringDatePartForTimeValidation) {
      return utils2.isAfter(dateLeft, dateRight);
    }
    return getSecondsInDay(dateLeft, utils2) > getSecondsInDay(dateRight, utils2);
  };
  const resolveTimeFormat = (utils2, {
    format,
    views,
    ampm
  }) => {
    if (format != null) {
      return format;
    }
    const formats = utils2.formats;
    if (areViewsEqual(views, ["hours"])) {
      return ampm ? `${formats.hours12h} ${formats.meridiem}` : formats.hours24h;
    }
    if (areViewsEqual(views, ["minutes"])) {
      return formats.minutes;
    }
    if (areViewsEqual(views, ["seconds"])) {
      return formats.seconds;
    }
    if (areViewsEqual(views, ["minutes", "seconds"])) {
      return `${formats.minutes}:${formats.seconds}`;
    }
    if (areViewsEqual(views, ["hours", "minutes", "seconds"])) {
      return ampm ? `${formats.hours12h}:${formats.minutes}:${formats.seconds} ${formats.meridiem}` : `${formats.hours24h}:${formats.minutes}:${formats.seconds}`;
    }
    return ampm ? `${formats.hours12h}:${formats.minutes} ${formats.meridiem}` : `${formats.hours24h}:${formats.minutes}`;
  };
  const SECTION_TYPE_GRANULARITY = {
    year: 1,
    month: 2,
    day: 3,
    hours: 4,
    minutes: 5,
    seconds: 6,
    milliseconds: 7
  };
  const getSectionTypeGranularity = (sections) => Math.max(...sections.map((section) => SECTION_TYPE_GRANULARITY[section.type] ?? 1));
  const roundDate = (utils2, granularity, date) => {
    if (granularity === SECTION_TYPE_GRANULARITY.year) {
      return utils2.startOfYear(date);
    }
    if (granularity === SECTION_TYPE_GRANULARITY.month) {
      return utils2.startOfMonth(date);
    }
    if (granularity === SECTION_TYPE_GRANULARITY.day) {
      return utils2.startOfDay(date);
    }
    let roundedDate = date;
    if (granularity < SECTION_TYPE_GRANULARITY.minutes) {
      roundedDate = utils2.setMinutes(roundedDate, 0);
    }
    if (granularity < SECTION_TYPE_GRANULARITY.seconds) {
      roundedDate = utils2.setSeconds(roundedDate, 0);
    }
    if (granularity < SECTION_TYPE_GRANULARITY.milliseconds) {
      roundedDate = utils2.setMilliseconds(roundedDate, 0);
    }
    return roundedDate;
  };
  const getDefaultReferenceDate = ({
    props,
    utils: utils2,
    granularity,
    timezone,
    getTodayDate: inGetTodayDate
  }) => {
    let referenceDate = inGetTodayDate ? inGetTodayDate() : roundDate(utils2, granularity, getTodayDate(utils2, timezone));
    if (props.minDate != null && utils2.isAfterDay(props.minDate, referenceDate)) {
      referenceDate = roundDate(utils2, granularity, props.minDate);
    }
    if (props.maxDate != null && utils2.isBeforeDay(props.maxDate, referenceDate)) {
      referenceDate = roundDate(utils2, granularity, props.maxDate);
    }
    const isAfter = createIsAfterIgnoreDatePart(props.disableIgnoringDatePartForTimeValidation ?? false, utils2);
    if (props.minTime != null && isAfter(props.minTime, referenceDate)) {
      referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.minTime : mergeDateAndTime(utils2, referenceDate, props.minTime));
    }
    if (props.maxTime != null && isAfter(referenceDate, props.maxTime)) {
      referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.maxTime : mergeDateAndTime(utils2, referenceDate, props.maxTime));
    }
    return referenceDate;
  };
  const getDateSectionConfigFromFormatToken = (utils2, formatToken) => {
    const config2 = utils2.formatTokenMap[formatToken];
    if (config2 == null) {
      throw new Error([`MUI X: The token "${formatToken}" is not supported by the Date and Time Pickers.`, "Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));
    }
    if (typeof config2 === "string") {
      return {
        type: config2,
        contentType: config2 === "meridiem" ? "letter" : "digit",
        maxLength: void 0
      };
    }
    return {
      type: config2.sectionType,
      contentType: config2.contentType,
      maxLength: config2.maxLength
    };
  };
  const getDeltaFromKeyCode = (keyCode) => {
    switch (keyCode) {
      case "ArrowUp":
        return 1;
      case "ArrowDown":
        return -1;
      case "PageUp":
        return 5;
      case "PageDown":
        return -5;
      default:
        return 0;
    }
  };
  const getDaysInWeekStr = (utils2, timezone, format) => {
    const elements = [];
    const now = utils2.date(void 0, timezone);
    const startDate = utils2.startOfWeek(now);
    const endDate = utils2.endOfWeek(now);
    let current = startDate;
    while (utils2.isBefore(current, endDate)) {
      elements.push(current);
      current = utils2.addDays(current, 1);
    }
    return elements.map((weekDay) => utils2.formatByString(weekDay, format));
  };
  const getLetterEditingOptions = (utils2, timezone, sectionType, format) => {
    switch (sectionType) {
      case "month": {
        return getMonthsInYear(utils2, utils2.date(void 0, timezone)).map((month) => utils2.formatByString(month, format));
      }
      case "weekDay": {
        return getDaysInWeekStr(utils2, timezone, format);
      }
      case "meridiem": {
        const now = utils2.date(void 0, timezone);
        return [utils2.startOfDay(now), utils2.endOfDay(now)].map((date) => utils2.formatByString(date, format));
      }
      default: {
        return [];
      }
    }
  };
  const FORMAT_SECONDS_NO_LEADING_ZEROS = "s";
  const NON_LOCALIZED_DIGITS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
  const getLocalizedDigits = (utils2) => {
    const today = utils2.date(void 0);
    const formattedZero = utils2.formatByString(utils2.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS);
    if (formattedZero === "0") {
      return NON_LOCALIZED_DIGITS;
    }
    return Array.from({
      length: 10
    }).map((_2, index) => utils2.formatByString(utils2.setSeconds(today, index), FORMAT_SECONDS_NO_LEADING_ZEROS));
  };
  const removeLocalizedDigits = (valueStr, localizedDigits) => {
    if (localizedDigits[0] === "0") {
      return valueStr;
    }
    const digits = [];
    let currentFormattedDigit = "";
    for (let i = 0; i < valueStr.length; i += 1) {
      currentFormattedDigit += valueStr[i];
      const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);
      if (matchingDigitIndex > -1) {
        digits.push(matchingDigitIndex.toString());
        currentFormattedDigit = "";
      }
    }
    return digits.join("");
  };
  const applyLocalizedDigits = (valueStr, localizedDigits) => {
    if (localizedDigits[0] === "0") {
      return valueStr;
    }
    return valueStr.split("").map((char2) => localizedDigits[Number(char2)]).join("");
  };
  const isStringNumber = (valueStr, localizedDigits) => {
    const nonLocalizedValueStr = removeLocalizedDigits(valueStr, localizedDigits);
    return nonLocalizedValueStr !== " " && !Number.isNaN(Number(nonLocalizedValueStr));
  };
  const cleanLeadingZeros = (valueStr, size) => {
    let cleanValueStr = valueStr;
    cleanValueStr = Number(cleanValueStr).toString();
    while (cleanValueStr.length < size) {
      cleanValueStr = `0${cleanValueStr}`;
    }
    return cleanValueStr;
  };
  const cleanDigitSectionValue = (utils2, value, sectionBoundaries, localizedDigits, section) => {
    if (section.type === "day" && section.contentType === "digit-with-letter") {
      const date = utils2.setDate(sectionBoundaries.longestMonth, value);
      return utils2.formatByString(date, section.format);
    }
    let valueStr = value.toString();
    if (section.hasLeadingZerosInInput) {
      valueStr = cleanLeadingZeros(valueStr, section.maxLength);
    }
    return applyLocalizedDigits(valueStr, localizedDigits);
  };
  const adjustSectionValue = (utils2, timezone, section, keyCode, sectionsValueBoundaries, localizedDigits, activeDate, stepsAttributes) => {
    const delta = getDeltaFromKeyCode(keyCode);
    const isStart = keyCode === "Home";
    const isEnd = keyCode === "End";
    const shouldSetAbsolute = section.value === "" || isStart || isEnd;
    const adjustDigitSection = () => {
      const sectionBoundaries = sectionsValueBoundaries[section.type]({
        currentDate: activeDate,
        format: section.format,
        contentType: section.contentType
      });
      const getCleanValue = (value) => cleanDigitSectionValue(utils2, value, sectionBoundaries, localizedDigits, section);
      const step = section.type === "minutes" && (stepsAttributes == null ? void 0 : stepsAttributes.minutesStep) ? stepsAttributes.minutesStep : 1;
      const currentSectionValue = parseInt(removeLocalizedDigits(section.value, localizedDigits), 10);
      let newSectionValueNumber = currentSectionValue + delta * step;
      if (shouldSetAbsolute) {
        if (section.type === "year" && !isEnd && !isStart) {
          return utils2.formatByString(utils2.date(void 0, timezone), section.format);
        }
        if (delta > 0 || isStart) {
          newSectionValueNumber = sectionBoundaries.minimum;
        } else {
          newSectionValueNumber = sectionBoundaries.maximum;
        }
      }
      if (newSectionValueNumber % step !== 0) {
        if (delta < 0 || isStart) {
          newSectionValueNumber += step - (step + newSectionValueNumber) % step;
        }
        if (delta > 0 || isEnd) {
          newSectionValueNumber -= newSectionValueNumber % step;
        }
      }
      if (newSectionValueNumber > sectionBoundaries.maximum) {
        return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
      }
      if (newSectionValueNumber < sectionBoundaries.minimum) {
        return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
      }
      return getCleanValue(newSectionValueNumber);
    };
    const adjustLetterSection = () => {
      const options2 = getLetterEditingOptions(utils2, timezone, section.type, section.format);
      if (options2.length === 0) {
        return section.value;
      }
      if (shouldSetAbsolute) {
        if (delta > 0 || isStart) {
          return options2[0];
        }
        return options2[options2.length - 1];
      }
      const currentOptionIndex = options2.indexOf(section.value);
      const newOptionIndex = (currentOptionIndex + delta) % options2.length;
      const clampedIndex = (newOptionIndex + options2.length) % options2.length;
      return options2[clampedIndex];
    };
    if (section.contentType === "digit" || section.contentType === "digit-with-letter") {
      return adjustDigitSection();
    }
    return adjustLetterSection();
  };
  const getSectionVisibleValue = (section, target, localizedDigits) => {
    let value = section.value || section.placeholder;
    const hasLeadingZeros = target === "non-input" ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;
    if (target === "non-input" && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {
      value = Number(removeLocalizedDigits(value, localizedDigits)).toString();
    }
    const shouldAddInvisibleSpace = ["input-rtl", "input-ltr"].includes(target) && section.contentType === "digit" && !hasLeadingZeros && value.length === 1;
    if (shouldAddInvisibleSpace) {
      value = `${value}‎`;
    }
    if (target === "input-rtl") {
      value = `⁨${value}⁩`;
    }
    return value;
  };
  const changeSectionValueFormat = (utils2, valueStr, currentFormat, newFormat) => {
    return utils2.formatByString(utils2.parse(valueStr, currentFormat), newFormat);
  };
  const isFourDigitYearFormat = (utils2, timezone, format) => utils2.formatByString(utils2.date(void 0, timezone), format).length === 4;
  const doesSectionFormatHaveLeadingZeros = (utils2, timezone, contentType, sectionType, format) => {
    if (contentType !== "digit") {
      return false;
    }
    const now = utils2.date(void 0, timezone);
    switch (sectionType) {
      case "year": {
        if (isFourDigitYearFormat(utils2, timezone, format)) {
          const formatted0001 = utils2.formatByString(utils2.setYear(now, 1), format);
          return formatted0001 === "0001";
        }
        const formatted2001 = utils2.formatByString(utils2.setYear(now, 2001), format);
        return formatted2001 === "01";
      }
      case "month": {
        return utils2.formatByString(utils2.startOfYear(now), format).length > 1;
      }
      case "day": {
        return utils2.formatByString(utils2.startOfMonth(now), format).length > 1;
      }
      case "weekDay": {
        return utils2.formatByString(utils2.startOfWeek(now), format).length > 1;
      }
      case "hours": {
        return utils2.formatByString(utils2.setHours(now, 1), format).length > 1;
      }
      case "minutes": {
        return utils2.formatByString(utils2.setMinutes(now, 1), format).length > 1;
      }
      case "seconds": {
        return utils2.formatByString(utils2.setSeconds(now, 1), format).length > 1;
      }
      default: {
        throw new Error("Invalid section type");
      }
    }
  };
  const getDateFromDateSections = (utils2, sections, localizedDigits) => {
    const shouldSkipWeekDays = sections.some((section) => section.type === "day");
    const sectionFormats = [];
    const sectionValues = [];
    for (let i = 0; i < sections.length; i += 1) {
      const section = sections[i];
      const shouldSkip = shouldSkipWeekDays && section.type === "weekDay";
      if (!shouldSkip) {
        sectionFormats.push(section.format);
        sectionValues.push(getSectionVisibleValue(section, "non-input", localizedDigits));
      }
    }
    const formatWithoutSeparator = sectionFormats.join(" ");
    const dateWithoutSeparatorStr = sectionValues.join(" ");
    return utils2.parse(dateWithoutSeparatorStr, formatWithoutSeparator);
  };
  const createDateStrForV7HiddenInputFromSections = (sections) => sections.map((section) => {
    return `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`;
  }).join("");
  const createDateStrForV6InputFromSections = (sections, localizedDigits, isRtl) => {
    const formattedSections = sections.map((section) => {
      const dateValue = getSectionVisibleValue(section, isRtl ? "input-rtl" : "input-ltr", localizedDigits);
      return `${section.startSeparator}${dateValue}${section.endSeparator}`;
    });
    const dateStr = formattedSections.join("");
    if (!isRtl) {
      return dateStr;
    }
    return `⁦${dateStr}⁩`;
  };
  const getSectionsBoundaries = (utils2, localizedDigits, timezone) => {
    const today = utils2.date(void 0, timezone);
    const endOfYear = utils2.endOfYear(today);
    const endOfDay = utils2.endOfDay(today);
    const {
      maxDaysInMonth,
      longestMonth
    } = getMonthsInYear(utils2, today).reduce((acc, month) => {
      const daysInMonth = utils2.getDaysInMonth(month);
      if (daysInMonth > acc.maxDaysInMonth) {
        return {
          maxDaysInMonth: daysInMonth,
          longestMonth: month
        };
      }
      return acc;
    }, {
      maxDaysInMonth: 0,
      longestMonth: null
    });
    return {
      year: ({
        format
      }) => ({
        minimum: 0,
        maximum: isFourDigitYearFormat(utils2, timezone, format) ? 9999 : 99
      }),
      month: () => ({
        minimum: 1,
        // Assumption: All years have the same amount of months
        maximum: utils2.getMonth(endOfYear) + 1
      }),
      day: ({
        currentDate
      }) => ({
        minimum: 1,
        maximum: currentDate != null && utils2.isValid(currentDate) ? utils2.getDaysInMonth(currentDate) : maxDaysInMonth,
        longestMonth
      }),
      weekDay: ({
        format,
        contentType
      }) => {
        if (contentType === "digit") {
          const daysInWeek = getDaysInWeekStr(utils2, timezone, format).map(Number);
          return {
            minimum: Math.min(...daysInWeek),
            maximum: Math.max(...daysInWeek)
          };
        }
        return {
          minimum: 1,
          maximum: 7
        };
      },
      hours: ({
        format
      }) => {
        const lastHourInDay = utils2.getHours(endOfDay);
        const hasMeridiem = removeLocalizedDigits(utils2.formatByString(utils2.endOfDay(today), format), localizedDigits) !== lastHourInDay.toString();
        if (hasMeridiem) {
          return {
            minimum: 1,
            maximum: Number(removeLocalizedDigits(utils2.formatByString(utils2.startOfDay(today), format), localizedDigits))
          };
        }
        return {
          minimum: 0,
          maximum: lastHourInDay
        };
      },
      minutes: () => ({
        minimum: 0,
        // Assumption: All years have the same amount of minutes
        maximum: utils2.getMinutes(endOfDay)
      }),
      seconds: () => ({
        minimum: 0,
        // Assumption: All years have the same amount of seconds
        maximum: utils2.getSeconds(endOfDay)
      }),
      meridiem: () => ({
        minimum: 0,
        maximum: 1
      }),
      empty: () => ({
        minimum: 0,
        maximum: 0
      })
    };
  };
  const transferDateSectionValue = (utils2, timezone, section, dateToTransferFrom, dateToTransferTo) => {
    switch (section.type) {
      case "year": {
        return utils2.setYear(dateToTransferTo, utils2.getYear(dateToTransferFrom));
      }
      case "month": {
        return utils2.setMonth(dateToTransferTo, utils2.getMonth(dateToTransferFrom));
      }
      case "weekDay": {
        const formattedDaysInWeek = getDaysInWeekStr(utils2, timezone, section.format);
        const dayInWeekStrOfActiveDate = utils2.formatByString(dateToTransferFrom, section.format);
        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);
        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);
        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;
        return utils2.addDays(dateToTransferFrom, diff);
      }
      case "day": {
        return utils2.setDate(dateToTransferTo, utils2.getDate(dateToTransferFrom));
      }
      case "meridiem": {
        const isAM = utils2.getHours(dateToTransferFrom) < 12;
        const mergedDateHours = utils2.getHours(dateToTransferTo);
        if (isAM && mergedDateHours >= 12) {
          return utils2.addHours(dateToTransferTo, -12);
        }
        if (!isAM && mergedDateHours < 12) {
          return utils2.addHours(dateToTransferTo, 12);
        }
        return dateToTransferTo;
      }
      case "hours": {
        return utils2.setHours(dateToTransferTo, utils2.getHours(dateToTransferFrom));
      }
      case "minutes": {
        return utils2.setMinutes(dateToTransferTo, utils2.getMinutes(dateToTransferFrom));
      }
      case "seconds": {
        return utils2.setSeconds(dateToTransferTo, utils2.getSeconds(dateToTransferFrom));
      }
      default: {
        return dateToTransferTo;
      }
    }
  };
  const reliableSectionModificationOrder = {
    year: 1,
    month: 2,
    day: 3,
    weekDay: 4,
    hours: 5,
    minutes: 6,
    seconds: 7,
    meridiem: 8,
    empty: 9
  };
  const mergeDateIntoReferenceDate = (utils2, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => (
    // cloning sections before sort to avoid mutating it
    [...sections].sort((a, b2) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b2.type]).reduce((mergedDate, section) => {
      if (!shouldLimitToEditedSections || section.modified) {
        return transferDateSectionValue(utils2, timezone, section, dateToTransferFrom, mergedDate);
      }
      return mergedDate;
    }, referenceDate)
  );
  const isAndroid = () => navigator.userAgent.toLowerCase().includes("android");
  const getSectionOrder = (sections, shouldApplyRTL) => {
    const neighbors = {};
    if (!shouldApplyRTL) {
      sections.forEach((_2, index) => {
        const leftIndex = index === 0 ? null : index - 1;
        const rightIndex = index === sections.length - 1 ? null : index + 1;
        neighbors[index] = {
          leftIndex,
          rightIndex
        };
      });
      return {
        neighbors,
        startIndex: 0,
        endIndex: sections.length - 1
      };
    }
    const rtl2ltr = {};
    const ltr2rtl = {};
    let groupedSectionsStart = 0;
    let groupedSectionsEnd = 0;
    let RTLIndex = sections.length - 1;
    while (RTLIndex >= 0) {
      groupedSectionsEnd = sections.findIndex(
        // eslint-disable-next-line @typescript-eslint/no-loop-func
        (section, index) => {
          var _a;
          return index >= groupedSectionsStart && ((_a = section.endSeparator) == null ? void 0 : _a.includes(" ")) && // Special case where the spaces were not there in the initial input
          section.endSeparator !== " / ";
        }
      );
      if (groupedSectionsEnd === -1) {
        groupedSectionsEnd = sections.length - 1;
      }
      for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {
        ltr2rtl[i] = RTLIndex;
        rtl2ltr[RTLIndex] = i;
        RTLIndex -= 1;
      }
      groupedSectionsStart = groupedSectionsEnd + 1;
    }
    sections.forEach((_2, index) => {
      const rtlIndex = ltr2rtl[index];
      const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];
      const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];
      neighbors[index] = {
        leftIndex,
        rightIndex
      };
    });
    return {
      neighbors,
      startIndex: rtl2ltr[0],
      endIndex: rtl2ltr[sections.length - 1]
    };
  };
  const parseSelectedSections = (selectedSections, sections) => {
    if (selectedSections == null) {
      return null;
    }
    if (selectedSections === "all") {
      return "all";
    }
    if (typeof selectedSections === "string") {
      return sections.findIndex((section) => section.type === selectedSections);
    }
    return selectedSections;
  };
  const getSectionValueText = (section, utils2) => {
    if (!section.value) {
      return void 0;
    }
    switch (section.type) {
      case "month": {
        if (section.contentType === "digit") {
          return utils2.format(utils2.setMonth(utils2.date(), Number(section.value) - 1), "month");
        }
        const parsedDate = utils2.parse(section.value, section.format);
        return parsedDate ? utils2.format(parsedDate, "month") : void 0;
      }
      case "day":
        return section.contentType === "digit" ? utils2.format(utils2.setDate(utils2.startOfYear(utils2.date()), Number(section.value)), "dayOfMonthFull") : section.value;
      case "weekDay":
        return void 0;
      default:
        return void 0;
    }
  };
  const getSectionValueNow = (section, utils2) => {
    if (!section.value) {
      return void 0;
    }
    switch (section.type) {
      case "weekDay": {
        if (section.contentType === "letter") {
          return void 0;
        }
        return Number(section.value);
      }
      case "meridiem": {
        const parsedDate = utils2.parse(`01:00 ${section.value}`, `${utils2.formats.hours12h}:${utils2.formats.minutes} ${section.format}`);
        if (parsedDate) {
          return utils2.getHours(parsedDate) >= 12 ? 1 : 0;
        }
        return void 0;
      }
      case "day":
        return section.contentType === "digit-with-letter" ? parseInt(section.value, 10) : Number(section.value);
      case "month": {
        if (section.contentType === "digit") {
          return Number(section.value);
        }
        const parsedDate = utils2.parse(section.value, section.format);
        return parsedDate ? utils2.getMonth(parsedDate) + 1 : void 0;
      }
      default:
        return section.contentType !== "letter" ? Number(section.value) : void 0;
    }
  };
  const _excluded$1k = ["value", "referenceDate"];
  const singleItemValueManager = {
    emptyValue: null,
    getTodayValue: getTodayDate,
    getInitialReferenceValue: (_ref) => {
      let {
        value,
        referenceDate
      } = _ref, params = _objectWithoutPropertiesLoose(_ref, _excluded$1k);
      if (value != null && params.utils.isValid(value)) {
        return value;
      }
      if (referenceDate != null) {
        return referenceDate;
      }
      return getDefaultReferenceDate(params);
    },
    cleanValue: replaceInvalidDateByNull,
    areValuesEqual: areDatesEqual,
    isSameError: (a, b2) => a === b2,
    hasError: (error) => error != null,
    defaultErrorState: null,
    getTimezone: (utils2, value) => value == null || !utils2.isValid(value) ? null : utils2.getTimezone(value),
    setTimezone: (utils2, timezone, value) => value == null ? null : utils2.setTimezone(value, timezone)
  };
  const singleItemFieldValueManager = {
    updateReferenceValue: (utils2, value, prevReferenceValue) => value == null || !utils2.isValid(value) ? prevReferenceValue : value,
    getSectionsFromValue: (utils2, date, prevSections, getSectionsFromDate) => {
      const shouldReUsePrevDateSections = !utils2.isValid(date) && !!prevSections;
      if (shouldReUsePrevDateSections) {
        return prevSections;
      }
      return getSectionsFromDate(date);
    },
    getV7HiddenInputValueFromSections: createDateStrForV7HiddenInputFromSections,
    getV6InputValueFromSections: createDateStrForV6InputFromSections,
    getActiveDateManager: (utils2, state) => ({
      date: state.value,
      referenceDate: state.referenceValue,
      getSections: (sections) => sections,
      getNewValuesFromNewActiveDate: (newActiveDate) => ({
        value: newActiveDate,
        referenceValue: newActiveDate == null || !utils2.isValid(newActiveDate) ? state.referenceValue : newActiveDate
      })
    }),
    parseValueStr: (valueStr, referenceValue, parseDate) => parseDate(valueStr.trim(), referenceValue)
  };
  const _excluded$1j = ["onChange", "maxRows", "minRows", "style", "value"];
  function getStyleValue(value) {
    return parseInt(value, 10) || 0;
  }
  const styles$3 = {
    shadow: {
      // Visibility needed to hide the extra text area on iPads
      visibility: "hidden",
      // Remove from the content flow
      position: "absolute",
      // Ignore the scrollbar width
      overflow: "hidden",
      height: 0,
      top: 0,
      left: 0,
      // Create a new layer, increase the isolation of the computed values
      transform: "translateZ(0)"
    }
  };
  function isEmpty$1(obj) {
    return obj === void 0 || obj === null || Object.keys(obj).length === 0 || obj.outerHeightStyle === 0 && !obj.overflowing;
  }
  const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, forwardedRef) {
    const {
      onChange,
      maxRows,
      minRows = 1,
      style: style2,
      value
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1j);
    const {
      current: isControlled
    } = reactExports.useRef(value != null);
    const inputRef = reactExports.useRef(null);
    const handleRef = useForkRef(forwardedRef, inputRef);
    const heightRef = reactExports.useRef(null);
    const shadowRef = reactExports.useRef(null);
    const calculateTextareaStyles = reactExports.useCallback(() => {
      const input = inputRef.current;
      const containerWindow = ownerWindow(input);
      const computedStyle = containerWindow.getComputedStyle(input);
      if (computedStyle.width === "0px") {
        return {
          outerHeightStyle: 0,
          overflowing: false
        };
      }
      const inputShallow = shadowRef.current;
      inputShallow.style.width = computedStyle.width;
      inputShallow.value = input.value || props.placeholder || "x";
      if (inputShallow.value.slice(-1) === "\n") {
        inputShallow.value += " ";
      }
      const boxSizing2 = computedStyle.boxSizing;
      const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
      const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
      const innerHeight = inputShallow.scrollHeight;
      inputShallow.value = "x";
      const singleRowHeight = inputShallow.scrollHeight;
      let outerHeight = innerHeight;
      if (minRows) {
        outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
      }
      if (maxRows) {
        outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
      }
      outerHeight = Math.max(outerHeight, singleRowHeight);
      const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
      const overflowing = Math.abs(outerHeight - innerHeight) <= 1;
      return {
        outerHeightStyle,
        overflowing
      };
    }, [maxRows, minRows, props.placeholder]);
    const syncHeight = reactExports.useCallback(() => {
      const textareaStyles = calculateTextareaStyles();
      if (isEmpty$1(textareaStyles)) {
        return;
      }
      const outerHeightStyle = textareaStyles.outerHeightStyle;
      const input = inputRef.current;
      if (heightRef.current !== outerHeightStyle) {
        heightRef.current = outerHeightStyle;
        input.style.height = `${outerHeightStyle}px`;
      }
      input.style.overflow = textareaStyles.overflowing ? "hidden" : "";
    }, [calculateTextareaStyles]);
    useEnhancedEffect(() => {
      const handleResize = () => {
        syncHeight();
      };
      let rAF;
      const debounceHandleResize = debounce$1(handleResize);
      const input = inputRef.current;
      const containerWindow = ownerWindow(input);
      containerWindow.addEventListener("resize", debounceHandleResize);
      let resizeObserver;
      if (typeof ResizeObserver !== "undefined") {
        resizeObserver = new ResizeObserver(handleResize);
        resizeObserver.observe(input);
      }
      return () => {
        debounceHandleResize.clear();
        cancelAnimationFrame(rAF);
        containerWindow.removeEventListener("resize", debounceHandleResize);
        if (resizeObserver) {
          resizeObserver.disconnect();
        }
      };
    }, [calculateTextareaStyles, syncHeight]);
    useEnhancedEffect(() => {
      syncHeight();
    });
    const handleChange = (event) => {
      if (!isControlled) {
        syncHeight();
      }
      if (onChange) {
        onChange(event);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", _extends$1({
        value,
        onChange: handleChange,
        ref: handleRef,
        rows: minRows,
        style: style2
      }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
        "aria-hidden": true,
        className: props.className,
        readOnly: true,
        ref: shadowRef,
        tabIndex: -1,
        style: _extends$1({}, styles$3.shadow, style2, {
          paddingTop: 0,
          paddingBottom: 0
        })
      })]
    });
  });
  function formControlState({
    props,
    states,
    muiFormControl
  }) {
    return states.reduce((acc, state) => {
      acc[state] = props[state];
      if (muiFormControl) {
        if (typeof props[state] === "undefined") {
          acc[state] = muiFormControl[state];
        }
      }
      return acc;
    }, {});
  }
  function GlobalStyles(props) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, _extends$1({}, props, {
      defaultTheme,
      themeId: THEME_ID
    }));
  }
  function hasValue(value) {
    return value != null && !(Array.isArray(value) && value.length === 0);
  }
  function isFilled(obj, SSR = false) {
    return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
  }
  function isAdornedStart(obj) {
    return obj.startAdornment;
  }
  function getInputBaseUtilityClass(slot) {
    return generateUtilityClass("MuiInputBase", slot);
  }
  const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
  const _excluded$1i = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
  const rootOverridesResolver = (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
  };
  const inputOverridesResolver = (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
  };
  const useUtilityClasses$12 = (ownerState) => {
    const {
      classes,
      color: color2,
      disabled,
      error,
      endAdornment,
      focused,
      formControl,
      fullWidth,
      hiddenLabel,
      multiline,
      readOnly,
      size,
      startAdornment,
      type
    } = ownerState;
    const slots = {
      root: ["root", `color${capitalize$1(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size && size !== "medium" && `size${capitalize$1(size)}`, multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
      input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
    };
    return composeClasses(slots, getInputBaseUtilityClass, classes);
  };
  const InputBaseRoot = styled("div", {
    name: "MuiInputBase",
    slot: "Root",
    overridesResolver: rootOverridesResolver
  })(({
    theme,
    ownerState
  }) => _extends$1({}, theme.typography.body1, {
    color: (theme.vars || theme).palette.text.primary,
    lineHeight: "1.4375em",
    // 23px
    boxSizing: "border-box",
    // Prevent padding issue with fullWidth.
    position: "relative",
    cursor: "text",
    display: "inline-flex",
    alignItems: "center",
    [`&.${inputBaseClasses.disabled}`]: {
      color: (theme.vars || theme).palette.text.disabled,
      cursor: "default"
    }
  }, ownerState.multiline && _extends$1({
    padding: "4px 0 5px"
  }, ownerState.size === "small" && {
    paddingTop: 1
  }), ownerState.fullWidth && {
    width: "100%"
  }));
  const InputBaseComponent = styled("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: inputOverridesResolver
  })(({
    theme,
    ownerState
  }) => {
    const light2 = theme.palette.mode === "light";
    const placeholder = _extends$1({
      color: "currentColor"
    }, theme.vars ? {
      opacity: theme.vars.opacity.inputPlaceholder
    } : {
      opacity: light2 ? 0.42 : 0.5
    }, {
      transition: theme.transitions.create("opacity", {
        duration: theme.transitions.duration.shorter
      })
    });
    const placeholderHidden = {
      opacity: "0 !important"
    };
    const placeholderVisible = theme.vars ? {
      opacity: theme.vars.opacity.inputPlaceholder
    } : {
      opacity: light2 ? 0.42 : 0.5
    };
    return _extends$1({
      font: "inherit",
      letterSpacing: "inherit",
      color: "currentColor",
      padding: "4px 0 5px",
      border: 0,
      boxSizing: "content-box",
      background: "none",
      height: "1.4375em",
      // Reset 23pxthe native input line-height
      margin: 0,
      // Reset for Safari
      WebkitTapHighlightColor: "transparent",
      display: "block",
      // Make the flex item shrink with Firefox
      minWidth: 0,
      width: "100%",
      // Fix IE11 width issue
      animationName: "mui-auto-fill-cancel",
      animationDuration: "10ms",
      "&::-webkit-input-placeholder": placeholder,
      "&::-moz-placeholder": placeholder,
      // Firefox 19+
      "&:-ms-input-placeholder": placeholder,
      // IE11
      "&::-ms-input-placeholder": placeholder,
      // Edge
      "&:focus": {
        outline: 0
      },
      // Reset Firefox invalid required input style
      "&:invalid": {
        boxShadow: "none"
      },
      "&::-webkit-search-decoration": {
        // Remove the padding when type=search.
        WebkitAppearance: "none"
      },
      // Show and hide the placeholder logic
      [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
        "&::-webkit-input-placeholder": placeholderHidden,
        "&::-moz-placeholder": placeholderHidden,
        // Firefox 19+
        "&:-ms-input-placeholder": placeholderHidden,
        // IE11
        "&::-ms-input-placeholder": placeholderHidden,
        // Edge
        "&:focus::-webkit-input-placeholder": placeholderVisible,
        "&:focus::-moz-placeholder": placeholderVisible,
        // Firefox 19+
        "&:focus:-ms-input-placeholder": placeholderVisible,
        // IE11
        "&:focus::-ms-input-placeholder": placeholderVisible
        // Edge
      },
      [`&.${inputBaseClasses.disabled}`]: {
        opacity: 1,
        // Reset iOS opacity
        WebkitTextFillColor: (theme.vars || theme).palette.text.disabled
        // Fix opacity Safari bug
      },
      "&:-webkit-autofill": {
        animationDuration: "5000s",
        animationName: "mui-auto-fill"
      }
    }, ownerState.size === "small" && {
      paddingTop: 1
    }, ownerState.multiline && {
      height: "auto",
      resize: "none",
      padding: 0,
      paddingTop: 0
    }, ownerState.type === "search" && {
      // Improve type search style.
      MozAppearance: "textfield"
    });
  });
  const inputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
    styles: {
      "@keyframes mui-auto-fill": {
        from: {
          display: "block"
        }
      },
      "@keyframes mui-auto-fill-cancel": {
        from: {
          display: "block"
        }
      }
    }
  });
  const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref) {
    var _slotProps$input;
    const props = useDefaultProps({
      props: inProps,
      name: "MuiInputBase"
    });
    const {
      "aria-describedby": ariaDescribedby,
      autoComplete,
      autoFocus,
      className,
      components = {},
      componentsProps = {},
      defaultValue,
      disabled,
      disableInjectingGlobalStyles,
      endAdornment,
      fullWidth = false,
      id: id2,
      inputComponent = "input",
      inputProps: inputPropsProp = {},
      inputRef: inputRefProp,
      maxRows,
      minRows,
      multiline = false,
      name,
      onBlur,
      onChange,
      onClick,
      onFocus,
      onKeyDown,
      onKeyUp,
      placeholder,
      readOnly,
      renderSuffix,
      rows,
      slotProps = {},
      slots = {},
      startAdornment,
      type = "text",
      value: valueProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1i);
    const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
    const {
      current: isControlled
    } = reactExports.useRef(value != null);
    const inputRef = reactExports.useRef();
    const handleInputRefWarning = reactExports.useCallback((instance) => {
    }, []);
    const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
    const [focused, setFocused] = reactExports.useState(false);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
    });
    fcs.focused = muiFormControl ? muiFormControl.focused : focused;
    reactExports.useEffect(() => {
      if (!muiFormControl && disabled && focused) {
        setFocused(false);
        if (onBlur) {
          onBlur();
        }
      }
    }, [muiFormControl, disabled, focused, onBlur]);
    const onFilled = muiFormControl && muiFormControl.onFilled;
    const onEmpty = muiFormControl && muiFormControl.onEmpty;
    const checkDirty = reactExports.useCallback((obj) => {
      if (isFilled(obj)) {
        if (onFilled) {
          onFilled();
        }
      } else if (onEmpty) {
        onEmpty();
      }
    }, [onFilled, onEmpty]);
    useEnhancedEffect(() => {
      if (isControlled) {
        checkDirty({
          value
        });
      }
    }, [value, checkDirty, isControlled]);
    const handleFocus = (event) => {
      if (fcs.disabled) {
        event.stopPropagation();
        return;
      }
      if (onFocus) {
        onFocus(event);
      }
      if (inputPropsProp.onFocus) {
        inputPropsProp.onFocus(event);
      }
      if (muiFormControl && muiFormControl.onFocus) {
        muiFormControl.onFocus(event);
      } else {
        setFocused(true);
      }
    };
    const handleBlur = (event) => {
      if (onBlur) {
        onBlur(event);
      }
      if (inputPropsProp.onBlur) {
        inputPropsProp.onBlur(event);
      }
      if (muiFormControl && muiFormControl.onBlur) {
        muiFormControl.onBlur(event);
      } else {
        setFocused(false);
      }
    };
    const handleChange = (event, ...args) => {
      if (!isControlled) {
        const element = event.target || inputRef.current;
        if (element == null) {
          throw new Error(formatMuiErrorMessage$1(1));
        }
        checkDirty({
          value: element.value
        });
      }
      if (inputPropsProp.onChange) {
        inputPropsProp.onChange(event, ...args);
      }
      if (onChange) {
        onChange(event, ...args);
      }
    };
    reactExports.useEffect(() => {
      checkDirty(inputRef.current);
    }, []);
    const handleClick = (event) => {
      if (inputRef.current && event.currentTarget === event.target) {
        inputRef.current.focus();
      }
      if (onClick) {
        onClick(event);
      }
    };
    let InputComponent = inputComponent;
    let inputProps = inputPropsProp;
    if (multiline && InputComponent === "input") {
      if (rows) {
        inputProps = _extends$1({
          type: void 0,
          minRows: rows,
          maxRows: rows
        }, inputProps);
      } else {
        inputProps = _extends$1({
          type: void 0,
          maxRows,
          minRows
        }, inputProps);
      }
      InputComponent = TextareaAutosize;
    }
    const handleAutoFill = (event) => {
      checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
        value: "x"
      });
    };
    reactExports.useEffect(() => {
      if (muiFormControl) {
        muiFormControl.setAdornedStart(Boolean(startAdornment));
      }
    }, [muiFormControl, startAdornment]);
    const ownerState = _extends$1({}, props, {
      color: fcs.color || "primary",
      disabled: fcs.disabled,
      endAdornment,
      error: fcs.error,
      focused: fcs.focused,
      formControl: muiFormControl,
      fullWidth,
      hiddenLabel: fcs.hiddenLabel,
      multiline,
      size: fcs.size,
      startAdornment,
      type
    });
    const classes = useUtilityClasses$12(ownerState);
    const Root2 = slots.root || components.Root || InputBaseRoot;
    const rootProps = slotProps.root || componentsProps.root || {};
    const Input2 = slots.input || components.Input || InputBaseComponent;
    inputProps = _extends$1({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2, _extends$1({}, rootProps, !isHostComponent(Root2) && {
        ownerState: _extends$1({}, ownerState, rootProps.ownerState)
      }, {
        ref,
        onClick: handleClick
      }, other, {
        className: clsx(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
        children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
          value: null,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input2, _extends$1({
            ownerState,
            "aria-invalid": fcs.error,
            "aria-describedby": ariaDescribedby,
            autoComplete,
            autoFocus,
            defaultValue,
            disabled: fcs.disabled,
            id: id2,
            onAnimationStart: handleAutoFill,
            name,
            placeholder,
            readOnly,
            required: fcs.required,
            rows,
            value,
            onKeyDown,
            onKeyUp,
            type
          }, inputProps, !isHostComponent(Input2) && {
            as: InputComponent,
            ownerState: _extends$1({}, ownerState, inputProps.ownerState)
          }, {
            ref: handleInputRef,
            className: clsx(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
            onBlur: handleBlur,
            onChange: handleChange,
            onFocus: handleFocus
          }))
        }), endAdornment, renderSuffix ? renderSuffix(_extends$1({}, fcs, {
          startAdornment
        })) : null]
      }))]
    });
  });
  const InputBase$1 = InputBase;
  function getInputUtilityClass(slot) {
    return generateUtilityClass("MuiInput", slot);
  }
  const inputClasses = _extends$1({}, inputBaseClasses, generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
  const _excluded$1h = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
  const useUtilityClasses$11 = (ownerState) => {
    const {
      classes,
      disableUnderline
    } = ownerState;
    const slots = {
      root: ["root", !disableUnderline && "underline"],
      input: ["input"]
    };
    const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
    return _extends$1({}, classes, composedClasses);
  };
  const InputRoot = styled(InputBaseRoot, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
    }
  })(({
    theme,
    ownerState
  }) => {
    const light2 = theme.palette.mode === "light";
    let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    if (theme.vars) {
      bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
    }
    return _extends$1({
      position: "relative"
    }, ownerState.formControl && {
      "label + &": {
        marginTop: 16
      }
    }, !ownerState.disableUnderline && {
      "&::after": {
        borderBottom: `2px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
        content: '""',
        position: "absolute",
        right: 0,
        transform: "scaleX(0)",
        transition: theme.transitions.create("transform", {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      [`&.${inputClasses.focused}:after`]: {
        // translateX(0) is a workaround for Safari transform scale bug
        // See https://github.com/mui/material-ui/issues/31766
        transform: "scaleX(1) translateX(0)"
      },
      [`&.${inputClasses.error}`]: {
        "&::before, &::after": {
          borderBottomColor: (theme.vars || theme).palette.error.main
        }
      },
      "&::before": {
        borderBottom: `1px solid ${bottomLineColor}`,
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
        content: '"\\00a0"',
        position: "absolute",
        right: 0,
        transition: theme.transitions.create("border-bottom-color", {
          duration: theme.transitions.duration.shorter
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      [`&:hover:not(.${inputClasses.disabled}, .${inputClasses.error}):before`]: {
        borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          borderBottom: `1px solid ${bottomLineColor}`
        }
      },
      [`&.${inputClasses.disabled}:before`]: {
        borderBottomStyle: "dotted"
      }
    });
  });
  const InputInput = styled(InputBaseComponent, {
    name: "MuiInput",
    slot: "Input",
    overridesResolver: inputOverridesResolver
  })({});
  const Input = /* @__PURE__ */ reactExports.forwardRef(function Input2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$input;
    const props = useDefaultProps({
      props: inProps,
      name: "MuiInput"
    });
    const {
      disableUnderline,
      components = {},
      componentsProps: componentsPropsProp,
      fullWidth = false,
      inputComponent = "input",
      multiline = false,
      slotProps,
      slots = {},
      type = "text"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1h);
    const classes = useUtilityClasses$11(props);
    const ownerState = {
      disableUnderline
    };
    const inputComponentsProps = {
      root: {
        ownerState
      }
    };
    const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge$1(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
    const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
    const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
      slots: {
        root: RootSlot,
        input: InputSlot
      },
      slotProps: componentsProps,
      fullWidth,
      inputComponent,
      multiline,
      ref,
      type
    }, other, {
      classes
    }));
  });
  Input.muiName = "Input";
  function getFilledInputUtilityClass(slot) {
    return generateUtilityClass("MuiFilledInput", slot);
  }
  const filledInputClasses = _extends$1({}, inputBaseClasses, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"]));
  const _excluded$1g = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
  const useUtilityClasses$10 = (ownerState) => {
    const {
      classes,
      disableUnderline
    } = ownerState;
    const slots = {
      root: ["root", !disableUnderline && "underline"],
      input: ["input"]
    };
    const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
    return _extends$1({}, classes, composedClasses);
  };
  const FilledInputRoot = styled(InputBaseRoot, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
    }
  })(({
    theme,
    ownerState
  }) => {
    var _palette;
    const light2 = theme.palette.mode === "light";
    const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
    const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
    const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return _extends$1({
      position: "relative",
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
      borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
      borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
      transition: theme.transitions.create("background-color", {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      "&:hover": {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
        }
      },
      [`&.${filledInputClasses.focused}`]: {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
      },
      [`&.${filledInputClasses.disabled}`]: {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
      }
    }, !ownerState.disableUnderline && {
      "&::after": {
        borderBottom: `2px solid ${(_palette = (theme.vars || theme).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
        content: '""',
        position: "absolute",
        right: 0,
        transform: "scaleX(0)",
        transition: theme.transitions.create("transform", {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      [`&.${filledInputClasses.focused}:after`]: {
        // translateX(0) is a workaround for Safari transform scale bug
        // See https://github.com/mui/material-ui/issues/31766
        transform: "scaleX(1) translateX(0)"
      },
      [`&.${filledInputClasses.error}`]: {
        "&::before, &::after": {
          borderBottomColor: (theme.vars || theme).palette.error.main
        }
      },
      "&::before": {
        borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
        content: '"\\00a0"',
        position: "absolute",
        right: 0,
        transition: theme.transitions.create("border-bottom-color", {
          duration: theme.transitions.duration.shorter
        }),
        pointerEvents: "none"
        // Transparent to the hover style.
      },
      [`&:hover:not(.${filledInputClasses.disabled}, .${filledInputClasses.error}):before`]: {
        borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
      },
      [`&.${filledInputClasses.disabled}:before`]: {
        borderBottomStyle: "dotted"
      }
    }, ownerState.startAdornment && {
      paddingLeft: 12
    }, ownerState.endAdornment && {
      paddingRight: 12
    }, ownerState.multiline && _extends$1({
      padding: "25px 12px 8px"
    }, ownerState.size === "small" && {
      paddingTop: 21,
      paddingBottom: 4
    }, ownerState.hiddenLabel && {
      paddingTop: 16,
      paddingBottom: 17
    }, ownerState.hiddenLabel && ownerState.size === "small" && {
      paddingTop: 8,
      paddingBottom: 9
    }));
  });
  const FilledInputInput = styled(InputBaseComponent, {
    name: "MuiFilledInput",
    slot: "Input",
    overridesResolver: inputOverridesResolver
  })(({
    theme,
    ownerState
  }) => _extends$1({
    paddingTop: 25,
    paddingRight: 12,
    paddingBottom: 8,
    paddingLeft: 12
  }, !theme.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
      caretColor: theme.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  }, theme.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [theme.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  }, ownerState.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, ownerState.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }, ownerState.startAdornment && {
    paddingLeft: 0
  }, ownerState.endAdornment && {
    paddingRight: 0
  }, ownerState.hiddenLabel && ownerState.size === "small" && {
    paddingTop: 8,
    paddingBottom: 9
  }, ownerState.multiline && {
    paddingTop: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0
  }));
  const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$input;
    const props = useDefaultProps({
      props: inProps,
      name: "MuiFilledInput"
    });
    const {
      components = {},
      componentsProps: componentsPropsProp,
      fullWidth = false,
      // declare here to prevent spreading to DOM
      inputComponent = "input",
      multiline = false,
      slotProps,
      slots = {},
      type = "text"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1g);
    const ownerState = _extends$1({}, props, {
      fullWidth,
      inputComponent,
      multiline,
      type
    });
    const classes = useUtilityClasses$10(props);
    const filledInputComponentsProps = {
      root: {
        ownerState
      },
      input: {
        ownerState
      }
    };
    const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge$1(filledInputComponentsProps, slotProps != null ? slotProps : componentsPropsProp) : filledInputComponentsProps;
    const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
    const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
      slots: {
        root: RootSlot,
        input: InputSlot
      },
      componentsProps,
      fullWidth,
      inputComponent,
      multiline,
      ref,
      type
    }, other, {
      classes
    }));
  });
  FilledInput.muiName = "Input";
  var _span$3;
  const _excluded$1f = ["children", "classes", "className", "label", "notched"];
  const NotchedOutlineRoot$1 = styled("fieldset", {
    shouldForwardProp: rootShouldForwardProp
  })({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%"
  });
  const NotchedOutlineLegend = styled("legend", {
    shouldForwardProp: rootShouldForwardProp
  })(({
    ownerState,
    theme
  }) => _extends$1({
    float: "unset",
    // Fix conflict with bootstrap
    width: "auto",
    // Fix conflict with bootstrap
    overflow: "hidden"
  }, !ownerState.withLabel && {
    padding: 0,
    lineHeight: "11px",
    // sync with `height` in `legend` styles
    transition: theme.transitions.create("width", {
      duration: 150,
      easing: theme.transitions.easing.easeOut
    })
  }, ownerState.withLabel && _extends$1({
    display: "block",
    // Fix conflict with normalize.css and sanitize.css
    padding: 0,
    height: 11,
    // sync with `lineHeight` in `legend` styles
    fontSize: "0.75em",
    visibility: "hidden",
    maxWidth: 0.01,
    transition: theme.transitions.create("max-width", {
      duration: 50,
      easing: theme.transitions.easing.easeOut
    }),
    whiteSpace: "nowrap",
    "& > span": {
      paddingLeft: 5,
      paddingRight: 5,
      display: "inline-block",
      opacity: 0,
      visibility: "visible"
    }
  }, ownerState.notched && {
    maxWidth: "100%",
    transition: theme.transitions.create("max-width", {
      duration: 100,
      easing: theme.transitions.easing.easeOut,
      delay: 50
    })
  })));
  function NotchedOutline(props) {
    const {
      className,
      label,
      notched
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1f);
    const withLabel = label != null && label !== "";
    const ownerState = _extends$1({}, props, {
      notched,
      withLabel
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, _extends$1({
      "aria-hidden": true,
      className,
      ownerState
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
        ownerState,
        children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          children: label
        }) : (
          // notranslate needed while Google Translate will not fix zero-width space issue
          _span$3 || (_span$3 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            children: "​"
          }))
        )
      })
    }));
  }
  function getOutlinedInputUtilityClass(slot) {
    return generateUtilityClass("MuiOutlinedInput", slot);
  }
  const outlinedInputClasses = _extends$1({}, inputBaseClasses, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
  const _excluded$1e = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
  const useUtilityClasses$$ = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      notchedOutline: ["notchedOutline"],
      input: ["input"]
    };
    const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
    return _extends$1({}, classes, composedClasses);
  };
  const OutlinedInputRoot = styled(InputBaseRoot, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: rootOverridesResolver
  })(({
    theme,
    ownerState
  }) => {
    const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return _extends$1({
      position: "relative",
      borderRadius: (theme.vars || theme).shape.borderRadius,
      [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette.text.primary
      },
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
        }
      },
      [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette[ownerState.color].main,
        borderWidth: 2
      },
      [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette.error.main
      },
      [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette.action.disabled
      }
    }, ownerState.startAdornment && {
      paddingLeft: 14
    }, ownerState.endAdornment && {
      paddingRight: 14
    }, ownerState.multiline && _extends$1({
      padding: "16.5px 14px"
    }, ownerState.size === "small" && {
      padding: "8.5px 14px"
    }));
  });
  const NotchedOutlineRoot = styled(NotchedOutline, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline",
    overridesResolver: (props, styles2) => styles2.notchedOutline
  })(({
    theme
  }) => {
    const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
      borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
    };
  });
  const OutlinedInputInput = styled(InputBaseComponent, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: inputOverridesResolver
  })(({
    theme,
    ownerState
  }) => _extends$1({
    padding: "16.5px 14px"
  }, !theme.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
      caretColor: theme.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  }, theme.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [theme.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  }, ownerState.size === "small" && {
    padding: "8.5px 14px"
  }, ownerState.multiline && {
    padding: 0
  }, ownerState.startAdornment && {
    paddingLeft: 0
  }, ownerState.endAdornment && {
    paddingRight: 0
  }));
  const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
    const props = useDefaultProps({
      props: inProps,
      name: "MuiOutlinedInput"
    });
    const {
      components = {},
      fullWidth = false,
      inputComponent = "input",
      label,
      multiline = false,
      notched,
      slots = {},
      type = "text"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1e);
    const classes = useUtilityClasses$$(props);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
    });
    const ownerState = _extends$1({}, props, {
      color: fcs.color || "primary",
      disabled: fcs.disabled,
      error: fcs.error,
      focused: fcs.focused,
      formControl: muiFormControl,
      fullWidth,
      hiddenLabel: fcs.hiddenLabel,
      multiline,
      size: fcs.size,
      type
    });
    const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
    const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
      slots: {
        root: RootSlot,
        input: InputSlot
      },
      renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot, {
        ownerState,
        className: classes.notchedOutline,
        label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [label, " ", "*"]
        })) : label,
        notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
      }),
      fullWidth,
      inputComponent,
      multiline,
      ref,
      type
    }, other, {
      classes: _extends$1({}, classes, {
        notchedOutline: null
      })
    }));
  });
  OutlinedInput.muiName = "Input";
  function getFormLabelUtilityClasses(slot) {
    return generateUtilityClass("MuiFormLabel", slot);
  }
  const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
  const _excluded$1d = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];
  const useUtilityClasses$_ = (ownerState) => {
    const {
      classes,
      color: color2,
      focused,
      disabled,
      error,
      filled,
      required
    } = ownerState;
    const slots = {
      root: ["root", `color${capitalize$1(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
      asterisk: ["asterisk", error && "error"]
    };
    return composeClasses(slots, getFormLabelUtilityClasses, classes);
  };
  const FormLabelRoot = styled("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: ({
      ownerState
    }, styles2) => {
      return _extends$1({}, styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled);
    }
  })(({
    theme,
    ownerState
  }) => _extends$1({
    color: (theme.vars || theme).palette.text.secondary
  }, theme.typography.body1, {
    lineHeight: "1.4375em",
    padding: 0,
    position: "relative",
    [`&.${formLabelClasses.focused}`]: {
      color: (theme.vars || theme).palette[ownerState.color].main
    },
    [`&.${formLabelClasses.disabled}`]: {
      color: (theme.vars || theme).palette.text.disabled
    },
    [`&.${formLabelClasses.error}`]: {
      color: (theme.vars || theme).palette.error.main
    }
  }));
  const AsteriskComponent = styled("span", {
    name: "MuiFormLabel",
    slot: "Asterisk",
    overridesResolver: (props, styles2) => styles2.asterisk
  })(({
    theme
  }) => ({
    [`&.${formLabelClasses.error}`]: {
      color: (theme.vars || theme).palette.error.main
    }
  }));
  const FormLabel = /* @__PURE__ */ reactExports.forwardRef(function FormLabel2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiFormLabel"
    });
    const {
      children,
      className,
      component = "label"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1d);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["color", "required", "focused", "disabled", "error", "filled"]
    });
    const ownerState = _extends$1({}, props, {
      color: fcs.color || "primary",
      component,
      disabled: fcs.disabled,
      error: fcs.error,
      filled: fcs.filled,
      focused: fcs.focused,
      required: fcs.required
    });
    const classes = useUtilityClasses$_(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabelRoot, _extends$1({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other, {
      children: [children, fcs.required && /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
        ownerState,
        "aria-hidden": true,
        className: classes.asterisk,
        children: [" ", "*"]
      })]
    }));
  });
  function getInputLabelUtilityClasses(slot) {
    return generateUtilityClass("MuiInputLabel", slot);
  }
  generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
  const _excluded$1c = ["disableAnimation", "margin", "shrink", "variant", "className"];
  const useUtilityClasses$Z = (ownerState) => {
    const {
      classes,
      formControl,
      size,
      shrink,
      disableAnimation,
      variant,
      required
    } = ownerState;
    const slots = {
      root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size && size !== "normal" && `size${capitalize$1(size)}`, variant],
      asterisk: [required && "asterisk"]
    };
    const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
    return _extends$1({}, classes, composedClasses);
  };
  const InputLabelRoot = styled(FormLabel, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [{
        [`& .${formLabelClasses.asterisk}`]: styles2.asterisk
      }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, ownerState.focused && styles2.focused, styles2[ownerState.variant]];
    }
  })(({
    theme,
    ownerState
  }) => _extends$1({
    display: "block",
    transformOrigin: "top left",
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    maxWidth: "100%"
  }, ownerState.formControl && {
    position: "absolute",
    left: 0,
    top: 0,
    // slight alteration to spec spacing to match visual spec result
    transform: "translate(0, 20px) scale(1)"
  }, ownerState.size === "small" && {
    // Compensation for the `Input.inputSizeSmall` style.
    transform: "translate(0, 17px) scale(1)"
  }, ownerState.shrink && {
    transform: "translate(0, -1.5px) scale(0.75)",
    transformOrigin: "top left",
    maxWidth: "133%"
  }, !ownerState.disableAnimation && {
    transition: theme.transitions.create(["color", "transform", "max-width"], {
      duration: theme.transitions.duration.shorter,
      easing: theme.transitions.easing.easeOut
    })
  }, ownerState.variant === "filled" && _extends$1({
    // Chrome's autofill feature gives the input field a yellow background.
    // Since the input field is behind the label in the HTML tree,
    // the input field is drawn last and hides the label with an opaque background color.
    // zIndex: 1 will raise the label above opaque background-colors of input.
    zIndex: 1,
    pointerEvents: "none",
    transform: "translate(12px, 16px) scale(1)",
    maxWidth: "calc(100% - 24px)"
  }, ownerState.size === "small" && {
    transform: "translate(12px, 13px) scale(1)"
  }, ownerState.shrink && _extends$1({
    userSelect: "none",
    pointerEvents: "auto",
    transform: "translate(12px, 7px) scale(0.75)",
    maxWidth: "calc(133% - 24px)"
  }, ownerState.size === "small" && {
    transform: "translate(12px, 4px) scale(0.75)"
  })), ownerState.variant === "outlined" && _extends$1({
    // see comment above on filled.zIndex
    zIndex: 1,
    pointerEvents: "none",
    transform: "translate(14px, 16px) scale(1)",
    maxWidth: "calc(100% - 24px)"
  }, ownerState.size === "small" && {
    transform: "translate(14px, 9px) scale(1)"
  }, ownerState.shrink && {
    userSelect: "none",
    pointerEvents: "auto",
    // Theoretically, we should have (8+5)*2/0.75 = 34px
    // but it feels a better when it bleeds a bit on the left, so 32px.
    maxWidth: "calc(133% - 32px)",
    transform: "translate(14px, -9px) scale(0.75)"
  })));
  const InputLabel = /* @__PURE__ */ reactExports.forwardRef(function InputLabel2(inProps, ref) {
    const props = useDefaultProps({
      name: "MuiInputLabel",
      props: inProps
    });
    const {
      disableAnimation = false,
      shrink: shrinkProp,
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1c);
    const muiFormControl = useFormControl();
    let shrink = shrinkProp;
    if (typeof shrink === "undefined" && muiFormControl) {
      shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
    }
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["size", "variant", "required", "focused"]
    });
    const ownerState = _extends$1({}, props, {
      disableAnimation,
      formControl: muiFormControl,
      shrink,
      size: fcs.size,
      variant: fcs.variant,
      required: fcs.required,
      focused: fcs.focused
    });
    const classes = useUtilityClasses$Z(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelRoot, _extends$1({
      "data-shrink": shrink,
      ownerState,
      ref,
      className: clsx(classes.root, className)
    }, other, {
      classes
    }));
  });
  function getFormControlUtilityClasses(slot) {
    return generateUtilityClass("MuiFormControl", slot);
  }
  generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
  const _excluded$1b = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];
  const useUtilityClasses$Y = (ownerState) => {
    const {
      classes,
      margin: margin2,
      fullWidth
    } = ownerState;
    const slots = {
      root: ["root", margin2 !== "none" && `margin${capitalize$1(margin2)}`, fullWidth && "fullWidth"]
    };
    return composeClasses(slots, getFormControlUtilityClasses, classes);
  };
  const FormControlRoot = styled("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: ({
      ownerState
    }, styles2) => {
      return _extends$1({}, styles2.root, styles2[`margin${capitalize$1(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth);
    }
  })(({
    ownerState
  }) => _extends$1({
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    // Reset fieldset default style.
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top"
  }, ownerState.margin === "normal" && {
    marginTop: 16,
    marginBottom: 8
  }, ownerState.margin === "dense" && {
    marginTop: 8,
    marginBottom: 4
  }, ownerState.fullWidth && {
    width: "100%"
  }));
  const FormControl = /* @__PURE__ */ reactExports.forwardRef(function FormControl2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiFormControl"
    });
    const {
      children,
      className,
      color: color2 = "primary",
      component = "div",
      disabled = false,
      error = false,
      focused: visuallyFocused,
      fullWidth = false,
      hiddenLabel = false,
      margin: margin2 = "none",
      required = false,
      size = "medium",
      variant = "outlined"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1b);
    const ownerState = _extends$1({}, props, {
      color: color2,
      component,
      disabled,
      error,
      fullWidth,
      hiddenLabel,
      margin: margin2,
      required,
      size,
      variant
    });
    const classes = useUtilityClasses$Y(ownerState);
    const [adornedStart, setAdornedStart] = reactExports.useState(() => {
      let initialAdornedStart = false;
      if (children) {
        reactExports.Children.forEach(children, (child) => {
          if (!isMuiElement(child, ["Input", "Select"])) {
            return;
          }
          const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
          if (input && isAdornedStart(input.props)) {
            initialAdornedStart = true;
          }
        });
      }
      return initialAdornedStart;
    });
    const [filled, setFilled] = reactExports.useState(() => {
      let initialFilled = false;
      if (children) {
        reactExports.Children.forEach(children, (child) => {
          if (!isMuiElement(child, ["Input", "Select"])) {
            return;
          }
          if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
            initialFilled = true;
          }
        });
      }
      return initialFilled;
    });
    const [focusedState, setFocused] = reactExports.useState(false);
    if (disabled && focusedState) {
      setFocused(false);
    }
    const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
    let registerEffect;
    const childContext = reactExports.useMemo(() => {
      return {
        adornedStart,
        setAdornedStart,
        color: color2,
        disabled,
        error,
        filled,
        focused,
        fullWidth,
        hiddenLabel,
        size,
        onBlur: () => {
          setFocused(false);
        },
        onEmpty: () => {
          setFilled(false);
        },
        onFilled: () => {
          setFilled(true);
        },
        onFocus: () => {
          setFocused(true);
        },
        registerEffect,
        required,
        variant
      };
    }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size, variant]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
      value: childContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlRoot, _extends$1({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other, {
        children
      }))
    });
  });
  function getFormHelperTextUtilityClasses(slot) {
    return generateUtilityClass("MuiFormHelperText", slot);
  }
  const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
  var _span$2;
  const _excluded$1a = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"];
  const useUtilityClasses$X = (ownerState) => {
    const {
      classes,
      contained,
      size,
      disabled,
      error,
      filled,
      focused,
      required
    } = ownerState;
    const slots = {
      root: ["root", disabled && "disabled", error && "error", size && `size${capitalize$1(size)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
    };
    return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
  };
  const FormHelperTextRoot = styled("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.size && styles2[`size${capitalize$1(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
    }
  })(({
    theme,
    ownerState
  }) => _extends$1({
    color: (theme.vars || theme).palette.text.secondary
  }, theme.typography.caption, {
    textAlign: "left",
    marginTop: 3,
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    [`&.${formHelperTextClasses.disabled}`]: {
      color: (theme.vars || theme).palette.text.disabled
    },
    [`&.${formHelperTextClasses.error}`]: {
      color: (theme.vars || theme).palette.error.main
    }
  }, ownerState.size === "small" && {
    marginTop: 4
  }, ownerState.contained && {
    marginLeft: 14,
    marginRight: 14
  }));
  const FormHelperText = /* @__PURE__ */ reactExports.forwardRef(function FormHelperText2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiFormHelperText"
    });
    const {
      children,
      className,
      component = "p"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1a);
    const muiFormControl = useFormControl();
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
    });
    const ownerState = _extends$1({}, props, {
      component,
      contained: fcs.variant === "filled" || fcs.variant === "outlined",
      variant: fcs.variant,
      size: fcs.size,
      disabled: fcs.disabled,
      error: fcs.error,
      filled: fcs.filled,
      focused: fcs.focused,
      required: fcs.required
    });
    const classes = useUtilityClasses$X(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextRoot, _extends$1({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other, {
      children: children === " " ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$2 || (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      ) : children
    }));
  });
  const ListContext = /* @__PURE__ */ reactExports.createContext({});
  function getListUtilityClass(slot) {
    return generateUtilityClass("MuiList", slot);
  }
  generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
  const _excluded$19 = ["children", "className", "component", "dense", "disablePadding", "subheader"];
  const useUtilityClasses$W = (ownerState) => {
    const {
      classes,
      disablePadding,
      dense,
      subheader
    } = ownerState;
    const slots = {
      root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
    };
    return composeClasses(slots, getListUtilityClass, classes);
  };
  const ListRoot = styled("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
    }
  })(({
    ownerState
  }) => _extends$1({
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative"
  }, !ownerState.disablePadding && {
    paddingTop: 8,
    paddingBottom: 8
  }, ownerState.subheader && {
    paddingTop: 0
  }));
  const List = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiList"
    });
    const {
      children,
      className,
      component = "ul",
      dense = false,
      disablePadding = false,
      subheader
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$19);
    const context = reactExports.useMemo(() => ({
      dense
    }), [dense]);
    const ownerState = _extends$1({}, props, {
      component,
      dense,
      disablePadding
    });
    const classes = useUtilityClasses$W(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
      value: context,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, _extends$1({
        as: component,
        className: clsx(classes.root, className),
        ref,
        ownerState
      }, other, {
        children: [subheader, children]
      }))
    });
  });
  const _excluded$18 = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
  function nextItem$1(list, item, disableListWrap) {
    if (list === item) {
      return list.firstChild;
    }
    if (item && item.nextElementSibling) {
      return item.nextElementSibling;
    }
    return disableListWrap ? null : list.firstChild;
  }
  function previousItem$1(list, item, disableListWrap) {
    if (list === item) {
      return disableListWrap ? list.firstChild : list.lastChild;
    }
    if (item && item.previousElementSibling) {
      return item.previousElementSibling;
    }
    return disableListWrap ? null : list.lastChild;
  }
  function textCriteriaMatches(nextFocus, textCriteria) {
    if (textCriteria === void 0) {
      return true;
    }
    let text = nextFocus.innerText;
    if (text === void 0) {
      text = nextFocus.textContent;
    }
    text = text.trim().toLowerCase();
    if (text.length === 0) {
      return false;
    }
    if (textCriteria.repeating) {
      return text[0] === textCriteria.keys[0];
    }
    return text.indexOf(textCriteria.keys.join("")) === 0;
  }
  function moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
    let wrappedOnce = false;
    let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
    while (nextFocus) {
      if (nextFocus === list.firstChild) {
        if (wrappedOnce) {
          return false;
        }
        wrappedOnce = true;
      }
      const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
      if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
        nextFocus = traversalFunction(list, nextFocus, disableListWrap);
      } else {
        nextFocus.focus();
        return true;
      }
    }
    return false;
  }
  const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref) {
    const {
      // private
      // eslint-disable-next-line react/prop-types
      actions,
      autoFocus = false,
      autoFocusItem = false,
      children,
      className,
      disabledItemsFocusable = false,
      disableListWrap = false,
      onKeyDown,
      variant = "selectedMenu"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$18);
    const listRef = reactExports.useRef(null);
    const textCriteriaRef = reactExports.useRef({
      keys: [],
      repeating: true,
      previousKeyMatched: true,
      lastTime: null
    });
    useEnhancedEffect(() => {
      if (autoFocus) {
        listRef.current.focus();
      }
    }, [autoFocus]);
    reactExports.useImperativeHandle(actions, () => ({
      adjustStyleForScrollbar: (containerElement, {
        direction
      }) => {
        const noExplicitWidth = !listRef.current.style.width;
        if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
          const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
          listRef.current.style[direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
          listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
        }
        return listRef.current;
      }
    }), []);
    const handleKeyDown2 = (event) => {
      const list = listRef.current;
      const key = event.key;
      const currentFocus = ownerDocument(list).activeElement;
      if (key === "ArrowDown") {
        event.preventDefault();
        moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem$1);
      } else if (key === "ArrowUp") {
        event.preventDefault();
        moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem$1);
      } else if (key === "Home") {
        event.preventDefault();
        moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, nextItem$1);
      } else if (key === "End") {
        event.preventDefault();
        moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, previousItem$1);
      } else if (key.length === 1) {
        const criteria = textCriteriaRef.current;
        const lowerKey = key.toLowerCase();
        const currTime = performance.now();
        if (criteria.keys.length > 0) {
          if (currTime - criteria.lastTime > 500) {
            criteria.keys = [];
            criteria.repeating = true;
            criteria.previousKeyMatched = true;
          } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
            criteria.repeating = false;
          }
        }
        criteria.lastTime = currTime;
        criteria.keys.push(lowerKey);
        const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
        if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus$1(list, currentFocus, false, disabledItemsFocusable, nextItem$1, criteria))) {
          event.preventDefault();
        } else {
          criteria.previousKeyMatched = false;
        }
      }
      if (onKeyDown) {
        onKeyDown(event);
      }
    };
    const handleRef = useForkRef(listRef, ref);
    let activeItemIndex = -1;
    reactExports.Children.forEach(children, (child, index) => {
      if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
        if (activeItemIndex === index) {
          activeItemIndex += 1;
          if (activeItemIndex >= children.length) {
            activeItemIndex = -1;
          }
        }
        return;
      }
      if (!child.props.disabled) {
        if (variant === "selectedMenu" && child.props.selected) {
          activeItemIndex = index;
        } else if (activeItemIndex === -1) {
          activeItemIndex = index;
        }
      }
      if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
    });
    const items = reactExports.Children.map(children, (child, index) => {
      if (index === activeItemIndex) {
        const newChildProps = {};
        if (autoFocusItem) {
          newChildProps.autoFocus = true;
        }
        if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
          newChildProps.tabIndex = 0;
        }
        return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
      }
      return child;
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(List, _extends$1({
      role: "menu",
      ref: handleRef,
      className,
      onKeyDown: handleKeyDown2,
      tabIndex: autoFocus ? 0 : -1
    }, other, {
      children: items
    }));
  });
  const reflow = (node2) => node2.scrollTop;
  function getTransitionProps(props, options2) {
    var _style$transitionDura, _style$transitionTimi;
    const {
      timeout,
      easing: easing2,
      style: style2 = {}
    } = props;
    return {
      duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options2.mode] || 0,
      easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options2.mode] : easing2,
      delay: style2.transitionDelay
    };
  }
  const _excluded$17 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
  function getScale(value) {
    return `scale(${value}, ${value ** 2})`;
  }
  const styles$2 = {
    entering: {
      opacity: 1,
      transform: getScale(1)
    },
    entered: {
      opacity: 1,
      transform: "none"
    }
  };
  const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
  const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
    const {
      addEndListener,
      appear = true,
      children,
      easing: easing2,
      in: inProp,
      onEnter,
      onEntered,
      onEntering,
      onExit,
      onExited,
      onExiting,
      style: style2,
      timeout = "auto",
      // eslint-disable-next-line react/prop-types
      TransitionComponent = Transition
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$17);
    const timer = useTimeout();
    const autoTimeout = reactExports.useRef();
    const theme = useTheme$1();
    const nodeRef = reactExports.useRef(null);
    const handleRef = useForkRef(nodeRef, children.ref, ref);
    const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
      if (callback) {
        const node2 = nodeRef.current;
        if (maybeIsAppearing === void 0) {
          callback(node2);
        } else {
          callback(node2, maybeIsAppearing);
        }
      }
    };
    const handleEntering = normalizedTransitionCallback(onEntering);
    const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
      reflow(node2);
      const {
        duration: transitionDuration,
        delay,
        easing: transitionTimingFunction
      } = getTransitionProps({
        style: style2,
        timeout,
        easing: easing2
      }, {
        mode: "enter"
      });
      let duration2;
      if (timeout === "auto") {
        duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
        autoTimeout.current = duration2;
      } else {
        duration2 = transitionDuration;
      }
      node2.style.transition = [theme.transitions.create("opacity", {
        duration: duration2,
        delay
      }), theme.transitions.create("transform", {
        duration: isWebKit154 ? duration2 : duration2 * 0.666,
        delay,
        easing: transitionTimingFunction
      })].join(",");
      if (onEnter) {
        onEnter(node2, isAppearing);
      }
    });
    const handleEntered = normalizedTransitionCallback(onEntered);
    const handleExiting = normalizedTransitionCallback(onExiting);
    const handleExit = normalizedTransitionCallback((node2) => {
      const {
        duration: transitionDuration,
        delay,
        easing: transitionTimingFunction
      } = getTransitionProps({
        style: style2,
        timeout,
        easing: easing2
      }, {
        mode: "exit"
      });
      let duration2;
      if (timeout === "auto") {
        duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
        autoTimeout.current = duration2;
      } else {
        duration2 = transitionDuration;
      }
      node2.style.transition = [theme.transitions.create("opacity", {
        duration: duration2,
        delay
      }), theme.transitions.create("transform", {
        duration: isWebKit154 ? duration2 : duration2 * 0.666,
        delay: isWebKit154 ? delay : delay || duration2 * 0.333,
        easing: transitionTimingFunction
      })].join(",");
      node2.style.opacity = 0;
      node2.style.transform = getScale(0.75);
      if (onExit) {
        onExit(node2);
      }
    });
    const handleExited = normalizedTransitionCallback(onExited);
    const handleAddEndListener = (next2) => {
      if (timeout === "auto") {
        timer.start(autoTimeout.current || 0, next2);
      }
      if (addEndListener) {
        addEndListener(nodeRef.current, next2);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
      appear,
      in: inProp,
      nodeRef,
      onEnter: handleEnter,
      onEntered: handleEntered,
      onEntering: handleEntering,
      onExit: handleExit,
      onExited: handleExited,
      onExiting: handleExiting,
      addEndListener: handleAddEndListener,
      timeout: timeout === "auto" ? null : timeout
    }, other, {
      children: (state, childProps) => {
        return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
          style: _extends$1({
            opacity: 0,
            transform: getScale(0.75),
            visibility: state === "exited" && !inProp ? "hidden" : void 0
          }, styles$2[state], style2, children.props.style),
          ref: handleRef
        }, childProps));
      }
    }));
  });
  Grow.muiSupportAuto = true;
  function isOverflowing(container) {
    const doc = ownerDocument(container);
    if (doc.body === container) {
      return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
    }
    return container.scrollHeight > container.clientHeight;
  }
  function ariaHidden(element, show) {
    if (show) {
      element.setAttribute("aria-hidden", "true");
    } else {
      element.removeAttribute("aria-hidden");
    }
  }
  function getPaddingRight(element) {
    return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
  }
  function isAriaHiddenForbiddenOnElement(element) {
    const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
    const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
    const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
    return isForbiddenTagName || isInputHidden;
  }
  function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
    const blacklist = [mountElement, currentElement, ...elementsToExclude];
    [].forEach.call(container.children, (element) => {
      const isNotExcludedElement = blacklist.indexOf(element) === -1;
      const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
      if (isNotExcludedElement && isNotForbiddenElement) {
        ariaHidden(element, show);
      }
    });
  }
  function findIndexOf(items, callback) {
    let idx = -1;
    items.some((item, index) => {
      if (callback(item)) {
        idx = index;
        return true;
      }
      return false;
    });
    return idx;
  }
  function handleContainer(containerInfo, props) {
    const restoreStyle = [];
    const container = containerInfo.container;
    if (!props.disableScrollLock) {
      if (isOverflowing(container)) {
        const scrollbarSize = getScrollbarSize(ownerDocument(container));
        restoreStyle.push({
          value: container.style.paddingRight,
          property: "padding-right",
          el: container
        });
        container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
        const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
        [].forEach.call(fixedElements2, (element) => {
          restoreStyle.push({
            value: element.style.paddingRight,
            property: "padding-right",
            el: element
          });
          element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
        });
      }
      let scrollContainer;
      if (container.parentNode instanceof DocumentFragment) {
        scrollContainer = ownerDocument(container).body;
      } else {
        const parent = container.parentElement;
        const containerWindow = ownerWindow(container);
        scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
      }
      restoreStyle.push({
        value: scrollContainer.style.overflow,
        property: "overflow",
        el: scrollContainer
      }, {
        value: scrollContainer.style.overflowX,
        property: "overflow-x",
        el: scrollContainer
      }, {
        value: scrollContainer.style.overflowY,
        property: "overflow-y",
        el: scrollContainer
      });
      scrollContainer.style.overflow = "hidden";
    }
    const restore = () => {
      restoreStyle.forEach(({
        value,
        el: el2,
        property
      }) => {
        if (value) {
          el2.style.setProperty(property, value);
        } else {
          el2.style.removeProperty(property);
        }
      });
    };
    return restore;
  }
  function getHiddenSiblings(container) {
    const hiddenSiblings = [];
    [].forEach.call(container.children, (element) => {
      if (element.getAttribute("aria-hidden") === "true") {
        hiddenSiblings.push(element);
      }
    });
    return hiddenSiblings;
  }
  class ModalManager {
    constructor() {
      this.containers = void 0;
      this.modals = void 0;
      this.modals = [];
      this.containers = [];
    }
    add(modal, container) {
      let modalIndex = this.modals.indexOf(modal);
      if (modalIndex !== -1) {
        return modalIndex;
      }
      modalIndex = this.modals.length;
      this.modals.push(modal);
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, false);
      }
      const hiddenSiblings = getHiddenSiblings(container);
      ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
      const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
      if (containerIndex !== -1) {
        this.containers[containerIndex].modals.push(modal);
        return modalIndex;
      }
      this.containers.push({
        modals: [modal],
        container,
        restore: null,
        hiddenSiblings
      });
      return modalIndex;
    }
    mount(modal, props) {
      const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
      const containerInfo = this.containers[containerIndex];
      if (!containerInfo.restore) {
        containerInfo.restore = handleContainer(containerInfo, props);
      }
    }
    remove(modal, ariaHiddenState = true) {
      const modalIndex = this.modals.indexOf(modal);
      if (modalIndex === -1) {
        return modalIndex;
      }
      const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
      const containerInfo = this.containers[containerIndex];
      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
      this.modals.splice(modalIndex, 1);
      if (containerInfo.modals.length === 0) {
        if (containerInfo.restore) {
          containerInfo.restore();
        }
        if (modal.modalRef) {
          ariaHidden(modal.modalRef, ariaHiddenState);
        }
        ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
        this.containers.splice(containerIndex, 1);
      } else {
        const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
        if (nextTop.modalRef) {
          ariaHidden(nextTop.modalRef, false);
        }
      }
      return modalIndex;
    }
    isTopModal(modal) {
      return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
    }
  }
  const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
  function getTabIndex(node2) {
    const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
    if (!Number.isNaN(tabindexAttr)) {
      return tabindexAttr;
    }
    if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
      return 0;
    }
    return node2.tabIndex;
  }
  function isNonTabbableRadio(node2) {
    if (node2.tagName !== "INPUT" || node2.type !== "radio") {
      return false;
    }
    if (!node2.name) {
      return false;
    }
    const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
    let roving = getRadio(`[name="${node2.name}"]:checked`);
    if (!roving) {
      roving = getRadio(`[name="${node2.name}"]`);
    }
    return roving !== node2;
  }
  function isNodeMatchingSelectorFocusable(node2) {
    if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
      return false;
    }
    return true;
  }
  function defaultGetTabbable(root) {
    const regularTabNodes = [];
    const orderedTabNodes = [];
    Array.from(root.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
      const nodeTabIndex = getTabIndex(node2);
      if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
        return;
      }
      if (nodeTabIndex === 0) {
        regularTabNodes.push(node2);
      } else {
        orderedTabNodes.push({
          documentOrder: i,
          tabIndex: nodeTabIndex,
          node: node2
        });
      }
    });
    return orderedTabNodes.sort((a, b2) => a.tabIndex === b2.tabIndex ? a.documentOrder - b2.documentOrder : a.tabIndex - b2.tabIndex).map((a) => a.node).concat(regularTabNodes);
  }
  function defaultIsEnabled() {
    return true;
  }
  function FocusTrap(props) {
    const {
      children,
      disableAutoFocus = false,
      disableEnforceFocus = false,
      disableRestoreFocus = false,
      getTabbable = defaultGetTabbable,
      isEnabled = defaultIsEnabled,
      open
    } = props;
    const ignoreNextEnforceFocus = reactExports.useRef(false);
    const sentinelStart = reactExports.useRef(null);
    const sentinelEnd = reactExports.useRef(null);
    const nodeToRestore = reactExports.useRef(null);
    const reactFocusEventTarget = reactExports.useRef(null);
    const activated = reactExports.useRef(false);
    const rootRef = reactExports.useRef(null);
    const handleRef = useForkRef(children.ref, rootRef);
    const lastKeydown = reactExports.useRef(null);
    reactExports.useEffect(() => {
      if (!open || !rootRef.current) {
        return;
      }
      activated.current = !disableAutoFocus;
    }, [disableAutoFocus, open]);
    reactExports.useEffect(() => {
      if (!open || !rootRef.current) {
        return;
      }
      const doc = ownerDocument(rootRef.current);
      if (!rootRef.current.contains(doc.activeElement)) {
        if (!rootRef.current.hasAttribute("tabIndex")) {
          rootRef.current.setAttribute("tabIndex", "-1");
        }
        if (activated.current) {
          rootRef.current.focus();
        }
      }
      return () => {
        if (!disableRestoreFocus) {
          if (nodeToRestore.current && nodeToRestore.current.focus) {
            ignoreNextEnforceFocus.current = true;
            nodeToRestore.current.focus();
          }
          nodeToRestore.current = null;
        }
      };
    }, [open]);
    reactExports.useEffect(() => {
      if (!open || !rootRef.current) {
        return;
      }
      const doc = ownerDocument(rootRef.current);
      const loopFocus = (nativeEvent) => {
        lastKeydown.current = nativeEvent;
        if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
          return;
        }
        if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
          ignoreNextEnforceFocus.current = true;
          if (sentinelEnd.current) {
            sentinelEnd.current.focus();
          }
        }
      };
      const contain = () => {
        const rootElement = rootRef.current;
        if (rootElement === null) {
          return;
        }
        if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
          ignoreNextEnforceFocus.current = false;
          return;
        }
        if (rootElement.contains(doc.activeElement)) {
          return;
        }
        if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
          return;
        }
        if (doc.activeElement !== reactFocusEventTarget.current) {
          reactFocusEventTarget.current = null;
        } else if (reactFocusEventTarget.current !== null) {
          return;
        }
        if (!activated.current) {
          return;
        }
        let tabbable = [];
        if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
          tabbable = getTabbable(rootRef.current);
        }
        if (tabbable.length > 0) {
          var _lastKeydown$current, _lastKeydown$current2;
          const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
          const focusNext = tabbable[0];
          const focusPrevious = tabbable[tabbable.length - 1];
          if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
            if (isShiftTab) {
              focusPrevious.focus();
            } else {
              focusNext.focus();
            }
          }
        } else {
          rootElement.focus();
        }
      };
      doc.addEventListener("focusin", contain);
      doc.addEventListener("keydown", loopFocus, true);
      const interval = setInterval(() => {
        if (doc.activeElement && doc.activeElement.tagName === "BODY") {
          contain();
        }
      }, 50);
      return () => {
        clearInterval(interval);
        doc.removeEventListener("focusin", contain);
        doc.removeEventListener("keydown", loopFocus, true);
      };
    }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
    const onFocus = (event) => {
      if (nodeToRestore.current === null) {
        nodeToRestore.current = event.relatedTarget;
      }
      activated.current = true;
      reactFocusEventTarget.current = event.target;
      const childrenPropsHandler = children.props.onFocus;
      if (childrenPropsHandler) {
        childrenPropsHandler(event);
      }
    };
    const handleFocusSentinel = (event) => {
      if (nodeToRestore.current === null) {
        nodeToRestore.current = event.relatedTarget;
      }
      activated.current = true;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        tabIndex: open ? 0 : -1,
        onFocus: handleFocusSentinel,
        ref: sentinelStart,
        "data-testid": "sentinelStart"
      }), /* @__PURE__ */ reactExports.cloneElement(children, {
        ref: handleRef,
        onFocus
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        tabIndex: open ? 0 : -1,
        onFocus: handleFocusSentinel,
        ref: sentinelEnd,
        "data-testid": "sentinelEnd"
      })]
    });
  }
  function getContainer$1(container) {
    return typeof container === "function" ? container() : container;
  }
  const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
    const {
      children,
      container,
      disablePortal = false
    } = props;
    const [mountNode, setMountNode] = reactExports.useState(null);
    const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, forwardedRef);
    useEnhancedEffect(() => {
      if (!disablePortal) {
        setMountNode(getContainer$1(container) || document.body);
      }
    }, [container, disablePortal]);
    useEnhancedEffect(() => {
      if (mountNode && !disablePortal) {
        setRef(forwardedRef, mountNode);
        return () => {
          setRef(forwardedRef, null);
        };
      }
      return void 0;
    }, [forwardedRef, mountNode, disablePortal]);
    if (disablePortal) {
      if (/* @__PURE__ */ reactExports.isValidElement(children)) {
        const newProps = {
          ref: handleRef
        };
        return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
    });
  });
  const _excluded$16 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
  const styles$1 = {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    }
  };
  const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
    const theme = useTheme$1();
    const defaultTimeout = {
      enter: theme.transitions.duration.enteringScreen,
      exit: theme.transitions.duration.leavingScreen
    };
    const {
      addEndListener,
      appear = true,
      children,
      easing: easing2,
      in: inProp,
      onEnter,
      onEntered,
      onEntering,
      onExit,
      onExited,
      onExiting,
      style: style2,
      timeout = defaultTimeout,
      // eslint-disable-next-line react/prop-types
      TransitionComponent = Transition
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$16);
    const nodeRef = reactExports.useRef(null);
    const handleRef = useForkRef(nodeRef, children.ref, ref);
    const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
      if (callback) {
        const node2 = nodeRef.current;
        if (maybeIsAppearing === void 0) {
          callback(node2);
        } else {
          callback(node2, maybeIsAppearing);
        }
      }
    };
    const handleEntering = normalizedTransitionCallback(onEntering);
    const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
      reflow(node2);
      const transitionProps = getTransitionProps({
        style: style2,
        timeout,
        easing: easing2
      }, {
        mode: "enter"
      });
      node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
      node2.style.transition = theme.transitions.create("opacity", transitionProps);
      if (onEnter) {
        onEnter(node2, isAppearing);
      }
    });
    const handleEntered = normalizedTransitionCallback(onEntered);
    const handleExiting = normalizedTransitionCallback(onExiting);
    const handleExit = normalizedTransitionCallback((node2) => {
      const transitionProps = getTransitionProps({
        style: style2,
        timeout,
        easing: easing2
      }, {
        mode: "exit"
      });
      node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
      node2.style.transition = theme.transitions.create("opacity", transitionProps);
      if (onExit) {
        onExit(node2);
      }
    });
    const handleExited = normalizedTransitionCallback(onExited);
    const handleAddEndListener = (next2) => {
      if (addEndListener) {
        addEndListener(nodeRef.current, next2);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
      appear,
      in: inProp,
      nodeRef,
      onEnter: handleEnter,
      onEntered: handleEntered,
      onEntering: handleEntering,
      onExit: handleExit,
      onExited: handleExited,
      onExiting: handleExiting,
      addEndListener: handleAddEndListener,
      timeout
    }, other, {
      children: (state, childProps) => {
        return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
          style: _extends$1({
            opacity: 0,
            visibility: state === "exited" && !inProp ? "hidden" : void 0
          }, styles$1[state], style2, children.props.style),
          ref: handleRef
        }, childProps));
      }
    }));
  });
  function getBackdropUtilityClass(slot) {
    return generateUtilityClass("MuiBackdrop", slot);
  }
  generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
  const _excluded$15 = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
  const useUtilityClasses$V = (ownerState) => {
    const {
      classes,
      invisible
    } = ownerState;
    const slots = {
      root: ["root", invisible && "invisible"]
    };
    return composeClasses(slots, getBackdropUtilityClass, classes);
  };
  const BackdropRoot = styled("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.invisible && styles2.invisible];
    }
  })(({
    ownerState
  }) => _extends$1({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent"
  }, ownerState.invisible && {
    backgroundColor: "transparent"
  }));
  const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
    var _slotProps$root, _ref, _slots$root;
    const props = useDefaultProps({
      props: inProps,
      name: "MuiBackdrop"
    });
    const {
      children,
      className,
      component = "div",
      components = {},
      componentsProps = {},
      invisible = false,
      open,
      slotProps = {},
      slots = {},
      TransitionComponent = Fade,
      transitionDuration
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$15);
    const ownerState = _extends$1({}, props, {
      component,
      invisible
    });
    const classes = useUtilityClasses$V(ownerState);
    const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
      in: open,
      timeout: transitionDuration
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends$1({
        "aria-hidden": true
      }, rootSlotProps, {
        as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
        className: clsx(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
        ownerState: _extends$1({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
        classes,
        ref,
        children
      }))
    }));
  });
  function getContainer(container) {
    return typeof container === "function" ? container() : container;
  }
  function getHasTransition(children) {
    return children ? children.props.hasOwnProperty("in") : false;
  }
  const defaultManager = new ModalManager();
  function useModal(parameters) {
    const {
      container,
      disableEscapeKeyDown = false,
      disableScrollLock = false,
      // @ts-ignore internal logic - Base UI supports the manager as a prop too
      manager = defaultManager,
      closeAfterTransition = false,
      onTransitionEnter,
      onTransitionExited,
      children,
      onClose,
      open,
      rootRef
    } = parameters;
    const modal = reactExports.useRef({});
    const mountNodeRef = reactExports.useRef(null);
    const modalRef = reactExports.useRef(null);
    const handleRef = useForkRef(modalRef, rootRef);
    const [exited, setExited] = reactExports.useState(!open);
    const hasTransition = getHasTransition(children);
    let ariaHiddenProp = true;
    if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
      ariaHiddenProp = false;
    }
    const getDoc = () => ownerDocument(mountNodeRef.current);
    const getModal = () => {
      modal.current.modalRef = modalRef.current;
      modal.current.mount = mountNodeRef.current;
      return modal.current;
    };
    const handleMounted = () => {
      manager.mount(getModal(), {
        disableScrollLock
      });
      if (modalRef.current) {
        modalRef.current.scrollTop = 0;
      }
    };
    const handleOpen = useEventCallback(() => {
      const resolvedContainer = getContainer(container) || getDoc().body;
      manager.add(getModal(), resolvedContainer);
      if (modalRef.current) {
        handleMounted();
      }
    });
    const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
    const handlePortalRef = useEventCallback((node2) => {
      mountNodeRef.current = node2;
      if (!node2) {
        return;
      }
      if (open && isTopModal()) {
        handleMounted();
      } else if (modalRef.current) {
        ariaHidden(modalRef.current, ariaHiddenProp);
      }
    });
    const handleClose = reactExports.useCallback(() => {
      manager.remove(getModal(), ariaHiddenProp);
    }, [ariaHiddenProp, manager]);
    reactExports.useEffect(() => {
      return () => {
        handleClose();
      };
    }, [handleClose]);
    reactExports.useEffect(() => {
      if (open) {
        handleOpen();
      } else if (!hasTransition || !closeAfterTransition) {
        handleClose();
      }
    }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
    const createHandleKeyDown = (otherHandlers) => (event) => {
      var _otherHandlers$onKeyD;
      (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
      if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
      !isTopModal()) {
        return;
      }
      if (!disableEscapeKeyDown) {
        event.stopPropagation();
        if (onClose) {
          onClose(event, "escapeKeyDown");
        }
      }
    };
    const createHandleBackdropClick = (otherHandlers) => (event) => {
      var _otherHandlers$onClic;
      (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
      if (event.target !== event.currentTarget) {
        return;
      }
      if (onClose) {
        onClose(event, "backdropClick");
      }
    };
    const getRootProps = (otherHandlers = {}) => {
      const propsEventHandlers = extractEventHandlers(parameters);
      delete propsEventHandlers.onTransitionEnter;
      delete propsEventHandlers.onTransitionExited;
      const externalEventHandlers = _extends$1({}, propsEventHandlers, otherHandlers);
      return _extends$1({
        role: "presentation"
      }, externalEventHandlers, {
        onKeyDown: createHandleKeyDown(externalEventHandlers),
        ref: handleRef
      });
    };
    const getBackdropProps = (otherHandlers = {}) => {
      const externalEventHandlers = otherHandlers;
      return _extends$1({
        "aria-hidden": true
      }, externalEventHandlers, {
        onClick: createHandleBackdropClick(externalEventHandlers),
        open
      });
    };
    const getTransitionProps2 = () => {
      const handleEnter = () => {
        setExited(false);
        if (onTransitionEnter) {
          onTransitionEnter();
        }
      };
      const handleExited = () => {
        setExited(true);
        if (onTransitionExited) {
          onTransitionExited();
        }
        if (closeAfterTransition) {
          handleClose();
        }
      };
      return {
        onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
        onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
      };
    };
    return {
      getRootProps,
      getBackdropProps,
      getTransitionProps: getTransitionProps2,
      rootRef: handleRef,
      portalRef: handlePortalRef,
      isTopModal,
      exited,
      hasTransition
    };
  }
  function getModalUtilityClass(slot) {
    return generateUtilityClass("MuiModal", slot);
  }
  generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
  const _excluded$14 = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"];
  const useUtilityClasses$U = (ownerState) => {
    const {
      open,
      exited,
      classes
    } = ownerState;
    const slots = {
      root: ["root", !open && exited && "hidden"],
      backdrop: ["backdrop"]
    };
    return composeClasses(slots, getModalUtilityClass, classes);
  };
  const ModalRoot = styled("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
    }
  })(({
    theme,
    ownerState
  }) => _extends$1({
    position: "fixed",
    zIndex: (theme.vars || theme).zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0
  }, !ownerState.open && ownerState.exited && {
    visibility: "hidden"
  }));
  const ModalBackdrop = styled(Backdrop, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (props, styles2) => {
      return styles2.backdrop;
    }
  })({
    zIndex: -1
  });
  const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref) {
    var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
    const props = useDefaultProps({
      name: "MuiModal",
      props: inProps
    });
    const {
      BackdropComponent = ModalBackdrop,
      BackdropProps,
      className,
      closeAfterTransition = false,
      children,
      container,
      component,
      components = {},
      componentsProps = {},
      disableAutoFocus = false,
      disableEnforceFocus = false,
      disableEscapeKeyDown = false,
      disablePortal = false,
      disableRestoreFocus = false,
      disableScrollLock = false,
      hideBackdrop = false,
      keepMounted = false,
      onBackdropClick,
      open,
      slotProps,
      slots
      // eslint-disable-next-line react/prop-types
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$14);
    const propsWithDefaults = _extends$1({}, props, {
      closeAfterTransition,
      disableAutoFocus,
      disableEnforceFocus,
      disableEscapeKeyDown,
      disablePortal,
      disableRestoreFocus,
      disableScrollLock,
      hideBackdrop,
      keepMounted
    });
    const {
      getRootProps,
      getBackdropProps,
      getTransitionProps: getTransitionProps2,
      portalRef,
      isTopModal,
      exited,
      hasTransition
    } = useModal(_extends$1({}, propsWithDefaults, {
      rootRef: ref
    }));
    const ownerState = _extends$1({}, propsWithDefaults, {
      exited
    });
    const classes = useUtilityClasses$U(ownerState);
    const childProps = {};
    if (children.props.tabIndex === void 0) {
      childProps.tabIndex = "-1";
    }
    if (hasTransition) {
      const {
        onEnter,
        onExited
      } = getTransitionProps2();
      childProps.onEnter = onEnter;
      childProps.onExited = onExited;
    }
    const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
    const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
    const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
    const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
    const rootProps = useSlotProps({
      elementType: RootSlot,
      externalSlotProps: rootSlotProps,
      externalForwardedProps: other,
      getSlotProps: getRootProps,
      additionalProps: {
        ref,
        as: component
      },
      ownerState,
      className: clsx(className, rootSlotProps == null ? void 0 : rootSlotProps.className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
    });
    const backdropProps = useSlotProps({
      elementType: BackdropSlot,
      externalSlotProps: backdropSlotProps,
      additionalProps: BackdropProps,
      getSlotProps: (otherHandlers) => {
        return getBackdropProps(_extends$1({}, otherHandlers, {
          onClick: (e2) => {
            if (onBackdropClick) {
              onBackdropClick(e2);
            }
            if (otherHandlers != null && otherHandlers.onClick) {
              otherHandlers.onClick(e2);
            }
          }
        }));
      },
      className: clsx(backdropSlotProps == null ? void 0 : backdropSlotProps.className, BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
      ownerState
    });
    if (!keepMounted && !open && (!hasTransition || exited)) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
      ref: portalRef,
      container,
      disablePortal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$1({}, rootProps, {
        children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, _extends$1({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
          disableEnforceFocus,
          disableAutoFocus,
          disableRestoreFocus,
          isEnabled: isTopModal,
          open,
          children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
        })]
      }))
    });
  });
  function getPaperUtilityClass(slot) {
    return generateUtilityClass("MuiPaper", slot);
  }
  generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
  const _excluded$13 = ["className", "component", "elevation", "square", "variant"];
  const useUtilityClasses$T = (ownerState) => {
    const {
      square,
      elevation,
      variant,
      classes
    } = ownerState;
    const slots = {
      root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
    };
    return composeClasses(slots, getPaperUtilityClass, classes);
  };
  const PaperRoot = styled("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
    }
  })(({
    theme,
    ownerState
  }) => {
    var _theme$vars$overlays;
    return _extends$1({
      backgroundColor: (theme.vars || theme).palette.background.paper,
      color: (theme.vars || theme).palette.text.primary,
      transition: theme.transitions.create("box-shadow")
    }, !ownerState.square && {
      borderRadius: theme.shape.borderRadius
    }, ownerState.variant === "outlined" && {
      border: `1px solid ${(theme.vars || theme).palette.divider}`
    }, ownerState.variant === "elevation" && _extends$1({
      boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
    }, !theme.vars && theme.palette.mode === "dark" && {
      backgroundImage: `linear-gradient(${alpha_1("#fff", getOverlayAlpha(ownerState.elevation))}, ${alpha_1("#fff", getOverlayAlpha(ownerState.elevation))})`
    }, theme.vars && {
      backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
    }));
  });
  const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiPaper"
    });
    const {
      className,
      component = "div",
      elevation = 1,
      square = false,
      variant = "elevation"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$13);
    const ownerState = _extends$1({}, props, {
      component,
      elevation,
      square,
      variant
    });
    const classes = useUtilityClasses$T(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends$1({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other));
  });
  function getPopoverUtilityClass(slot) {
    return generateUtilityClass("MuiPopover", slot);
  }
  generateUtilityClasses("MuiPopover", ["root", "paper"]);
  const _excluded$12 = ["onEntering"], _excluded2$b = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps", "disableScrollLock"], _excluded3$3 = ["slotProps"];
  function getOffsetTop(rect, vertical) {
    let offset2 = 0;
    if (typeof vertical === "number") {
      offset2 = vertical;
    } else if (vertical === "center") {
      offset2 = rect.height / 2;
    } else if (vertical === "bottom") {
      offset2 = rect.height;
    }
    return offset2;
  }
  function getOffsetLeft(rect, horizontal) {
    let offset2 = 0;
    if (typeof horizontal === "number") {
      offset2 = horizontal;
    } else if (horizontal === "center") {
      offset2 = rect.width / 2;
    } else if (horizontal === "right") {
      offset2 = rect.width;
    }
    return offset2;
  }
  function getTransformOriginValue(transformOrigin) {
    return [transformOrigin.horizontal, transformOrigin.vertical].map((n2) => typeof n2 === "number" ? `${n2}px` : n2).join(" ");
  }
  function resolveAnchorEl$1(anchorEl) {
    return typeof anchorEl === "function" ? anchorEl() : anchorEl;
  }
  const useUtilityClasses$S = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      paper: ["paper"]
    };
    return composeClasses(slots, getPopoverUtilityClass, classes);
  };
  const PopoverRoot = styled(Modal, {
    name: "MuiPopover",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const PopoverPaper = styled(Paper, {
    name: "MuiPopover",
    slot: "Paper",
    overridesResolver: (props, styles2) => styles2.paper
  })({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    // So we see the popover when it's empty.
    // It's most likely on issue on userland.
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  });
  const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref) {
    var _slotProps$paper, _slots$root, _slots$paper;
    const props = useDefaultProps({
      props: inProps,
      name: "MuiPopover"
    });
    const {
      action,
      anchorEl,
      anchorOrigin = {
        vertical: "top",
        horizontal: "left"
      },
      anchorPosition,
      anchorReference = "anchorEl",
      children,
      className,
      container: containerProp,
      elevation = 8,
      marginThreshold = 16,
      open,
      PaperProps: PaperPropsProp = {},
      slots,
      slotProps,
      transformOrigin = {
        vertical: "top",
        horizontal: "left"
      },
      TransitionComponent = Grow,
      transitionDuration: transitionDurationProp = "auto",
      TransitionProps: {
        onEntering
      } = {},
      disableScrollLock = false
    } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$12), other = _objectWithoutPropertiesLoose(props, _excluded2$b);
    const externalPaperSlotProps = (_slotProps$paper = slotProps == null ? void 0 : slotProps.paper) != null ? _slotProps$paper : PaperPropsProp;
    const paperRef = reactExports.useRef();
    const handlePaperRef = useForkRef(paperRef, externalPaperSlotProps.ref);
    const ownerState = _extends$1({}, props, {
      anchorOrigin,
      anchorReference,
      elevation,
      marginThreshold,
      externalPaperSlotProps,
      transformOrigin,
      TransitionComponent,
      transitionDuration: transitionDurationProp,
      TransitionProps
    });
    const classes = useUtilityClasses$S(ownerState);
    const getAnchorOffset = reactExports.useCallback(() => {
      if (anchorReference === "anchorPosition") {
        return anchorPosition;
      }
      const resolvedAnchorEl = resolveAnchorEl$1(anchorEl);
      const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
      const anchorRect = anchorElement.getBoundingClientRect();
      return {
        top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
        left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
      };
    }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
    const getTransformOrigin = reactExports.useCallback((elemRect) => {
      return {
        vertical: getOffsetTop(elemRect, transformOrigin.vertical),
        horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
      };
    }, [transformOrigin.horizontal, transformOrigin.vertical]);
    const getPositioningStyle = reactExports.useCallback((element) => {
      const elemRect = {
        width: element.offsetWidth,
        height: element.offsetHeight
      };
      const elemTransformOrigin = getTransformOrigin(elemRect);
      if (anchorReference === "none") {
        return {
          top: null,
          left: null,
          transformOrigin: getTransformOriginValue(elemTransformOrigin)
        };
      }
      const anchorOffset = getAnchorOffset();
      let top2 = anchorOffset.top - elemTransformOrigin.vertical;
      let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
      const bottom2 = top2 + elemRect.height;
      const right2 = left2 + elemRect.width;
      const containerWindow = ownerWindow(resolveAnchorEl$1(anchorEl));
      const heightThreshold = containerWindow.innerHeight - marginThreshold;
      const widthThreshold = containerWindow.innerWidth - marginThreshold;
      if (marginThreshold !== null && top2 < marginThreshold) {
        const diff = top2 - marginThreshold;
        top2 -= diff;
        elemTransformOrigin.vertical += diff;
      } else if (marginThreshold !== null && bottom2 > heightThreshold) {
        const diff = bottom2 - heightThreshold;
        top2 -= diff;
        elemTransformOrigin.vertical += diff;
      }
      if (marginThreshold !== null && left2 < marginThreshold) {
        const diff = left2 - marginThreshold;
        left2 -= diff;
        elemTransformOrigin.horizontal += diff;
      } else if (right2 > widthThreshold) {
        const diff = right2 - widthThreshold;
        left2 -= diff;
        elemTransformOrigin.horizontal += diff;
      }
      return {
        top: `${Math.round(top2)}px`,
        left: `${Math.round(left2)}px`,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
    const [isPositioned, setIsPositioned] = reactExports.useState(open);
    const setPositioningStyles = reactExports.useCallback(() => {
      const element = paperRef.current;
      if (!element) {
        return;
      }
      const positioning = getPositioningStyle(element);
      if (positioning.top !== null) {
        element.style.top = positioning.top;
      }
      if (positioning.left !== null) {
        element.style.left = positioning.left;
      }
      element.style.transformOrigin = positioning.transformOrigin;
      setIsPositioned(true);
    }, [getPositioningStyle]);
    reactExports.useEffect(() => {
      if (disableScrollLock) {
        window.addEventListener("scroll", setPositioningStyles);
      }
      return () => window.removeEventListener("scroll", setPositioningStyles);
    }, [anchorEl, disableScrollLock, setPositioningStyles]);
    const handleEntering = (element, isAppearing) => {
      if (onEntering) {
        onEntering(element, isAppearing);
      }
      setPositioningStyles();
    };
    const handleExited = () => {
      setIsPositioned(false);
    };
    reactExports.useEffect(() => {
      if (open) {
        setPositioningStyles();
      }
    });
    reactExports.useImperativeHandle(action, () => open ? {
      updatePosition: () => {
        setPositioningStyles();
      }
    } : null, [open, setPositioningStyles]);
    reactExports.useEffect(() => {
      if (!open) {
        return void 0;
      }
      const handleResize = debounce$1(() => {
        setPositioningStyles();
      });
      const containerWindow = ownerWindow(anchorEl);
      containerWindow.addEventListener("resize", handleResize);
      return () => {
        handleResize.clear();
        containerWindow.removeEventListener("resize", handleResize);
      };
    }, [anchorEl, open, setPositioningStyles]);
    let transitionDuration = transitionDurationProp;
    if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
      transitionDuration = void 0;
    }
    const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl$1(anchorEl)).body : void 0);
    const RootSlot = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : PopoverRoot;
    const PaperSlot = (_slots$paper = slots == null ? void 0 : slots.paper) != null ? _slots$paper : PopoverPaper;
    const paperProps = useSlotProps({
      elementType: PaperSlot,
      externalSlotProps: _extends$1({}, externalPaperSlotProps, {
        style: isPositioned ? externalPaperSlotProps.style : _extends$1({}, externalPaperSlotProps.style, {
          opacity: 0
        })
      }),
      additionalProps: {
        elevation,
        ref: handlePaperRef
      },
      ownerState,
      className: clsx(classes.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className)
    });
    const _useSlotProps = useSlotProps({
      elementType: RootSlot,
      externalSlotProps: (slotProps == null ? void 0 : slotProps.root) || {},
      externalForwardedProps: other,
      additionalProps: {
        ref,
        slotProps: {
          backdrop: {
            invisible: true
          }
        },
        container,
        open
      },
      ownerState,
      className: clsx(classes.root, className)
    }), {
      slotProps: rootSlotPropsProp
    } = _useSlotProps, rootProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded3$3);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, _extends$1({}, rootProps, !isHostComponent(RootSlot) && {
      slotProps: rootSlotPropsProp,
      disableScrollLock
    }, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        appear: true,
        in: open,
        onEntering: handleEntering,
        onExited: handleExited,
        timeout: transitionDuration
      }, TransitionProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, _extends$1({}, paperProps, {
          children
        }))
      }))
    }));
  });
  function getMenuUtilityClass(slot) {
    return generateUtilityClass("MuiMenu", slot);
  }
  generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
  const _excluded$11 = ["onEntering"], _excluded2$a = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"];
  const RTL_ORIGIN = {
    vertical: "top",
    horizontal: "right"
  };
  const LTR_ORIGIN = {
    vertical: "top",
    horizontal: "left"
  };
  const useUtilityClasses$R = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      paper: ["paper"],
      list: ["list"]
    };
    return composeClasses(slots, getMenuUtilityClass, classes);
  };
  const MenuRoot = styled(Popover, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiMenu",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const MenuPaper = styled(PopoverPaper, {
    name: "MuiMenu",
    slot: "Paper",
    overridesResolver: (props, styles2) => styles2.paper
  })({
    // specZ: The maximum height of a simple menu should be one or more rows less than the view
    // height. This ensures a tappable area outside of the simple menu with which to dismiss
    // the menu.
    maxHeight: "calc(100% - 96px)",
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: "touch"
  });
  const MenuMenuList = styled(MenuList, {
    name: "MuiMenu",
    slot: "List",
    overridesResolver: (props, styles2) => styles2.list
  })({
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  });
  const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref) {
    var _slots$paper, _slotProps$paper;
    const props = useDefaultProps({
      props: inProps,
      name: "MuiMenu"
    });
    const {
      autoFocus = true,
      children,
      className,
      disableAutoFocusItem = false,
      MenuListProps = {},
      onClose,
      open,
      PaperProps = {},
      PopoverClasses,
      transitionDuration = "auto",
      TransitionProps: {
        onEntering
      } = {},
      variant = "selectedMenu",
      slots = {},
      slotProps = {}
    } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$11), other = _objectWithoutPropertiesLoose(props, _excluded2$a);
    const isRtl = useRtl();
    const ownerState = _extends$1({}, props, {
      autoFocus,
      disableAutoFocusItem,
      MenuListProps,
      onEntering,
      PaperProps,
      transitionDuration,
      TransitionProps,
      variant
    });
    const classes = useUtilityClasses$R(ownerState);
    const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
    const menuListActionsRef = reactExports.useRef(null);
    const handleEntering = (element, isAppearing) => {
      if (menuListActionsRef.current) {
        menuListActionsRef.current.adjustStyleForScrollbar(element, {
          direction: isRtl ? "rtl" : "ltr"
        });
      }
      if (onEntering) {
        onEntering(element, isAppearing);
      }
    };
    const handleListKeyDown = (event) => {
      if (event.key === "Tab") {
        event.preventDefault();
        if (onClose) {
          onClose(event, "tabKeyDown");
        }
      }
    };
    let activeItemIndex = -1;
    reactExports.Children.map(children, (child, index) => {
      if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
        return;
      }
      if (!child.props.disabled) {
        if (variant === "selectedMenu" && child.props.selected) {
          activeItemIndex = index;
        } else if (activeItemIndex === -1) {
          activeItemIndex = index;
        }
      }
    });
    const PaperSlot = (_slots$paper = slots.paper) != null ? _slots$paper : MenuPaper;
    const paperExternalSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : PaperProps;
    const rootSlotProps = useSlotProps({
      elementType: slots.root,
      externalSlotProps: slotProps.root,
      ownerState,
      className: [classes.root, className]
    });
    const paperSlotProps = useSlotProps({
      elementType: PaperSlot,
      externalSlotProps: paperExternalSlotProps,
      ownerState,
      className: classes.paper
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, _extends$1({
      onClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: isRtl ? "right" : "left"
      },
      transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
      slots: {
        paper: PaperSlot,
        root: slots.root
      },
      slotProps: {
        root: rootSlotProps,
        paper: paperSlotProps
      },
      open,
      ref,
      transitionDuration,
      TransitionProps: _extends$1({
        onEntering: handleEntering
      }, TransitionProps),
      ownerState
    }, other, {
      classes: PopoverClasses,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, _extends$1({
        onKeyDown: handleListKeyDown,
        actions: menuListActionsRef,
        autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
        autoFocusItem,
        variant
      }, MenuListProps, {
        className: clsx(classes.list, MenuListProps.className),
        children
      }))
    }));
  });
  function getNativeSelectUtilityClasses(slot) {
    return generateUtilityClass("MuiNativeSelect", slot);
  }
  const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
  const _excluded$10 = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"];
  const useUtilityClasses$Q = (ownerState) => {
    const {
      classes,
      variant,
      disabled,
      multiple,
      open,
      error
    } = ownerState;
    const slots = {
      select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
      icon: ["icon", `icon${capitalize$1(variant)}`, open && "iconOpen", disabled && "disabled"]
    };
    return composeClasses(slots, getNativeSelectUtilityClasses, classes);
  };
  const nativeSelectSelectStyles = ({
    ownerState,
    theme
  }) => _extends$1({
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    // When interacting quickly, the text can end up selected.
    // Native select can't be selected either.
    userSelect: "none",
    borderRadius: 0,
    // Reset
    cursor: "pointer",
    "&:focus": _extends$1({}, theme.vars ? {
      backgroundColor: `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.05)`
    } : {
      backgroundColor: theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
    }, {
      borderRadius: 0
      // Reset Chrome style
    }),
    // Remove IE11 arrow
    "&::-ms-expand": {
      display: "none"
    },
    [`&.${nativeSelectClasses.disabled}`]: {
      cursor: "default"
    },
    "&[multiple]": {
      height: "auto"
    },
    "&:not([multiple]) option, &:not([multiple]) optgroup": {
      backgroundColor: (theme.vars || theme).palette.background.paper
    },
    // Bump specificity to allow extending custom inputs
    "&&&": {
      paddingRight: 24,
      minWidth: 16
      // So it doesn't collapse.
    }
  }, ownerState.variant === "filled" && {
    "&&&": {
      paddingRight: 32
    }
  }, ownerState.variant === "outlined" && {
    borderRadius: (theme.vars || theme).shape.borderRadius,
    "&:focus": {
      borderRadius: (theme.vars || theme).shape.borderRadius
      // Reset the reset for Chrome style
    },
    "&&&": {
      paddingRight: 32
    }
  });
  const NativeSelectSelect = styled("select", {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: rootShouldForwardProp,
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
        [`&.${nativeSelectClasses.multiple}`]: styles2.multiple
      }];
    }
  })(nativeSelectSelectStyles);
  const nativeSelectIconStyles = ({
    ownerState,
    theme
  }) => _extends$1({
    // We use a position absolute over a flexbox in order to forward the pointer events
    // to the input and to support wrapping tags..
    position: "absolute",
    right: 0,
    top: "calc(50% - .5em)",
    // Center vertically, height is 1em
    pointerEvents: "none",
    // Don't block pointer events on the select under the icon.
    color: (theme.vars || theme).palette.action.active,
    [`&.${nativeSelectClasses.disabled}`]: {
      color: (theme.vars || theme).palette.action.disabled
    }
  }, ownerState.open && {
    transform: "rotate(180deg)"
  }, ownerState.variant === "filled" && {
    right: 7
  }, ownerState.variant === "outlined" && {
    right: 7
  });
  const NativeSelectIcon = styled("svg", {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.icon, ownerState.variant && styles2[`icon${capitalize$1(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
    }
  })(nativeSelectIconStyles);
  const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref) {
    const {
      className,
      disabled,
      error,
      IconComponent,
      inputRef,
      variant = "standard"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$10);
    const ownerState = _extends$1({}, props, {
      disabled,
      variant,
      error
    });
    const classes = useUtilityClasses$Q(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, _extends$1({
        ownerState,
        className: clsx(classes.select, className),
        disabled,
        ref: inputRef || ref
      }, other)), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
        as: IconComponent,
        ownerState,
        className: classes.icon
      })]
    });
  });
  function getSelectUtilityClasses(slot) {
    return generateUtilityClass("MuiSelect", slot);
  }
  const selectClasses = generateUtilityClasses("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
  var _span$1;
  const _excluded$$ = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
  const SelectSelect = styled("div", {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [
        // Win specificity over the input base
        {
          [`&.${selectClasses.select}`]: styles2.select
        },
        {
          [`&.${selectClasses.select}`]: styles2[ownerState.variant]
        },
        {
          [`&.${selectClasses.error}`]: styles2.error
        },
        {
          [`&.${selectClasses.multiple}`]: styles2.multiple
        }
      ];
    }
  })(nativeSelectSelectStyles, {
    // Win specificity over the input base
    [`&.${selectClasses.select}`]: {
      height: "auto",
      // Resets for multiple select with chips
      minHeight: "1.4375em",
      // Required for select\text-field height consistency
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    }
  });
  const SelectIcon = styled("svg", {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.icon, ownerState.variant && styles2[`icon${capitalize$1(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
    }
  })(nativeSelectIconStyles);
  const SelectNativeInput = styled("input", {
    shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
    name: "MuiSelect",
    slot: "NativeInput",
    overridesResolver: (props, styles2) => styles2.nativeInput
  })({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box"
  });
  function areEqualValues(a, b2) {
    if (typeof b2 === "object" && b2 !== null) {
      return a === b2;
    }
    return String(a) === String(b2);
  }
  function isEmpty(display) {
    return display == null || typeof display === "string" && !display.trim();
  }
  const useUtilityClasses$P = (ownerState) => {
    const {
      classes,
      variant,
      disabled,
      multiple,
      open,
      error
    } = ownerState;
    const slots = {
      select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
      icon: ["icon", `icon${capitalize$1(variant)}`, open && "iconOpen", disabled && "disabled"],
      nativeInput: ["nativeInput"]
    };
    return composeClasses(slots, getSelectUtilityClasses, classes);
  };
  const SelectInput = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref) {
    var _MenuProps$slotProps;
    const {
      "aria-describedby": ariaDescribedby,
      "aria-label": ariaLabel,
      autoFocus,
      autoWidth,
      children,
      className,
      defaultOpen,
      defaultValue,
      disabled,
      displayEmpty,
      error = false,
      IconComponent,
      inputRef: inputRefProp,
      labelId,
      MenuProps = {},
      multiple,
      name,
      onBlur,
      onChange,
      onClose,
      onFocus,
      onOpen,
      open: openProp,
      readOnly,
      renderValue,
      SelectDisplayProps = {},
      tabIndex: tabIndexProp,
      value: valueProp,
      variant = "standard"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$$);
    const [value, setValueState] = useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: "Select"
    });
    const [openState, setOpenState] = useControlled({
      controlled: openProp,
      default: defaultOpen,
      name: "Select"
    });
    const inputRef = reactExports.useRef(null);
    const displayRef = reactExports.useRef(null);
    const [displayNode, setDisplayNode] = reactExports.useState(null);
    const {
      current: isOpenControlled
    } = reactExports.useRef(openProp != null);
    const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
    const handleRef = useForkRef(ref, inputRefProp);
    const handleDisplayRef = reactExports.useCallback((node2) => {
      displayRef.current = node2;
      if (node2) {
        setDisplayNode(node2);
      }
    }, []);
    const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
    reactExports.useImperativeHandle(handleRef, () => ({
      focus: () => {
        displayRef.current.focus();
      },
      node: inputRef.current,
      value
    }), [value]);
    reactExports.useEffect(() => {
      if (defaultOpen && openState && displayNode && !isOpenControlled) {
        setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
        displayRef.current.focus();
      }
    }, [displayNode, autoWidth]);
    reactExports.useEffect(() => {
      if (autoFocus) {
        displayRef.current.focus();
      }
    }, [autoFocus]);
    reactExports.useEffect(() => {
      if (!labelId) {
        return void 0;
      }
      const label = ownerDocument(displayRef.current).getElementById(labelId);
      if (label) {
        const handler = () => {
          if (getSelection().isCollapsed) {
            displayRef.current.focus();
          }
        };
        label.addEventListener("click", handler);
        return () => {
          label.removeEventListener("click", handler);
        };
      }
      return void 0;
    }, [labelId]);
    const update = (open2, event) => {
      if (open2) {
        if (onOpen) {
          onOpen(event);
        }
      } else if (onClose) {
        onClose(event);
      }
      if (!isOpenControlled) {
        setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
        setOpenState(open2);
      }
    };
    const handleMouseDown = (event) => {
      if (event.button !== 0) {
        return;
      }
      event.preventDefault();
      displayRef.current.focus();
      update(true, event);
    };
    const handleClose = (event) => {
      update(false, event);
    };
    const childrenArray = reactExports.Children.toArray(children);
    const handleChange = (event) => {
      const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
      if (child === void 0) {
        return;
      }
      setValueState(child.props.value);
      if (onChange) {
        onChange(event, child);
      }
    };
    const handleItemClick = (child) => (event) => {
      let newValue;
      if (!event.currentTarget.hasAttribute("tabindex")) {
        return;
      }
      if (multiple) {
        newValue = Array.isArray(value) ? value.slice() : [];
        const itemIndex = value.indexOf(child.props.value);
        if (itemIndex === -1) {
          newValue.push(child.props.value);
        } else {
          newValue.splice(itemIndex, 1);
        }
      } else {
        newValue = child.props.value;
      }
      if (child.props.onClick) {
        child.props.onClick(event);
      }
      if (value !== newValue) {
        setValueState(newValue);
        if (onChange) {
          const nativeEvent = event.nativeEvent || event;
          const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
          Object.defineProperty(clonedEvent, "target", {
            writable: true,
            value: {
              value: newValue,
              name
            }
          });
          onChange(clonedEvent, child);
        }
      }
      if (!multiple) {
        update(false, event);
      }
    };
    const handleKeyDown2 = (event) => {
      if (!readOnly) {
        const validKeys = [
          " ",
          "ArrowUp",
          "ArrowDown",
          // The native select doesn't respond to enter on macOS, but it's recommended by
          // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
          "Enter"
        ];
        if (validKeys.indexOf(event.key) !== -1) {
          event.preventDefault();
          update(true, event);
        }
      }
    };
    const open = displayNode !== null && openState;
    const handleBlur = (event) => {
      if (!open && onBlur) {
        Object.defineProperty(event, "target", {
          writable: true,
          value: {
            value,
            name
          }
        });
        onBlur(event);
      }
    };
    delete other["aria-invalid"];
    let display;
    let displaySingle;
    const displayMultiple = [];
    let computeDisplay = false;
    if (isFilled({
      value
    }) || displayEmpty) {
      if (renderValue) {
        display = renderValue(value);
      } else {
        computeDisplay = true;
      }
    }
    const items = childrenArray.map((child) => {
      if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
        return null;
      }
      let selected;
      if (multiple) {
        if (!Array.isArray(value)) {
          throw new Error(formatMuiErrorMessage$1(2));
        }
        selected = value.some((v2) => areEqualValues(v2, child.props.value));
        if (selected && computeDisplay) {
          displayMultiple.push(child.props.children);
        }
      } else {
        selected = areEqualValues(value, child.props.value);
        if (selected && computeDisplay) {
          displaySingle = child.props.children;
        }
      }
      return /* @__PURE__ */ reactExports.cloneElement(child, {
        "aria-selected": selected ? "true" : "false",
        onClick: handleItemClick(child),
        onKeyUp: (event) => {
          if (event.key === " ") {
            event.preventDefault();
          }
          if (child.props.onKeyUp) {
            child.props.onKeyUp(event);
          }
        },
        role: "option",
        selected,
        value: void 0,
        // The value is most likely not a valid HTML attribute.
        "data-value": child.props.value
        // Instead, we provide it as a data attribute.
      });
    });
    if (computeDisplay) {
      if (multiple) {
        if (displayMultiple.length === 0) {
          display = null;
        } else {
          display = displayMultiple.reduce((output, child, index) => {
            output.push(child);
            if (index < displayMultiple.length - 1) {
              output.push(", ");
            }
            return output;
          }, []);
        }
      } else {
        display = displaySingle;
      }
    }
    let menuMinWidth = menuMinWidthState;
    if (!autoWidth && isOpenControlled && displayNode) {
      menuMinWidth = anchorElement.clientWidth;
    }
    let tabIndex;
    if (typeof tabIndexProp !== "undefined") {
      tabIndex = tabIndexProp;
    } else {
      tabIndex = disabled ? null : 0;
    }
    const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
    const ownerState = _extends$1({}, props, {
      variant,
      value,
      open,
      error
    });
    const classes = useUtilityClasses$P(ownerState);
    const paperProps = _extends$1({}, MenuProps.PaperProps, (_MenuProps$slotProps = MenuProps.slotProps) == null ? void 0 : _MenuProps$slotProps.paper);
    const listboxId = useId();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, _extends$1({
        ref: handleDisplayRef,
        tabIndex,
        role: "combobox",
        "aria-controls": listboxId,
        "aria-disabled": disabled ? "true" : void 0,
        "aria-expanded": open ? "true" : "false",
        "aria-haspopup": "listbox",
        "aria-label": ariaLabel,
        "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
        "aria-describedby": ariaDescribedby,
        onKeyDown: handleKeyDown2,
        onMouseDown: disabled || readOnly ? null : handleMouseDown,
        onBlur: handleBlur,
        onFocus
      }, SelectDisplayProps, {
        ownerState,
        className: clsx(SelectDisplayProps.className, classes.select, className),
        id: buttonId,
        children: isEmpty(display) ? (
          // notranslate needed while Google Translate will not fix zero-width space issue
          _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            children: "​"
          }))
        ) : display
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, _extends$1({
        "aria-invalid": error,
        value: Array.isArray(value) ? value.join(",") : value,
        name,
        ref: inputRef,
        "aria-hidden": true,
        onChange: handleChange,
        tabIndex: -1,
        disabled,
        className: classes.nativeInput,
        autoFocus,
        ownerState
      }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
        as: IconComponent,
        className: classes.icon,
        ownerState
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, _extends$1({
        id: `menu-${name || ""}`,
        anchorEl: anchorElement,
        open,
        onClose: handleClose,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: "center"
        },
        transformOrigin: {
          vertical: "top",
          horizontal: "center"
        }
      }, MenuProps, {
        MenuListProps: _extends$1({
          "aria-labelledby": labelId,
          role: "listbox",
          "aria-multiselectable": multiple ? "true" : void 0,
          disableListWrap: true,
          id: listboxId
        }, MenuProps.MenuListProps),
        slotProps: _extends$1({}, MenuProps.slotProps, {
          paper: _extends$1({}, paperProps, {
            style: _extends$1({
              minWidth: menuMinWidth
            }, paperProps != null ? paperProps.style : null)
          })
        }),
        children: items
      }))]
    });
  });
  function getSvgIconUtilityClass(slot) {
    return generateUtilityClass("MuiSvgIcon", slot);
  }
  generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
  const _excluded$_ = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
  const useUtilityClasses$O = (ownerState) => {
    const {
      color: color2,
      fontSize,
      classes
    } = ownerState;
    const slots = {
      root: ["root", color2 !== "inherit" && `color${capitalize$1(color2)}`, `fontSize${capitalize$1(fontSize)}`]
    };
    return composeClasses(slots, getSvgIconUtilityClass, classes);
  };
  const SvgIconRoot = styled("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize$1(ownerState.color)}`], styles2[`fontSize${capitalize$1(ownerState.fontSize)}`]];
    }
  })(({
    theme,
    ownerState
  }) => {
    var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
    return {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      // the <svg> will define the property that has `currentColor`
      // for example heroicons uses fill="none" and stroke="currentColor"
      fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
      flexShrink: 0,
      transition: (_theme$transitions = theme.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
        duration: (_theme$transitions2 = theme.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
      }),
      fontSize: {
        inherit: "inherit",
        small: ((_theme$typography = theme.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
        medium: ((_theme$typography2 = theme.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
        large: ((_theme$typography3 = theme.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
      }[ownerState.fontSize],
      // TODO v5 deprecate, v6 remove for sx
      color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
        action: (_palette2 = (theme.vars || theme).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
        disabled: (_palette3 = (theme.vars || theme).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
        inherit: void 0
      }[ownerState.color]
    };
  });
  const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiSvgIcon"
    });
    const {
      children,
      className,
      color: color2 = "inherit",
      component = "svg",
      fontSize = "medium",
      htmlColor,
      inheritViewBox = false,
      titleAccess,
      viewBox = "0 0 24 24"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$_);
    const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
    const ownerState = _extends$1({}, props, {
      color: color2,
      component,
      fontSize,
      instanceFontSize: inProps.fontSize,
      inheritViewBox,
      viewBox,
      hasSvgAsChild
    });
    const more = {};
    if (!inheritViewBox) {
      more.viewBox = viewBox;
    }
    const classes = useUtilityClasses$O(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends$1({
      as: component,
      className: clsx(classes.root, className),
      focusable: "false",
      color: htmlColor,
      "aria-hidden": titleAccess ? void 0 : true,
      role: titleAccess ? "img" : void 0,
      ref
    }, more, other, hasSvgAsChild && children.props, {
      ownerState,
      children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
        children: titleAccess
      }) : null]
    }));
  });
  SvgIcon.muiName = "SvgIcon";
  function createSvgIcon(path, displayName) {
    function Component(props, ref) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, _extends$1({
        "data-testid": `${displayName}Icon`,
        ref
      }, props, {
        children: path
      }));
    }
    Component.muiName = SvgIcon.muiName;
    return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
  }
  const ArrowDropDownIcon$1 = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M7 10l5 5 5-5z"
  }), "ArrowDropDown");
  const _excluded$Z = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], _excluded2$9 = ["root"];
  const useUtilityClasses$N = (ownerState) => {
    const {
      classes
    } = ownerState;
    return classes;
  };
  const styledRootConfig = {
    name: "MuiSelect",
    overridesResolver: (props, styles2) => styles2.root,
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
    slot: "Root"
  };
  const StyledInput = styled(Input, styledRootConfig)("");
  const StyledOutlinedInput = styled(OutlinedInput, styledRootConfig)("");
  const StyledFilledInput = styled(FilledInput, styledRootConfig)("");
  const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref) {
    const props = useDefaultProps({
      name: "MuiSelect",
      props: inProps
    });
    const {
      autoWidth = false,
      children,
      classes: classesProp = {},
      className,
      defaultOpen = false,
      displayEmpty = false,
      IconComponent = ArrowDropDownIcon$1,
      id: id2,
      input,
      inputProps,
      label,
      labelId,
      MenuProps,
      multiple = false,
      native = false,
      onClose,
      onOpen,
      open,
      renderValue,
      SelectDisplayProps,
      variant: variantProp = "outlined"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$Z);
    const inputComponent = native ? NativeSelectInput : SelectInput;
    const muiFormControl = useFormControl();
    const fcs = formControlState({
      props,
      muiFormControl,
      states: ["variant", "error"]
    });
    const variant = fcs.variant || variantProp;
    const ownerState = _extends$1({}, props, {
      variant,
      classes: classesProp
    });
    const classes = useUtilityClasses$N(ownerState);
    const restOfClasses = _objectWithoutPropertiesLoose(classes, _excluded2$9);
    const InputComponent = input || {
      standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
        ownerState
      }),
      outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
        label,
        ownerState
      }),
      filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
        ownerState
      })
    }[variant];
    const inputComponentRef = useForkRef(ref, InputComponent.ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, _extends$1({
        // Most of the logic is implemented in `SelectInput`.
        // The `Select` component is a simple API wrapper to expose something better to play with.
        inputComponent,
        inputProps: _extends$1({
          children,
          error: fcs.error,
          IconComponent,
          variant,
          type: void 0,
          // We render a select. We can ignore the type provided by the `Input`.
          multiple
        }, native ? {
          id: id2
        } : {
          autoWidth,
          defaultOpen,
          displayEmpty,
          labelId,
          MenuProps,
          onClose,
          onOpen,
          open,
          renderValue,
          SelectDisplayProps: _extends$1({
            id: id2
          }, SelectDisplayProps)
        }, inputProps, {
          classes: inputProps ? deepmerge$1(restOfClasses, inputProps.classes) : restOfClasses
        }, input ? input.props.inputProps : {})
      }, (multiple && native || displayEmpty) && variant === "outlined" ? {
        notched: true
      } : {}, {
        ref: inputComponentRef,
        className: clsx(InputComponent.props.className, className, classes.root)
      }, !input && {
        variant
      }, other))
    });
  });
  Select.muiName = "Select";
  function getTextFieldUtilityClass(slot) {
    return generateUtilityClass("MuiTextField", slot);
  }
  generateUtilityClasses("MuiTextField", ["root"]);
  const _excluded$Y = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"];
  const variantComponent = {
    standard: Input,
    filled: FilledInput,
    outlined: OutlinedInput
  };
  const useUtilityClasses$M = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getTextFieldUtilityClass, classes);
  };
  const TextFieldRoot = styled(FormControl, {
    name: "MuiTextField",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const TextField = /* @__PURE__ */ reactExports.forwardRef(function TextField2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTextField"
    });
    const {
      autoComplete,
      autoFocus = false,
      children,
      className,
      color: color2 = "primary",
      defaultValue,
      disabled = false,
      error = false,
      FormHelperTextProps,
      fullWidth = false,
      helperText,
      id: idOverride,
      InputLabelProps,
      inputProps,
      InputProps,
      inputRef,
      label,
      maxRows,
      minRows,
      multiline = false,
      name,
      onBlur,
      onChange,
      onFocus,
      placeholder,
      required = false,
      rows,
      select = false,
      SelectProps,
      type,
      value,
      variant = "outlined"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$Y);
    const ownerState = _extends$1({}, props, {
      autoFocus,
      color: color2,
      disabled,
      error,
      fullWidth,
      multiline,
      required,
      select,
      variant
    });
    const classes = useUtilityClasses$M(ownerState);
    const InputMore = {};
    if (variant === "outlined") {
      if (InputLabelProps && typeof InputLabelProps.shrink !== "undefined") {
        InputMore.notched = InputLabelProps.shrink;
      }
      InputMore.label = label;
    }
    if (select) {
      if (!SelectProps || !SelectProps.native) {
        InputMore.id = void 0;
      }
      InputMore["aria-describedby"] = void 0;
    }
    const id2 = useId(idOverride);
    const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
    const inputLabelId = label && id2 ? `${id2}-label` : void 0;
    const InputComponent = variantComponent[variant];
    const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(InputComponent, _extends$1({
      "aria-describedby": helperTextId,
      autoComplete,
      autoFocus,
      defaultValue,
      fullWidth,
      multiline,
      name,
      rows,
      maxRows,
      minRows,
      type,
      value,
      id: id2,
      inputRef,
      onBlur,
      onChange,
      onFocus,
      placeholder,
      inputProps
    }, InputMore, InputProps));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TextFieldRoot, _extends$1({
      className: clsx(classes.root, className),
      disabled,
      error,
      fullWidth,
      ref,
      required,
      color: color2,
      variant,
      ownerState
    }, other, {
      children: [label != null && label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, _extends$1({
        htmlFor: id2,
        id: inputLabelId
      }, InputLabelProps, {
        children: label
      })), select ? /* @__PURE__ */ jsxRuntimeExports.jsx(Select, _extends$1({
        "aria-describedby": helperTextId,
        id: id2,
        labelId: inputLabelId,
        value,
        input: InputElement
      }, SelectProps, {
        children
      })) : InputElement, helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText, _extends$1({
        id: helperTextId
      }, FormHelperTextProps, {
        children: helperText
      }))]
    }));
  });
  const _excluded$X = ["localeText"];
  const MuiPickersAdapterContext = /* @__PURE__ */ reactExports.createContext(null);
  const LocalizationProvider = function LocalizationProvider2(inProps) {
    const {
      localeText: inLocaleText
    } = inProps, otherInProps = _objectWithoutPropertiesLoose(inProps, _excluded$X);
    const {
      utils: parentUtils,
      localeText: parentLocaleText
    } = reactExports.useContext(MuiPickersAdapterContext) ?? {
      utils: void 0,
      localeText: void 0
    };
    const props = useThemeProps({
      // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
      // We will then merge this theme value with our value manually
      props: otherInProps,
      name: "MuiLocalizationProvider"
    });
    const {
      children,
      dateAdapter: DateAdapter,
      dateFormats,
      dateLibInstance,
      adapterLocale,
      localeText: themeLocaleText
    } = props;
    const localeText = reactExports.useMemo(() => _extends$1({}, themeLocaleText, parentLocaleText, inLocaleText), [themeLocaleText, parentLocaleText, inLocaleText]);
    const utils2 = reactExports.useMemo(() => {
      if (!DateAdapter) {
        if (parentUtils) {
          return parentUtils;
        }
        return null;
      }
      const adapter = new DateAdapter({
        locale: adapterLocale,
        formats: dateFormats,
        instance: dateLibInstance
      });
      if (!adapter.isMUIAdapter) {
        throw new Error(["MUI X: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`", "For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`", "More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join(`
`));
      }
      return adapter;
    }, [DateAdapter, adapterLocale, dateFormats, dateLibInstance, parentUtils]);
    const defaultDates = reactExports.useMemo(() => {
      if (!utils2) {
        return null;
      }
      return {
        minDate: utils2.date("1900-01-01T00:00:00.000"),
        maxDate: utils2.date("2099-12-31T00:00:00.000")
      };
    }, [utils2]);
    const contextValue = reactExports.useMemo(() => {
      return {
        utils: utils2,
        defaultDates,
        localeText
      };
    }, [defaultDates, utils2, localeText]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MuiPickersAdapterContext.Provider, {
      value: contextValue,
      children
    });
  };
  const getPickersLocalization = (pickersTranslations) => {
    return {
      components: {
        MuiLocalizationProvider: {
          defaultProps: {
            localeText: _extends$1({}, pickersTranslations)
          }
        }
      }
    };
  };
  const enUSPickers = {
    // Calendar navigation
    previousMonth: "Previous month",
    nextMonth: "Next month",
    // View navigation
    openPreviousView: "Open previous view",
    openNextView: "Open next view",
    calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view",
    // DateRange labels
    start: "Start",
    end: "End",
    startDate: "Start date",
    startTime: "Start time",
    endDate: "End date",
    endTime: "End time",
    // Action bar
    cancelButtonLabel: "Cancel",
    clearButtonLabel: "Clear",
    okButtonLabel: "OK",
    todayButtonLabel: "Today",
    // Toolbar titles
    datePickerToolbarTitle: "Select date",
    dateTimePickerToolbarTitle: "Select date & time",
    timePickerToolbarTitle: "Select time",
    dateRangePickerToolbarTitle: "Select date range",
    // Clock labels
    clockLabelText: (view, time, adapter) => `Select ${view}. ${time === null ? "No time selected" : `Selected time is ${adapter.format(time, "fullTime")}`}`,
    hoursClockNumberText: (hours) => `${hours} hours`,
    minutesClockNumberText: (minutes) => `${minutes} minutes`,
    secondsClockNumberText: (seconds) => `${seconds} seconds`,
    // Digital clock labels
    selectViewText: (view) => `Select ${view}`,
    // Calendar labels
    calendarWeekNumberHeaderLabel: "Week number",
    calendarWeekNumberHeaderText: "#",
    calendarWeekNumberAriaLabelText: (weekNumber) => `Week ${weekNumber}`,
    calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose date, selected date is ${utils2.format(value, "fullDate")}` : "Choose date",
    openTimePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose time, selected time is ${utils2.format(value, "fullTime")}` : "Choose time",
    fieldClearLabel: "Clear value",
    // Table labels
    timeTableLabel: "pick time",
    dateTableLabel: "pick date",
    // Field section placeholders
    fieldYearPlaceholder: (params) => "Y".repeat(params.digitAmount),
    fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
    fieldDayPlaceholder: () => "DD",
    fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "EEEE" : "EE",
    fieldHoursPlaceholder: () => "hh",
    fieldMinutesPlaceholder: () => "mm",
    fieldSecondsPlaceholder: () => "ss",
    fieldMeridiemPlaceholder: () => "aa",
    // View names
    year: "Year",
    month: "Month",
    day: "Day",
    weekDay: "Week day",
    hours: "Hours",
    minutes: "Minutes",
    seconds: "Seconds",
    meridiem: "Meridiem",
    // Common
    empty: "Empty"
  };
  const DEFAULT_LOCALE = enUSPickers;
  getPickersLocalization(enUSPickers);
  const useLocalizationContext = () => {
    const localization = reactExports.useContext(MuiPickersAdapterContext);
    if (localization === null) {
      throw new Error(["MUI X: Can not find the date and time pickers localization context.", "It looks like you forgot to wrap your component in LocalizationProvider.", "This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join("\n"));
    }
    if (localization.utils === null) {
      throw new Error(["MUI X: Can not find the date and time pickers adapter from its localization context.", "It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join("\n"));
    }
    const localeText = reactExports.useMemo(() => _extends$1({}, DEFAULT_LOCALE, localization.localeText), [localization.localeText]);
    return reactExports.useMemo(() => _extends$1({}, localization, {
      localeText
    }), [localization, localeText]);
  };
  const useUtils = () => useLocalizationContext().utils;
  const useDefaultDates = () => useLocalizationContext().defaultDates;
  const useNow = (timezone) => {
    const utils2 = useUtils();
    const now = reactExports.useRef();
    if (now.current === void 0) {
      now.current = utils2.date(void 0, timezone);
    }
    return now.current;
  };
  function useValidation(props, validate, isSameError, defaultErrorState) {
    const {
      value,
      onError
    } = props;
    const adapter = useLocalizationContext();
    const previousValidationErrorRef = reactExports.useRef(defaultErrorState);
    const validationError = validate({
      adapter,
      value,
      props
    });
    reactExports.useEffect(() => {
      if (onError && !isSameError(validationError, previousValidationErrorRef.current)) {
        onError(validationError, value);
      }
      previousValidationErrorRef.current = validationError;
    }, [isSameError, onError, previousValidationErrorRef, validationError, value]);
    return validationError;
  }
  const usePickersTranslations = () => useLocalizationContext().localeText;
  const expandFormat = ({
    utils: utils2,
    format
  }) => {
    let formatExpansionOverflow = 10;
    let prevFormat = format;
    let nextFormat = utils2.expandFormat(format);
    while (nextFormat !== prevFormat) {
      prevFormat = nextFormat;
      nextFormat = utils2.expandFormat(prevFormat);
      formatExpansionOverflow -= 1;
      if (formatExpansionOverflow < 0) {
        throw new Error("MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.");
      }
    }
    return nextFormat;
  };
  const getEscapedPartsFromFormat = ({
    utils: utils2,
    expandedFormat
  }) => {
    const escapedParts = [];
    const {
      start: startChar,
      end: endChar
    } = utils2.escapedCharacters;
    const regExp = new RegExp(`(\\${startChar}[^\\${endChar}]*\\${endChar})+`, "g");
    let match2 = null;
    while (match2 = regExp.exec(expandedFormat)) {
      escapedParts.push({
        start: match2.index,
        end: regExp.lastIndex - 1
      });
    }
    return escapedParts;
  };
  const getSectionPlaceholder = (utils2, timezone, localeText, sectionConfig, sectionFormat) => {
    switch (sectionConfig.type) {
      case "year": {
        return localeText.fieldYearPlaceholder({
          digitAmount: utils2.formatByString(utils2.date(void 0, timezone), sectionFormat).length,
          format: sectionFormat
        });
      }
      case "month": {
        return localeText.fieldMonthPlaceholder({
          contentType: sectionConfig.contentType,
          format: sectionFormat
        });
      }
      case "day": {
        return localeText.fieldDayPlaceholder({
          format: sectionFormat
        });
      }
      case "weekDay": {
        return localeText.fieldWeekDayPlaceholder({
          contentType: sectionConfig.contentType,
          format: sectionFormat
        });
      }
      case "hours": {
        return localeText.fieldHoursPlaceholder({
          format: sectionFormat
        });
      }
      case "minutes": {
        return localeText.fieldMinutesPlaceholder({
          format: sectionFormat
        });
      }
      case "seconds": {
        return localeText.fieldSecondsPlaceholder({
          format: sectionFormat
        });
      }
      case "meridiem": {
        return localeText.fieldMeridiemPlaceholder({
          format: sectionFormat
        });
      }
      default: {
        return sectionFormat;
      }
    }
  };
  const createSection = ({
    utils: utils2,
    timezone,
    date,
    shouldRespectLeadingZeros,
    localeText,
    localizedDigits,
    now,
    token: token2,
    startSeparator
  }) => {
    if (token2 === "") {
      throw new Error("MUI X: Should not call `commitToken` with an empty token");
    }
    const sectionConfig = getDateSectionConfigFromFormatToken(utils2, token2);
    const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils2, timezone, sectionConfig.contentType, sectionConfig.type, token2);
    const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === "digit";
    const isValidDate = date != null && utils2.isValid(date);
    let sectionValue = isValidDate ? utils2.formatByString(date, token2) : "";
    let maxLength = null;
    if (hasLeadingZerosInInput) {
      if (hasLeadingZerosInFormat) {
        maxLength = sectionValue === "" ? utils2.formatByString(now, token2).length : sectionValue.length;
      } else {
        if (sectionConfig.maxLength == null) {
          throw new Error(`MUI X: The token ${token2} should have a 'maxDigitNumber' property on it's adapter`);
        }
        maxLength = sectionConfig.maxLength;
        if (isValidDate) {
          sectionValue = applyLocalizedDigits(cleanLeadingZeros(removeLocalizedDigits(sectionValue, localizedDigits), maxLength), localizedDigits);
        }
      }
    }
    return _extends$1({}, sectionConfig, {
      format: token2,
      maxLength,
      value: sectionValue,
      placeholder: getSectionPlaceholder(utils2, timezone, localeText, sectionConfig, token2),
      hasLeadingZerosInFormat,
      hasLeadingZerosInInput,
      startSeparator,
      endSeparator: "",
      modified: false
    });
  };
  const buildSections = (params) => {
    var _a;
    const {
      utils: utils2,
      expandedFormat,
      escapedParts
    } = params;
    const now = utils2.date(void 0);
    const sections = [];
    let startSeparator = "";
    const validTokens = Object.keys(utils2.formatTokenMap).sort((a, b2) => b2.length - a.length);
    const regExpFirstWordInFormat = /^([a-zA-Z]+)/;
    const regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join("|")})*$`);
    const regExpFirstTokenInWord = new RegExp(`^(${validTokens.join("|")})`);
    const getEscapedPartOfCurrentChar = (i2) => escapedParts.find((escapeIndex) => escapeIndex.start <= i2 && escapeIndex.end >= i2);
    let i = 0;
    while (i < expandedFormat.length) {
      const escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i);
      const isEscapedChar = escapedPartOfCurrentChar != null;
      const firstWordInFormat = (_a = regExpFirstWordInFormat.exec(expandedFormat.slice(i))) == null ? void 0 : _a[1];
      if (!isEscapedChar && firstWordInFormat != null && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {
        let word = firstWordInFormat;
        while (word.length > 0) {
          const firstWord = regExpFirstTokenInWord.exec(word)[1];
          word = word.slice(firstWord.length);
          sections.push(createSection(_extends$1({}, params, {
            now,
            token: firstWord,
            startSeparator
          })));
          startSeparator = "";
        }
        i += firstWordInFormat.length;
      } else {
        const char2 = expandedFormat[i];
        const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;
        if (!isEscapeBoundary) {
          if (sections.length === 0) {
            startSeparator += char2;
          } else {
            sections[sections.length - 1].endSeparator += char2;
          }
        }
        i += 1;
      }
    }
    if (sections.length === 0 && startSeparator.length > 0) {
      sections.push({
        type: "empty",
        contentType: "letter",
        maxLength: null,
        format: "",
        value: "",
        placeholder: "",
        hasLeadingZerosInFormat: false,
        hasLeadingZerosInInput: false,
        startSeparator,
        endSeparator: "",
        modified: false
      });
    }
    return sections;
  };
  const postProcessSections = ({
    isRtl,
    formatDensity,
    sections
  }) => {
    return sections.map((section) => {
      const cleanSeparator = (separator) => {
        let cleanedSeparator = separator;
        if (isRtl && cleanedSeparator !== null && cleanedSeparator.includes(" ")) {
          cleanedSeparator = `⁩${cleanedSeparator}⁦`;
        }
        if (formatDensity === "spacious" && ["/", ".", "-"].includes(cleanedSeparator)) {
          cleanedSeparator = ` ${cleanedSeparator} `;
        }
        return cleanedSeparator;
      };
      section.startSeparator = cleanSeparator(section.startSeparator);
      section.endSeparator = cleanSeparator(section.endSeparator);
      return section;
    });
  };
  const buildSectionsFromFormat = (params) => {
    let expandedFormat = expandFormat(params);
    if (params.isRtl && params.enableAccessibleFieldDOMStructure) {
      expandedFormat = expandedFormat.split(" ").reverse().join(" ");
    }
    const escapedParts = getEscapedPartsFromFormat(_extends$1({}, params, {
      expandedFormat
    }));
    const sections = buildSections(_extends$1({}, params, {
      expandedFormat,
      escapedParts
    }));
    return postProcessSections(_extends$1({}, params, {
      sections
    }));
  };
  const useValueWithTimezone = ({
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager
  }) => {
    const utils2 = useUtils();
    const firstDefaultValue = reactExports.useRef(defaultValue);
    const inputValue = valueProp ?? firstDefaultValue.current ?? valueManager.emptyValue;
    const inputTimezone = reactExports.useMemo(() => valueManager.getTimezone(utils2, inputValue), [utils2, valueManager, inputValue]);
    const setInputTimezone = useEventCallback((newValue) => {
      if (inputTimezone == null) {
        return newValue;
      }
      return valueManager.setTimezone(utils2, inputTimezone, newValue);
    });
    const timezoneToRender = timezoneProp ?? inputTimezone ?? "default";
    const valueWithTimezoneToRender = reactExports.useMemo(() => valueManager.setTimezone(utils2, timezoneToRender, inputValue), [valueManager, utils2, timezoneToRender, inputValue]);
    const handleValueChange = useEventCallback((newValue, ...otherParams) => {
      const newValueWithInputTimezone = setInputTimezone(newValue);
      onChange == null ? void 0 : onChange(newValueWithInputTimezone, ...otherParams);
    });
    return {
      value: valueWithTimezoneToRender,
      handleValueChange,
      timezone: timezoneToRender
    };
  };
  const useControlledValueWithTimezone = ({
    name,
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange: onChangeProp,
    valueManager
  }) => {
    const [valueWithInputTimezone, setValue] = useControlled({
      name,
      state: "value",
      controlled: valueProp,
      default: defaultValue ?? valueManager.emptyValue
    });
    const onChange = useEventCallback((newValue, ...otherParams) => {
      setValue(newValue);
      onChangeProp == null ? void 0 : onChangeProp(newValue, ...otherParams);
    });
    return useValueWithTimezone({
      timezone: timezoneProp,
      value: valueWithInputTimezone,
      defaultValue: void 0,
      onChange,
      valueManager
    });
  };
  const useFieldState = (params) => {
    const utils2 = useUtils();
    const translations = usePickersTranslations();
    const adapter = useLocalizationContext();
    const isRtl = useRtl();
    const {
      valueManager,
      fieldValueManager,
      valueType,
      validator: validator2,
      internalProps,
      internalProps: {
        value: valueProp,
        defaultValue,
        referenceDate: referenceDateProp,
        onChange,
        format,
        formatDensity = "dense",
        selectedSections: selectedSectionsProp,
        onSelectedSectionsChange,
        shouldRespectLeadingZeros = false,
        timezone: timezoneProp,
        enableAccessibleFieldDOMStructure = false
      }
    } = params;
    const {
      timezone,
      value: valueFromTheOutside,
      handleValueChange
    } = useValueWithTimezone({
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange,
      valueManager
    });
    const localizedDigits = reactExports.useMemo(() => getLocalizedDigits(utils2), [utils2]);
    const sectionsValueBoundaries = reactExports.useMemo(() => getSectionsBoundaries(utils2, localizedDigits, timezone), [utils2, localizedDigits, timezone]);
    const getSectionsFromValue = reactExports.useCallback((value, fallbackSections = null) => fieldValueManager.getSectionsFromValue(utils2, value, fallbackSections, (date) => buildSectionsFromFormat({
      utils: utils2,
      timezone,
      localeText: translations,
      localizedDigits,
      format,
      date,
      formatDensity,
      shouldRespectLeadingZeros,
      enableAccessibleFieldDOMStructure,
      isRtl
    })), [fieldValueManager, format, translations, localizedDigits, isRtl, shouldRespectLeadingZeros, utils2, formatDensity, timezone, enableAccessibleFieldDOMStructure]);
    const [state, setState] = reactExports.useState(() => {
      const sections = getSectionsFromValue(valueFromTheOutside);
      const stateWithoutReferenceDate = {
        sections,
        value: valueFromTheOutside,
        referenceValue: valueManager.emptyValue,
        tempValueStrAndroid: null
      };
      const granularity = getSectionTypeGranularity(sections);
      const referenceValue = valueManager.getInitialReferenceValue({
        referenceDate: referenceDateProp,
        value: valueFromTheOutside,
        utils: utils2,
        props: internalProps,
        granularity,
        timezone
      });
      return _extends$1({}, stateWithoutReferenceDate, {
        referenceValue
      });
    });
    const [selectedSections, innerSetSelectedSections] = useControlled({
      controlled: selectedSectionsProp,
      default: null,
      name: "useField",
      state: "selectedSections"
    });
    const setSelectedSections = (newSelectedSections) => {
      innerSetSelectedSections(newSelectedSections);
      onSelectedSectionsChange == null ? void 0 : onSelectedSectionsChange(newSelectedSections);
    };
    const parsedSelectedSections = reactExports.useMemo(() => parseSelectedSections(selectedSections, state.sections), [selectedSections, state.sections]);
    const activeSectionIndex = parsedSelectedSections === "all" ? 0 : parsedSelectedSections;
    const publishValue = ({
      value,
      referenceValue,
      sections
    }) => {
      setState((prevState) => _extends$1({}, prevState, {
        sections,
        value,
        referenceValue,
        tempValueStrAndroid: null
      }));
      if (valueManager.areValuesEqual(utils2, state.value, value)) {
        return;
      }
      const context = {
        validationError: validator2({
          adapter,
          value,
          props: _extends$1({}, internalProps, {
            value,
            timezone
          })
        })
      };
      handleValueChange(value, context);
    };
    const setSectionValue = (sectionIndex, newSectionValue) => {
      const newSections = [...state.sections];
      newSections[sectionIndex] = _extends$1({}, newSections[sectionIndex], {
        value: newSectionValue,
        modified: true
      });
      return newSections;
    };
    const clearValue = () => {
      publishValue({
        value: valueManager.emptyValue,
        referenceValue: state.referenceValue,
        sections: getSectionsFromValue(valueManager.emptyValue)
      });
    };
    const clearActiveSection = () => {
      if (activeSectionIndex == null) {
        return;
      }
      const activeSection = state.sections[activeSectionIndex];
      const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
      const nonEmptySectionCountBefore = activeDateManager.getSections(state.sections).filter((section) => section.value !== "").length;
      const hasNoOtherNonEmptySections = nonEmptySectionCountBefore === (activeSection.value === "" ? 0 : 1);
      const newSections = setSectionValue(activeSectionIndex, "");
      const newActiveDate = hasNoOtherNonEmptySections ? null : utils2.getInvalidDate();
      const newValues = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
      publishValue(_extends$1({}, newValues, {
        sections: newSections
      }));
    };
    const updateValueFromValueStr = (valueStr) => {
      const parseDateStr = (dateStr, referenceDate) => {
        const date = utils2.parse(dateStr, format);
        if (date == null || !utils2.isValid(date)) {
          return null;
        }
        const sections = buildSectionsFromFormat({
          utils: utils2,
          timezone,
          localeText: translations,
          localizedDigits,
          format,
          date,
          formatDensity,
          shouldRespectLeadingZeros,
          enableAccessibleFieldDOMStructure,
          isRtl
        });
        return mergeDateIntoReferenceDate(utils2, timezone, date, sections, referenceDate, false);
      };
      const newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);
      const newReferenceValue = fieldValueManager.updateReferenceValue(utils2, newValue, state.referenceValue);
      publishValue({
        value: newValue,
        referenceValue: newReferenceValue,
        sections: getSectionsFromValue(newValue, state.sections)
      });
    };
    const updateSectionValue = ({
      activeSection,
      newSectionValue,
      shouldGoToNextSection
    }) => {
      if (shouldGoToNextSection && activeSectionIndex < state.sections.length - 1) {
        setSelectedSections(activeSectionIndex + 1);
      }
      const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
      const newSections = setSectionValue(activeSectionIndex, newSectionValue);
      const newActiveDateSections = activeDateManager.getSections(newSections);
      const newActiveDate = getDateFromDateSections(utils2, newActiveDateSections, localizedDigits);
      let values2;
      let shouldPublish;
      if (newActiveDate != null && utils2.isValid(newActiveDate)) {
        const mergedDate = mergeDateIntoReferenceDate(utils2, timezone, newActiveDate, newActiveDateSections, activeDateManager.referenceDate, true);
        values2 = activeDateManager.getNewValuesFromNewActiveDate(mergedDate);
        shouldPublish = true;
      } else {
        values2 = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
        shouldPublish = (newActiveDate != null && !utils2.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils2.isValid(activeDateManager.date));
      }
      if (shouldPublish) {
        return publishValue(_extends$1({}, values2, {
          sections: newSections
        }));
      }
      return setState((prevState) => _extends$1({}, prevState, values2, {
        sections: newSections,
        tempValueStrAndroid: null
      }));
    };
    const setTempAndroidValueStr = (tempValueStrAndroid) => setState((prev2) => _extends$1({}, prev2, {
      tempValueStrAndroid
    }));
    reactExports.useEffect(() => {
      const sections = getSectionsFromValue(state.value);
      setState((prevState) => _extends$1({}, prevState, {
        sections
      }));
    }, [format, utils2.locale, isRtl]);
    reactExports.useEffect(() => {
      let shouldUpdate;
      if (!valueManager.areValuesEqual(utils2, state.value, valueFromTheOutside)) {
        shouldUpdate = true;
      } else {
        shouldUpdate = valueManager.getTimezone(utils2, state.value) !== valueManager.getTimezone(utils2, valueFromTheOutside);
      }
      if (shouldUpdate) {
        setState((prevState) => _extends$1({}, prevState, {
          value: valueFromTheOutside,
          referenceValue: fieldValueManager.updateReferenceValue(utils2, valueFromTheOutside, prevState.referenceValue),
          sections: getSectionsFromValue(valueFromTheOutside)
        }));
      }
    }, [valueFromTheOutside]);
    return {
      state,
      activeSectionIndex,
      parsedSelectedSections,
      setSelectedSections,
      clearValue,
      clearActiveSection,
      updateSectionValue,
      updateValueFromValueStr,
      setTempAndroidValueStr,
      getSectionsFromValue,
      sectionsValueBoundaries,
      localizedDigits,
      timezone
    };
  };
  const QUERY_LIFE_DURATION_MS = 5e3;
  const isQueryResponseWithoutValue = (response) => response.saveQuery != null;
  const useFieldCharacterEditing = ({
    sections,
    updateSectionValue,
    sectionsValueBoundaries,
    localizedDigits,
    setTempAndroidValueStr,
    timezone
  }) => {
    const utils2 = useUtils();
    const [query, setQuery] = reactExports.useState(null);
    const resetQuery = useEventCallback(() => setQuery(null));
    reactExports.useEffect(() => {
      var _a;
      if (query != null && ((_a = sections[query.sectionIndex]) == null ? void 0 : _a.type) !== query.sectionType) {
        resetQuery();
      }
    }, [sections, query, resetQuery]);
    reactExports.useEffect(() => {
      if (query != null) {
        const timeout = setTimeout(() => resetQuery(), QUERY_LIFE_DURATION_MS);
        return () => {
          clearTimeout(timeout);
        };
      }
      return () => {
      };
    }, [query, resetQuery]);
    const applyQuery = ({
      keyPressed,
      sectionIndex
    }, getFirstSectionValueMatchingWithQuery, isValidQueryValue) => {
      const cleanKeyPressed = keyPressed.toLowerCase();
      const activeSection = sections[sectionIndex];
      if (query != null && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {
        const concatenatedQueryValue = `${query.value}${cleanKeyPressed}`;
        const queryResponse2 = getFirstSectionValueMatchingWithQuery(concatenatedQueryValue, activeSection);
        if (!isQueryResponseWithoutValue(queryResponse2)) {
          setQuery({
            sectionIndex,
            value: concatenatedQueryValue,
            sectionType: activeSection.type
          });
          return queryResponse2;
        }
      }
      const queryResponse = getFirstSectionValueMatchingWithQuery(cleanKeyPressed, activeSection);
      if (isQueryResponseWithoutValue(queryResponse) && !queryResponse.saveQuery) {
        resetQuery();
        return null;
      }
      setQuery({
        sectionIndex,
        value: cleanKeyPressed,
        sectionType: activeSection.type
      });
      if (isQueryResponseWithoutValue(queryResponse)) {
        return null;
      }
      return queryResponse;
    };
    const applyLetterEditing = (params) => {
      const findMatchingOptions = (format, options2, queryValue) => {
        const matchingValues = options2.filter((option) => option.toLowerCase().startsWith(queryValue));
        if (matchingValues.length === 0) {
          return {
            saveQuery: false
          };
        }
        return {
          sectionValue: matchingValues[0],
          shouldGoToNextSection: matchingValues.length === 1
        };
      };
      const testQueryOnFormatAndFallbackFormat = (queryValue, activeSection, fallbackFormat, formatFallbackValue) => {
        const getOptions = (format) => getLetterEditingOptions(utils2, timezone, activeSection.type, format);
        if (activeSection.contentType === "letter") {
          return findMatchingOptions(activeSection.format, getOptions(activeSection.format), queryValue);
        }
        if (fallbackFormat && formatFallbackValue != null && getDateSectionConfigFromFormatToken(utils2, fallbackFormat).contentType === "letter") {
          const fallbackOptions = getOptions(fallbackFormat);
          const response = findMatchingOptions(fallbackFormat, fallbackOptions, queryValue);
          if (isQueryResponseWithoutValue(response)) {
            return {
              saveQuery: false
            };
          }
          return _extends$1({}, response, {
            sectionValue: formatFallbackValue(response.sectionValue, fallbackOptions)
          });
        }
        return {
          saveQuery: false
        };
      };
      const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
        switch (activeSection.type) {
          case "month": {
            const formatFallbackValue = (fallbackValue) => changeSectionValueFormat(utils2, fallbackValue, utils2.formats.month, activeSection.format);
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils2.formats.month, formatFallbackValue);
          }
          case "weekDay": {
            const formatFallbackValue = (fallbackValue, fallbackOptions) => fallbackOptions.indexOf(fallbackValue).toString();
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils2.formats.weekday, formatFallbackValue);
          }
          case "meridiem": {
            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection);
          }
          default: {
            return {
              saveQuery: false
            };
          }
        }
      };
      return applyQuery(params, getFirstSectionValueMatchingWithQuery);
    };
    const applyNumericEditing = (params) => {
      const getNewSectionValue = (queryValue, section) => {
        const cleanQueryValue = removeLocalizedDigits(queryValue, localizedDigits);
        const queryValueNumber = Number(cleanQueryValue);
        const sectionBoundaries = sectionsValueBoundaries[section.type]({
          currentDate: null,
          format: section.format,
          contentType: section.contentType
        });
        if (queryValueNumber > sectionBoundaries.maximum) {
          return {
            saveQuery: false
          };
        }
        if (queryValueNumber < sectionBoundaries.minimum) {
          return {
            saveQuery: true
          };
        }
        const shouldGoToNextSection = queryValueNumber * 10 > sectionBoundaries.maximum || cleanQueryValue.length === sectionBoundaries.maximum.toString().length;
        const newSectionValue = cleanDigitSectionValue(utils2, queryValueNumber, sectionBoundaries, localizedDigits, section);
        return {
          sectionValue: newSectionValue,
          shouldGoToNextSection
        };
      };
      const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
        if (activeSection.contentType === "digit" || activeSection.contentType === "digit-with-letter") {
          return getNewSectionValue(queryValue, activeSection);
        }
        if (activeSection.type === "month") {
          const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils2, timezone, "digit", "month", "MM");
          const response = getNewSectionValue(queryValue, {
            type: activeSection.type,
            format: "MM",
            hasLeadingZerosInFormat,
            hasLeadingZerosInInput: true,
            contentType: "digit",
            maxLength: 2
          });
          if (isQueryResponseWithoutValue(response)) {
            return response;
          }
          const formattedValue = changeSectionValueFormat(utils2, response.sectionValue, "MM", activeSection.format);
          return _extends$1({}, response, {
            sectionValue: formattedValue
          });
        }
        if (activeSection.type === "weekDay") {
          const response = getNewSectionValue(queryValue, activeSection);
          if (isQueryResponseWithoutValue(response)) {
            return response;
          }
          const formattedValue = getDaysInWeekStr(utils2, timezone, activeSection.format)[Number(response.sectionValue) - 1];
          return _extends$1({}, response, {
            sectionValue: formattedValue
          });
        }
        return {
          saveQuery: false
        };
      };
      return applyQuery(params, getFirstSectionValueMatchingWithQuery, (queryValue) => isStringNumber(queryValue, localizedDigits));
    };
    const applyCharacterEditing = useEventCallback((params) => {
      const activeSection = sections[params.sectionIndex];
      const isNumericEditing = isStringNumber(params.keyPressed, localizedDigits);
      const response = isNumericEditing ? applyNumericEditing(_extends$1({}, params, {
        keyPressed: applyLocalizedDigits(params.keyPressed, localizedDigits)
      })) : applyLetterEditing(params);
      if (response == null) {
        setTempAndroidValueStr(null);
        return;
      }
      updateSectionValue({
        activeSection,
        newSectionValue: response.sectionValue,
        shouldGoToNextSection: response.shouldGoToNextSection
      });
    });
    return {
      applyCharacterEditing,
      resetCharacterQuery: resetQuery
    };
  };
  function arrayIncludes(array, itemOrItems) {
    if (Array.isArray(itemOrItems)) {
      return itemOrItems.every((item) => array.indexOf(item) !== -1);
    }
    return array.indexOf(itemOrItems) !== -1;
  }
  const onSpaceOrEnter = (innerFn, externalEvent) => (event) => {
    if (event.key === "Enter" || event.key === " ") {
      innerFn(event);
      event.preventDefault();
      event.stopPropagation();
    }
  };
  const getActiveElement = (root = document) => {
    const activeEl = root.activeElement;
    if (!activeEl) {
      return null;
    }
    if (activeEl.shadowRoot) {
      return getActiveElement(activeEl.shadowRoot);
    }
    return activeEl;
  };
  const DEFAULT_DESKTOP_MODE_MEDIA_QUERY = "@media (pointer: fine)";
  const useFieldV7TextField = (params) => {
    const {
      internalProps: {
        disabled,
        readOnly = false
      },
      forwardedProps: {
        sectionListRef: inSectionListRef,
        onBlur,
        onClick,
        onFocus,
        onInput,
        onPaste,
        focused: focusedProp,
        autoFocus = false
      },
      fieldValueManager,
      applyCharacterEditing,
      resetCharacterQuery,
      setSelectedSections,
      parsedSelectedSections,
      state,
      clearActiveSection,
      clearValue,
      updateSectionValue,
      updateValueFromValueStr,
      sectionOrder,
      areAllSectionsEmpty,
      sectionsValueBoundaries
    } = params;
    const sectionListRef = reactExports.useRef(null);
    const handleSectionListRef = useForkRef(inSectionListRef, sectionListRef);
    const translations = usePickersTranslations();
    const utils2 = useUtils();
    const id2 = useId();
    const [focused, setFocused] = reactExports.useState(false);
    const interactions = reactExports.useMemo(() => ({
      syncSelectionToDOM: () => {
        if (!sectionListRef.current) {
          return;
        }
        const selection = document.getSelection();
        if (!selection) {
          return;
        }
        if (parsedSelectedSections == null) {
          if (selection.rangeCount > 0 && sectionListRef.current.getRoot().contains(selection.getRangeAt(0).startContainer)) {
            selection.removeAllRanges();
          }
          if (focused) {
            sectionListRef.current.getRoot().blur();
          }
          return;
        }
        if (!sectionListRef.current.getRoot().contains(getActiveElement(document))) {
          return;
        }
        const range = new window.Range();
        let target;
        if (parsedSelectedSections === "all") {
          target = sectionListRef.current.getRoot();
        } else {
          const section = state.sections[parsedSelectedSections];
          if (section.type === "empty") {
            target = sectionListRef.current.getSectionContainer(parsedSelectedSections);
          } else {
            target = sectionListRef.current.getSectionContent(parsedSelectedSections);
          }
        }
        range.selectNodeContents(target);
        target.focus();
        selection.removeAllRanges();
        selection.addRange(range);
      },
      getActiveSectionIndexFromDOM: () => {
        const activeElement = getActiveElement(document);
        if (!activeElement || !sectionListRef.current || !sectionListRef.current.getRoot().contains(activeElement)) {
          return null;
        }
        return sectionListRef.current.getSectionIndexFromDOMElement(activeElement);
      },
      focusField: (newSelectedSections = 0) => {
        if (!sectionListRef.current) {
          return;
        }
        const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);
        setFocused(true);
        sectionListRef.current.getSectionContent(newParsedSelectedSections).focus();
      },
      setSelectedSections: (newSelectedSections) => {
        if (!sectionListRef.current) {
          return;
        }
        const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);
        const newActiveSectionIndex = newParsedSelectedSections === "all" ? 0 : newParsedSelectedSections;
        setFocused(newActiveSectionIndex !== null);
        setSelectedSections(newSelectedSections);
      },
      isFieldFocused: () => {
        const activeElement = getActiveElement(document);
        return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);
      }
    }), [parsedSelectedSections, setSelectedSections, state.sections, focused]);
    const revertDOMSectionChange = useEventCallback((sectionIndex) => {
      if (!sectionListRef.current) {
        return;
      }
      const section = state.sections[sectionIndex];
      sectionListRef.current.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;
      interactions.syncSelectionToDOM();
    });
    const handleContainerClick = useEventCallback((event, ...args) => {
      if (event.isDefaultPrevented() || !sectionListRef.current) {
        return;
      }
      setFocused(true);
      onClick == null ? void 0 : onClick(event, ...args);
      if (parsedSelectedSections === "all") {
        setTimeout(() => {
          const cursorPosition = document.getSelection().getRangeAt(0).startOffset;
          if (cursorPosition === 0) {
            setSelectedSections(sectionOrder.startIndex);
            return;
          }
          let sectionIndex = 0;
          let cursorOnStartOfSection = 0;
          while (cursorOnStartOfSection < cursorPosition && sectionIndex < state.sections.length) {
            const section = state.sections[sectionIndex];
            sectionIndex += 1;
            cursorOnStartOfSection += `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`.length;
          }
          setSelectedSections(sectionIndex - 1);
        });
      } else if (!focused) {
        setFocused(true);
        setSelectedSections(sectionOrder.startIndex);
      } else {
        const hasClickedOnASection = sectionListRef.current.getRoot().contains(event.target);
        if (!hasClickedOnASection) {
          setSelectedSections(sectionOrder.startIndex);
        }
      }
    });
    const handleContainerInput = useEventCallback((event) => {
      onInput == null ? void 0 : onInput(event);
      if (!sectionListRef.current || parsedSelectedSections !== "all") {
        return;
      }
      const target = event.target;
      const keyPressed = target.textContent ?? "";
      sectionListRef.current.getRoot().innerHTML = state.sections.map((section) => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join("");
      interactions.syncSelectionToDOM();
      if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {
        resetCharacterQuery();
        clearValue();
        setSelectedSections("all");
      } else if (keyPressed.length > 1) {
        updateValueFromValueStr(keyPressed);
      } else {
        applyCharacterEditing({
          keyPressed,
          sectionIndex: 0
        });
      }
    });
    const handleContainerPaste = useEventCallback((event) => {
      onPaste == null ? void 0 : onPaste(event);
      if (readOnly || parsedSelectedSections !== "all") {
        event.preventDefault();
        return;
      }
      const pastedValue = event.clipboardData.getData("text");
      event.preventDefault();
      resetCharacterQuery();
      updateValueFromValueStr(pastedValue);
    });
    const handleContainerFocus = useEventCallback((...args) => {
      onFocus == null ? void 0 : onFocus(...args);
      if (focused || !sectionListRef.current) {
        return;
      }
      setFocused(true);
      const isFocusInsideASection = sectionListRef.current.getSectionIndexFromDOMElement(getActiveElement(document)) != null;
      if (!isFocusInsideASection) {
        setSelectedSections(sectionOrder.startIndex);
      }
    });
    const handleContainerBlur = useEventCallback((...args) => {
      onBlur == null ? void 0 : onBlur(...args);
      setTimeout(() => {
        if (!sectionListRef.current) {
          return;
        }
        const activeElement = getActiveElement(document);
        const shouldBlur = !sectionListRef.current.getRoot().contains(activeElement);
        if (shouldBlur) {
          setFocused(false);
          setSelectedSections(null);
        }
      });
    });
    const getInputContainerClickHandler = useEventCallback((sectionIndex) => (event) => {
      if (event.isDefaultPrevented()) {
        return;
      }
      setSelectedSections(sectionIndex);
    });
    const handleInputContentMouseUp = useEventCallback((event) => {
      event.preventDefault();
    });
    const getInputContentFocusHandler = useEventCallback((sectionIndex) => () => {
      setSelectedSections(sectionIndex);
    });
    const handleInputContentPaste = useEventCallback((event) => {
      event.preventDefault();
      if (readOnly || disabled || typeof parsedSelectedSections !== "number") {
        return;
      }
      const activeSection = state.sections[parsedSelectedSections];
      const pastedValue = event.clipboardData.getData("text");
      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);
      const digitsOnly = /^[0-9]+$/.test(pastedValue);
      const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);
      const isValidPastedValue = activeSection.contentType === "letter" && lettersOnly || activeSection.contentType === "digit" && digitsOnly || activeSection.contentType === "digit-with-letter" && digitsAndLetterOnly;
      if (isValidPastedValue) {
        resetCharacterQuery();
        updateSectionValue({
          activeSection,
          newSectionValue: pastedValue,
          shouldGoToNextSection: true
        });
      } else if (!lettersOnly && !digitsOnly) {
        resetCharacterQuery();
        updateValueFromValueStr(pastedValue);
      }
    });
    const handleInputContentDragOver = useEventCallback((event) => {
      event.preventDefault();
      event.dataTransfer.dropEffect = "none";
    });
    const handleInputContentInput = useEventCallback((event) => {
      if (!sectionListRef.current) {
        return;
      }
      const target = event.target;
      const keyPressed = target.textContent ?? "";
      const sectionIndex = sectionListRef.current.getSectionIndexFromDOMElement(target);
      const section = state.sections[sectionIndex];
      if (readOnly || !sectionListRef.current) {
        revertDOMSectionChange(sectionIndex);
        return;
      }
      if (keyPressed.length === 0) {
        if (section.value === "") {
          revertDOMSectionChange(sectionIndex);
          return;
        }
        const inputType = event.nativeEvent.inputType;
        if (inputType === "insertParagraph" || inputType === "insertLineBreak") {
          revertDOMSectionChange(sectionIndex);
          return;
        }
        resetCharacterQuery();
        clearActiveSection();
        return;
      }
      applyCharacterEditing({
        keyPressed,
        sectionIndex
      });
      revertDOMSectionChange(sectionIndex);
    });
    useEnhancedEffect(() => {
      if (!focused || !sectionListRef.current) {
        return;
      }
      if (parsedSelectedSections === "all") {
        sectionListRef.current.getRoot().focus();
      } else if (typeof parsedSelectedSections === "number") {
        const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);
        if (domElement) {
          domElement.focus();
        }
      }
    }, [parsedSelectedSections, focused]);
    const sectionBoundaries = reactExports.useMemo(() => {
      return state.sections.reduce((acc, next2) => {
        acc[next2.type] = sectionsValueBoundaries[next2.type]({
          currentDate: null,
          contentType: next2.contentType,
          format: next2.format
        });
        return acc;
      }, {});
    }, [sectionsValueBoundaries, state.sections]);
    const isContainerEditable = parsedSelectedSections === "all";
    const elements = reactExports.useMemo(() => {
      return state.sections.map((section, index) => {
        const isEditable = !isContainerEditable && !disabled && !readOnly;
        return {
          container: {
            "data-sectionindex": index,
            onClick: getInputContainerClickHandler(index)
          },
          content: {
            tabIndex: isContainerEditable || index > 0 ? -1 : 0,
            contentEditable: !isContainerEditable && !disabled && !readOnly,
            role: "spinbutton",
            id: `${id2}-${section.type}`,
            "aria-labelledby": `${id2}-${section.type}`,
            "aria-readonly": readOnly,
            "aria-valuenow": getSectionValueNow(section, utils2),
            "aria-valuemin": sectionBoundaries[section.type].minimum,
            "aria-valuemax": sectionBoundaries[section.type].maximum,
            "aria-valuetext": section.value ? getSectionValueText(section, utils2) : translations.empty,
            "aria-label": translations[section.type],
            "aria-disabled": disabled,
            spellCheck: isEditable ? false : void 0,
            autoCapitalize: isEditable ? "off" : void 0,
            autoCorrect: isEditable ? "off" : void 0,
            [parseInt(reactExports.version, 10) >= 17 ? "enterKeyHint" : "enterkeyhint"]: isEditable ? "next" : void 0,
            children: section.value || section.placeholder,
            onInput: handleInputContentInput,
            onPaste: handleInputContentPaste,
            onFocus: getInputContentFocusHandler(index),
            onDragOver: handleInputContentDragOver,
            onMouseUp: handleInputContentMouseUp,
            inputMode: section.contentType === "letter" ? "text" : "numeric"
          },
          before: {
            children: section.startSeparator
          },
          after: {
            children: section.endSeparator
          }
        };
      });
    }, [state.sections, getInputContentFocusHandler, handleInputContentPaste, handleInputContentDragOver, handleInputContentInput, getInputContainerClickHandler, handleInputContentMouseUp, disabled, readOnly, isContainerEditable, translations, utils2, sectionBoundaries, id2]);
    const handleValueStrChange = useEventCallback((event) => {
      updateValueFromValueStr(event.target.value);
    });
    const valueStr = reactExports.useMemo(() => areAllSectionsEmpty ? "" : fieldValueManager.getV7HiddenInputValueFromSections(state.sections), [areAllSectionsEmpty, state.sections, fieldValueManager]);
    reactExports.useEffect(() => {
      if (sectionListRef.current == null) {
        throw new Error(["MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`", "You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.", "", "If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:", "", "<DatePicker slots={{ textField: MyCustomTextField }} />", "", "Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element"].join("\n"));
      }
      if (autoFocus && sectionListRef.current) {
        sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();
      }
    }, []);
    return {
      interactions,
      returnedValue: {
        // Forwarded
        autoFocus,
        readOnly,
        focused: focusedProp ?? focused,
        sectionListRef: handleSectionListRef,
        onBlur: handleContainerBlur,
        onClick: handleContainerClick,
        onFocus: handleContainerFocus,
        onInput: handleContainerInput,
        onPaste: handleContainerPaste,
        // Additional
        enableAccessibleFieldDOMStructure: true,
        elements,
        // TODO v7: Try to set to undefined when there is a section selected.
        tabIndex: parsedSelectedSections === 0 ? -1 : 0,
        contentEditable: isContainerEditable,
        value: valueStr,
        onChange: handleValueStrChange,
        areAllSectionsEmpty
      }
    };
  };
  const cleanString = (dirtyString) => dirtyString.replace(/[\u2066\u2067\u2068\u2069]/g, "");
  const addPositionPropertiesToSections = (sections, localizedDigits, isRtl) => {
    let position2 = 0;
    let positionInInput = isRtl ? 1 : 0;
    const newSections = [];
    for (let i = 0; i < sections.length; i += 1) {
      const section = sections[i];
      const renderedValue = getSectionVisibleValue(section, isRtl ? "input-rtl" : "input-ltr", localizedDigits);
      const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;
      const sectionLength = cleanString(sectionStr).length;
      const sectionLengthInInput = sectionStr.length;
      const cleanedValue = cleanString(renderedValue);
      const startInInput = positionInInput + (cleanedValue === "" ? 0 : renderedValue.indexOf(cleanedValue[0])) + section.startSeparator.length;
      const endInInput = startInInput + cleanedValue.length;
      newSections.push(_extends$1({}, section, {
        start: position2,
        end: position2 + sectionLength,
        startInInput,
        endInInput
      }));
      position2 += sectionLength;
      positionInInput += sectionLengthInInput;
    }
    return newSections;
  };
  const useFieldV6TextField = (params) => {
    const isRtl = useRtl();
    const focusTimeoutRef = reactExports.useRef();
    const selectionSyncTimeoutRef = reactExports.useRef();
    const {
      forwardedProps: {
        onFocus,
        onClick,
        onPaste,
        onBlur,
        inputRef: inputRefProp,
        placeholder: inPlaceholder
      },
      internalProps: {
        readOnly = false,
        disabled = false
      },
      parsedSelectedSections,
      activeSectionIndex,
      state,
      fieldValueManager,
      valueManager,
      applyCharacterEditing,
      resetCharacterQuery,
      updateSectionValue,
      updateValueFromValueStr,
      clearActiveSection,
      clearValue,
      setTempAndroidValueStr,
      setSelectedSections,
      getSectionsFromValue,
      areAllSectionsEmpty,
      localizedDigits
    } = params;
    const inputRef = reactExports.useRef(null);
    const handleRef = useForkRef(inputRefProp, inputRef);
    const sections = reactExports.useMemo(() => addPositionPropertiesToSections(state.sections, localizedDigits, isRtl), [state.sections, localizedDigits, isRtl]);
    const interactions = reactExports.useMemo(() => ({
      syncSelectionToDOM: () => {
        if (!inputRef.current) {
          return;
        }
        if (parsedSelectedSections == null) {
          if (inputRef.current.scrollLeft) {
            inputRef.current.scrollLeft = 0;
          }
          return;
        }
        if (inputRef.current !== getActiveElement(document)) {
          return;
        }
        const currentScrollTop = inputRef.current.scrollTop;
        if (parsedSelectedSections === "all") {
          inputRef.current.select();
        } else {
          const selectedSection = sections[parsedSelectedSections];
          const selectionStart = selectedSection.type === "empty" ? selectedSection.startInInput - selectedSection.startSeparator.length : selectedSection.startInInput;
          const selectionEnd = selectedSection.type === "empty" ? selectedSection.endInInput + selectedSection.endSeparator.length : selectedSection.endInInput;
          if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {
            if (inputRef.current === getActiveElement(document)) {
              inputRef.current.setSelectionRange(selectionStart, selectionEnd);
            }
          }
          clearTimeout(selectionSyncTimeoutRef.current);
          selectionSyncTimeoutRef.current = setTimeout(() => {
            if (inputRef.current && inputRef.current === getActiveElement(document) && // The section might loose all selection, where `selectionStart === selectionEnd`
            // https://github.com/mui/mui-x/pull/13652
            inputRef.current.selectionStart === inputRef.current.selectionEnd && (inputRef.current.selectionStart !== selectionStart || inputRef.current.selectionEnd !== selectionEnd)) {
              interactions.syncSelectionToDOM();
            }
          });
        }
        inputRef.current.scrollTop = currentScrollTop;
      },
      getActiveSectionIndexFromDOM: () => {
        const browserStartIndex = inputRef.current.selectionStart ?? 0;
        const browserEndIndex = inputRef.current.selectionEnd ?? 0;
        if (browserStartIndex === 0 && browserEndIndex === 0) {
          return null;
        }
        const nextSectionIndex = browserStartIndex <= sections[0].startInInput ? 1 : sections.findIndex((section) => section.startInInput - section.startSeparator.length > browserStartIndex);
        return nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;
      },
      focusField: (newSelectedSection = 0) => {
        var _a;
        (_a = inputRef.current) == null ? void 0 : _a.focus();
        setSelectedSections(newSelectedSection);
      },
      setSelectedSections: (newSelectedSections) => setSelectedSections(newSelectedSections),
      isFieldFocused: () => inputRef.current === getActiveElement(document)
    }), [inputRef, parsedSelectedSections, sections, setSelectedSections]);
    const syncSelectionFromDOM = () => {
      const browserStartIndex = inputRef.current.selectionStart ?? 0;
      let nextSectionIndex;
      if (browserStartIndex <= sections[0].startInInput) {
        nextSectionIndex = 1;
      } else if (browserStartIndex >= sections[sections.length - 1].endInInput) {
        nextSectionIndex = 1;
      } else {
        nextSectionIndex = sections.findIndex((section) => section.startInInput - section.startSeparator.length > browserStartIndex);
      }
      const sectionIndex = nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;
      setSelectedSections(sectionIndex);
    };
    const handleInputFocus = useEventCallback((...args) => {
      onFocus == null ? void 0 : onFocus(...args);
      const input = inputRef.current;
      clearTimeout(focusTimeoutRef.current);
      focusTimeoutRef.current = setTimeout(() => {
        if (!input || input !== inputRef.current) {
          return;
        }
        if (activeSectionIndex != null) {
          return;
        }
        if (
          // avoid selecting all sections when focusing empty field without value
          input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length
        ) {
          setSelectedSections("all");
        } else {
          syncSelectionFromDOM();
        }
      });
    });
    const handleInputClick = useEventCallback((event, ...args) => {
      if (event.isDefaultPrevented()) {
        return;
      }
      onClick == null ? void 0 : onClick(event, ...args);
      syncSelectionFromDOM();
    });
    const handleInputPaste = useEventCallback((event) => {
      onPaste == null ? void 0 : onPaste(event);
      event.preventDefault();
      if (readOnly || disabled) {
        return;
      }
      const pastedValue = event.clipboardData.getData("text");
      if (typeof parsedSelectedSections === "number") {
        const activeSection = state.sections[parsedSelectedSections];
        const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);
        const digitsOnly = /^[0-9]+$/.test(pastedValue);
        const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);
        const isValidPastedValue = activeSection.contentType === "letter" && lettersOnly || activeSection.contentType === "digit" && digitsOnly || activeSection.contentType === "digit-with-letter" && digitsAndLetterOnly;
        if (isValidPastedValue) {
          resetCharacterQuery();
          updateSectionValue({
            activeSection,
            newSectionValue: pastedValue,
            shouldGoToNextSection: true
          });
          return;
        }
        if (lettersOnly || digitsOnly) {
          return;
        }
      }
      resetCharacterQuery();
      updateValueFromValueStr(pastedValue);
    });
    const handleContainerBlur = useEventCallback((...args) => {
      onBlur == null ? void 0 : onBlur(...args);
      setSelectedSections(null);
    });
    const handleInputChange = useEventCallback((event) => {
      if (readOnly) {
        return;
      }
      const targetValue = event.target.value;
      if (targetValue === "") {
        resetCharacterQuery();
        clearValue();
        return;
      }
      const eventData = event.nativeEvent.data;
      const shouldUseEventData = eventData && eventData.length > 1;
      const valueStr2 = shouldUseEventData ? eventData : targetValue;
      const cleanValueStr = cleanString(valueStr2);
      if (activeSectionIndex == null || shouldUseEventData) {
        updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);
        return;
      }
      let keyPressed;
      if (parsedSelectedSections === "all" && cleanValueStr.length === 1) {
        keyPressed = cleanValueStr;
      } else {
        const prevValueStr = cleanString(fieldValueManager.getV6InputValueFromSections(sections, localizedDigits, isRtl));
        let startOfDiffIndex = -1;
        let endOfDiffIndex = -1;
        for (let i = 0; i < prevValueStr.length; i += 1) {
          if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {
            startOfDiffIndex = i;
          }
          if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {
            endOfDiffIndex = i;
          }
        }
        const activeSection = sections[activeSectionIndex];
        const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;
        if (hasDiffOutsideOfActiveSection) {
          return;
        }
        const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || "").length;
        keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || "").length, activeSectionEndRelativeToNewValue);
      }
      if (keyPressed.length === 0) {
        if (isAndroid()) {
          setTempAndroidValueStr(valueStr2);
        }
        resetCharacterQuery();
        clearActiveSection();
        return;
      }
      applyCharacterEditing({
        keyPressed,
        sectionIndex: activeSectionIndex
      });
    });
    const placeholder = reactExports.useMemo(() => {
      if (inPlaceholder !== void 0) {
        return inPlaceholder;
      }
      return fieldValueManager.getV6InputValueFromSections(getSectionsFromValue(valueManager.emptyValue), localizedDigits, isRtl);
    }, [inPlaceholder, fieldValueManager, getSectionsFromValue, valueManager.emptyValue, localizedDigits, isRtl]);
    const valueStr = reactExports.useMemo(() => state.tempValueStrAndroid ?? fieldValueManager.getV6InputValueFromSections(state.sections, localizedDigits, isRtl), [state.sections, fieldValueManager, state.tempValueStrAndroid, localizedDigits, isRtl]);
    reactExports.useEffect(() => {
      if (inputRef.current && inputRef.current === getActiveElement(document)) {
        setSelectedSections("all");
      }
      return () => {
        clearTimeout(focusTimeoutRef.current);
        clearTimeout(selectionSyncTimeoutRef.current);
      };
    }, []);
    const inputMode = reactExports.useMemo(() => {
      if (activeSectionIndex == null) {
        return "text";
      }
      if (state.sections[activeSectionIndex].contentType === "letter") {
        return "text";
      }
      return "numeric";
    }, [activeSectionIndex, state.sections]);
    const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);
    const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;
    return {
      interactions,
      returnedValue: {
        // Forwarded
        readOnly,
        onBlur: handleContainerBlur,
        onClick: handleInputClick,
        onFocus: handleInputFocus,
        onPaste: handleInputPaste,
        inputRef: handleRef,
        // Additional
        enableAccessibleFieldDOMStructure: false,
        placeholder,
        inputMode,
        autoComplete: "off",
        value: shouldShowPlaceholder ? "" : valueStr,
        onChange: handleInputChange
      }
    };
  };
  const useField = (params) => {
    const utils2 = useUtils();
    const {
      internalProps,
      internalProps: {
        unstableFieldRef,
        minutesStep,
        enableAccessibleFieldDOMStructure = false,
        disabled = false,
        readOnly = false
      },
      forwardedProps: {
        onKeyDown,
        error,
        clearable,
        onClear
      },
      fieldValueManager,
      valueManager,
      validator: validator2
    } = params;
    const isRtl = useRtl();
    const stateResponse = useFieldState(params);
    const {
      state,
      activeSectionIndex,
      parsedSelectedSections,
      setSelectedSections,
      clearValue,
      clearActiveSection,
      updateSectionValue,
      setTempAndroidValueStr,
      sectionsValueBoundaries,
      localizedDigits,
      timezone
    } = stateResponse;
    const characterEditingResponse = useFieldCharacterEditing({
      sections: state.sections,
      updateSectionValue,
      sectionsValueBoundaries,
      localizedDigits,
      setTempAndroidValueStr,
      timezone
    });
    const {
      resetCharacterQuery
    } = characterEditingResponse;
    const areAllSectionsEmpty = valueManager.areValuesEqual(utils2, state.value, valueManager.emptyValue);
    const useFieldTextField = enableAccessibleFieldDOMStructure ? useFieldV7TextField : useFieldV6TextField;
    const sectionOrder = reactExports.useMemo(() => getSectionOrder(state.sections, isRtl && !enableAccessibleFieldDOMStructure), [state.sections, isRtl, enableAccessibleFieldDOMStructure]);
    const {
      returnedValue,
      interactions
    } = useFieldTextField(_extends$1({}, params, stateResponse, characterEditingResponse, {
      areAllSectionsEmpty,
      sectionOrder
    }));
    const handleContainerKeyDown = useEventCallback((event) => {
      onKeyDown == null ? void 0 : onKeyDown(event);
      if (disabled) {
        return;
      }
      switch (true) {
        case ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "a" && !event.shiftKey && !event.altKey): {
          event.preventDefault();
          setSelectedSections("all");
          break;
        }
        case event.key === "ArrowRight": {
          event.preventDefault();
          if (parsedSelectedSections == null) {
            setSelectedSections(sectionOrder.startIndex);
          } else if (parsedSelectedSections === "all") {
            setSelectedSections(sectionOrder.endIndex);
          } else {
            const nextSectionIndex = sectionOrder.neighbors[parsedSelectedSections].rightIndex;
            if (nextSectionIndex !== null) {
              setSelectedSections(nextSectionIndex);
            }
          }
          break;
        }
        case event.key === "ArrowLeft": {
          event.preventDefault();
          if (parsedSelectedSections == null) {
            setSelectedSections(sectionOrder.endIndex);
          } else if (parsedSelectedSections === "all") {
            setSelectedSections(sectionOrder.startIndex);
          } else {
            const nextSectionIndex = sectionOrder.neighbors[parsedSelectedSections].leftIndex;
            if (nextSectionIndex !== null) {
              setSelectedSections(nextSectionIndex);
            }
          }
          break;
        }
        case event.key === "Delete": {
          event.preventDefault();
          if (readOnly) {
            break;
          }
          if (parsedSelectedSections == null || parsedSelectedSections === "all") {
            clearValue();
          } else {
            clearActiveSection();
          }
          resetCharacterQuery();
          break;
        }
        case ["ArrowUp", "ArrowDown", "Home", "End", "PageUp", "PageDown"].includes(event.key): {
          event.preventDefault();
          if (readOnly || activeSectionIndex == null) {
            break;
          }
          const activeSection = state.sections[activeSectionIndex];
          const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
          const newSectionValue = adjustSectionValue(utils2, timezone, activeSection, event.key, sectionsValueBoundaries, localizedDigits, activeDateManager.date, {
            minutesStep
          });
          updateSectionValue({
            activeSection,
            newSectionValue,
            shouldGoToNextSection: false
          });
          break;
        }
      }
    });
    useEnhancedEffect(() => {
      interactions.syncSelectionToDOM();
    });
    const validationError = useValidation(_extends$1({}, internalProps, {
      value: state.value,
      timezone
    }), validator2, valueManager.isSameError, valueManager.defaultErrorState);
    const inputError = reactExports.useMemo(() => {
      if (error !== void 0) {
        return error;
      }
      return valueManager.hasError(validationError);
    }, [valueManager, validationError, error]);
    reactExports.useEffect(() => {
      if (!inputError && activeSectionIndex == null) {
        resetCharacterQuery();
      }
    }, [state.referenceValue, activeSectionIndex, inputError]);
    reactExports.useEffect(() => {
      if (state.tempValueStrAndroid != null && activeSectionIndex != null) {
        resetCharacterQuery();
        clearActiveSection();
      }
    }, [state.sections]);
    reactExports.useImperativeHandle(unstableFieldRef, () => ({
      getSections: () => state.sections,
      getActiveSectionIndex: interactions.getActiveSectionIndexFromDOM,
      setSelectedSections: interactions.setSelectedSections,
      focusField: interactions.focusField,
      isFieldFocused: interactions.isFieldFocused
    }));
    const handleClearValue = useEventCallback((event, ...args) => {
      event.preventDefault();
      onClear == null ? void 0 : onClear(event, ...args);
      clearValue();
      if (!interactions.isFieldFocused()) {
        interactions.focusField(0);
      } else {
        setSelectedSections(sectionOrder.startIndex);
      }
    });
    const commonForwardedProps = {
      onKeyDown: handleContainerKeyDown,
      onClear: handleClearValue,
      error: inputError,
      clearable: Boolean(clearable && !areAllSectionsEmpty && !readOnly && !disabled)
    };
    const commonAdditionalProps = {
      disabled,
      readOnly
    };
    return _extends$1({}, params.forwardedProps, commonForwardedProps, commonAdditionalProps, returnedValue);
  };
  const validateDate = ({
    props,
    value,
    adapter
  }) => {
    if (value === null) {
      return null;
    }
    const {
      shouldDisableDate,
      shouldDisableMonth,
      shouldDisableYear,
      disablePast,
      disableFuture,
      timezone
    } = props;
    const now = adapter.utils.date(void 0, timezone);
    const minDate = applyDefaultDate(adapter.utils, props.minDate, adapter.defaultDates.minDate);
    const maxDate = applyDefaultDate(adapter.utils, props.maxDate, adapter.defaultDates.maxDate);
    switch (true) {
      case !adapter.utils.isValid(value):
        return "invalidDate";
      case Boolean(shouldDisableDate && shouldDisableDate(value)):
        return "shouldDisableDate";
      case Boolean(shouldDisableMonth && shouldDisableMonth(value)):
        return "shouldDisableMonth";
      case Boolean(shouldDisableYear && shouldDisableYear(value)):
        return "shouldDisableYear";
      case Boolean(disableFuture && adapter.utils.isAfterDay(value, now)):
        return "disableFuture";
      case Boolean(disablePast && adapter.utils.isBeforeDay(value, now)):
        return "disablePast";
      case Boolean(minDate && adapter.utils.isBeforeDay(value, minDate)):
        return "minDate";
      case Boolean(maxDate && adapter.utils.isAfterDay(value, maxDate)):
        return "maxDate";
      default:
        return null;
    }
  };
  const validateTime = ({
    adapter,
    value,
    props
  }) => {
    if (value === null) {
      return null;
    }
    const {
      minTime,
      maxTime,
      minutesStep,
      shouldDisableTime,
      disableIgnoringDatePartForTimeValidation = false,
      disablePast,
      disableFuture,
      timezone
    } = props;
    const now = adapter.utils.date(void 0, timezone);
    const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, adapter.utils);
    switch (true) {
      case !adapter.utils.isValid(value):
        return "invalidDate";
      case Boolean(minTime && isAfter(minTime, value)):
        return "minTime";
      case Boolean(maxTime && isAfter(value, maxTime)):
        return "maxTime";
      case Boolean(disableFuture && adapter.utils.isAfter(value, now)):
        return "disableFuture";
      case Boolean(disablePast && adapter.utils.isBefore(value, now)):
        return "disablePast";
      case Boolean(shouldDisableTime && shouldDisableTime(value, "hours")):
        return "shouldDisableTime-hours";
      case Boolean(shouldDisableTime && shouldDisableTime(value, "minutes")):
        return "shouldDisableTime-minutes";
      case Boolean(shouldDisableTime && shouldDisableTime(value, "seconds")):
        return "shouldDisableTime-seconds";
      case Boolean(minutesStep && adapter.utils.getMinutes(value) % minutesStep !== 0):
        return "minutesStep";
      default:
        return null;
    }
  };
  const validateDateTime = ({
    props,
    value,
    adapter
  }) => {
    const dateValidationResult = validateDate({
      adapter,
      value,
      props
    });
    if (dateValidationResult !== null) {
      return dateValidationResult;
    }
    return validateTime({
      adapter,
      value,
      props
    });
  };
  const DATE_VALIDATION_PROP_NAMES = ["disablePast", "disableFuture", "minDate", "maxDate", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear"];
  const TIME_VALIDATION_PROP_NAMES = ["disablePast", "disableFuture", "minTime", "maxTime", "shouldDisableTime", "minutesStep", "ampm", "disableIgnoringDatePartForTimeValidation"];
  const DATE_TIME_VALIDATION_PROP_NAMES = ["minDateTime", "maxDateTime"];
  const VALIDATION_PROP_NAMES = [...DATE_VALIDATION_PROP_NAMES, ...TIME_VALIDATION_PROP_NAMES, ...DATE_TIME_VALIDATION_PROP_NAMES];
  const extractValidationProps = (props) => VALIDATION_PROP_NAMES.reduce((extractedProps, propName) => {
    if (props.hasOwnProperty(propName)) {
      extractedProps[propName] = props[propName];
    }
    return extractedProps;
  }, {});
  const SHARED_FIELD_INTERNAL_PROP_NAMES = ["value", "defaultValue", "referenceDate", "format", "formatDensity", "onChange", "timezone", "onError", "shouldRespectLeadingZeros", "selectedSections", "onSelectedSectionsChange", "unstableFieldRef", "enableAccessibleFieldDOMStructure", "disabled", "readOnly", "dateSeparator"];
  const splitFieldInternalAndForwardedProps = (props, valueType) => {
    const forwardedProps = _extends$1({}, props);
    const internalProps = {};
    const extractProp = (propName) => {
      if (forwardedProps.hasOwnProperty(propName)) {
        internalProps[propName] = forwardedProps[propName];
        delete forwardedProps[propName];
      }
    };
    SHARED_FIELD_INTERNAL_PROP_NAMES.forEach(extractProp);
    if (valueType === "date") {
      DATE_VALIDATION_PROP_NAMES.forEach(extractProp);
    } else if (valueType === "time") {
      TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
    } else if (valueType === "date-time") {
      DATE_VALIDATION_PROP_NAMES.forEach(extractProp);
      TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
      DATE_TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
    }
    return {
      forwardedProps,
      internalProps
    };
  };
  const useDefaultizedTimeField = (props) => {
    const utils2 = useUtils();
    const ampm = props.ampm ?? utils2.is12HourCycleInCurrentLocale();
    const defaultFormat = ampm ? utils2.formats.fullTime12h : utils2.formats.fullTime24h;
    return _extends$1({}, props, {
      disablePast: props.disablePast ?? false,
      disableFuture: props.disableFuture ?? false,
      format: props.format ?? defaultFormat
    });
  };
  const useDefaultizedDateTimeField = (props) => {
    const utils2 = useUtils();
    const defaultDates = useDefaultDates();
    const ampm = props.ampm ?? utils2.is12HourCycleInCurrentLocale();
    const defaultFormat = ampm ? utils2.formats.keyboardDateTime12h : utils2.formats.keyboardDateTime24h;
    return _extends$1({}, props, {
      disablePast: props.disablePast ?? false,
      disableFuture: props.disableFuture ?? false,
      format: props.format ?? defaultFormat,
      disableIgnoringDatePartForTimeValidation: Boolean(props.minDateTime || props.maxDateTime),
      minDate: applyDefaultDate(utils2, props.minDateTime ?? props.minDate, defaultDates.minDate),
      maxDate: applyDefaultDate(utils2, props.maxDateTime ?? props.maxDate, defaultDates.maxDate),
      minTime: props.minDateTime ?? props.minTime,
      maxTime: props.maxDateTime ?? props.maxTime
    });
  };
  const useDateTimeField = (inProps) => {
    const props = useDefaultizedDateTimeField(inProps);
    const {
      forwardedProps,
      internalProps
    } = splitFieldInternalAndForwardedProps(props, "date-time");
    return useField({
      forwardedProps,
      internalProps,
      valueManager: singleItemValueManager,
      fieldValueManager: singleItemFieldValueManager,
      validator: validateDateTime,
      valueType: "date-time"
    });
  };
  function getIconButtonUtilityClass(slot) {
    return generateUtilityClass("MuiIconButton", slot);
  }
  const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
  const _excluded$W = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
  const useUtilityClasses$L = (ownerState) => {
    const {
      classes,
      disabled,
      color: color2,
      edge,
      size
    } = ownerState;
    const slots = {
      root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize$1(color2)}`, edge && `edge${capitalize$1(edge)}`, `size${capitalize$1(size)}`]
    };
    return composeClasses(slots, getIconButtonUtilityClass, classes);
  };
  const IconButtonRoot = styled(ButtonBase, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize$1(ownerState.edge)}`], styles2[`size${capitalize$1(ownerState.size)}`]];
    }
  })(({
    theme,
    ownerState
  }) => _extends$1({
    textAlign: "center",
    flex: "0 0 auto",
    fontSize: theme.typography.pxToRem(24),
    padding: 8,
    borderRadius: "50%",
    overflow: "visible",
    // Explicitly set the default value to solve a bug on IE11.
    color: (theme.vars || theme).palette.action.active,
    transition: theme.transitions.create("background-color", {
      duration: theme.transitions.duration.shortest
    })
  }, !ownerState.disableRipple && {
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette.action.active, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }
  }, ownerState.edge === "start" && {
    marginLeft: ownerState.size === "small" ? -3 : -12
  }, ownerState.edge === "end" && {
    marginRight: ownerState.size === "small" ? -3 : -12
  }), ({
    theme,
    ownerState
  }) => {
    var _palette;
    const palette = (_palette = (theme.vars || theme).palette) == null ? void 0 : _palette[ownerState.color];
    return _extends$1({}, ownerState.color === "inherit" && {
      color: "inherit"
    }, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends$1({
      color: palette == null ? void 0 : palette.main
    }, !ownerState.disableRipple && {
      "&:hover": _extends$1({}, palette && {
        backgroundColor: theme.vars ? `rgba(${palette.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(palette.main, theme.palette.action.hoverOpacity)
      }, {
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      })
    }), ownerState.size === "small" && {
      padding: 5,
      fontSize: theme.typography.pxToRem(18)
    }, ownerState.size === "large" && {
      padding: 12,
      fontSize: theme.typography.pxToRem(28)
    }, {
      [`&.${iconButtonClasses.disabled}`]: {
        backgroundColor: "transparent",
        color: (theme.vars || theme).palette.action.disabled
      }
    });
  });
  const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiIconButton"
    });
    const {
      edge = false,
      children,
      className,
      color: color2 = "default",
      disabled = false,
      disableFocusRipple = false,
      size = "medium"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$W);
    const ownerState = _extends$1({}, props, {
      edge,
      color: color2,
      disabled,
      disableFocusRipple,
      size
    });
    const classes = useUtilityClasses$L(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonRoot, _extends$1({
      className: clsx(classes.root, className),
      centerRipple: true,
      focusRipple: !disableFocusRipple,
      disabled,
      ref
    }, other, {
      ownerState,
      children
    }));
  });
  function getTypographyUtilityClass(slot) {
    return generateUtilityClass("MuiTypography", slot);
  }
  generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
  const _excluded$V = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
  const useUtilityClasses$K = (ownerState) => {
    const {
      align,
      gutterBottom,
      noWrap,
      paragraph,
      variant,
      classes
    } = ownerState;
    const slots = {
      root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize$1(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
    };
    return composeClasses(slots, getTypographyUtilityClass, classes);
  };
  const TypographyRoot = styled("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize$1(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
    }
  })(({
    theme,
    ownerState
  }) => _extends$1({
    margin: 0
  }, ownerState.variant === "inherit" && {
    // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
    font: "inherit"
  }, ownerState.variant !== "inherit" && theme.typography[ownerState.variant], ownerState.align !== "inherit" && {
    textAlign: ownerState.align
  }, ownerState.noWrap && {
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, ownerState.gutterBottom && {
    marginBottom: "0.35em"
  }, ownerState.paragraph && {
    marginBottom: 16
  }));
  const defaultVariantMapping = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
  };
  const colorTransformations = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main"
  };
  const transformDeprecatedColors = (color2) => {
    return colorTransformations[color2] || color2;
  };
  const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
    const themeProps = useDefaultProps({
      props: inProps,
      name: "MuiTypography"
    });
    const color2 = transformDeprecatedColors(themeProps.color);
    const props = extendSxProp(_extends$1({}, themeProps, {
      color: color2
    }));
    const {
      align = "inherit",
      className,
      component,
      gutterBottom = false,
      noWrap = false,
      paragraph = false,
      variant = "body1",
      variantMapping = defaultVariantMapping
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$V);
    const ownerState = _extends$1({}, props, {
      align,
      color: color2,
      className,
      component,
      gutterBottom,
      noWrap,
      paragraph,
      variant,
      variantMapping
    });
    const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
    const classes = useUtilityClasses$K(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, _extends$1({
      as: Component,
      ref,
      ownerState,
      className: clsx(classes.root, className)
    }, other));
  });
  function getInputAdornmentUtilityClass(slot) {
    return generateUtilityClass("MuiInputAdornment", slot);
  }
  const inputAdornmentClasses = generateUtilityClasses("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
  var _span;
  const _excluded$U = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"];
  const overridesResolver$3 = (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`position${capitalize$1(ownerState.position)}`], ownerState.disablePointerEvents === true && styles2.disablePointerEvents, styles2[ownerState.variant]];
  };
  const useUtilityClasses$J = (ownerState) => {
    const {
      classes,
      disablePointerEvents,
      hiddenLabel,
      position: position2,
      size,
      variant
    } = ownerState;
    const slots = {
      root: ["root", disablePointerEvents && "disablePointerEvents", position2 && `position${capitalize$1(position2)}`, variant, hiddenLabel && "hiddenLabel", size && `size${capitalize$1(size)}`]
    };
    return composeClasses(slots, getInputAdornmentUtilityClass, classes);
  };
  const InputAdornmentRoot = styled("div", {
    name: "MuiInputAdornment",
    slot: "Root",
    overridesResolver: overridesResolver$3
  })(({
    theme,
    ownerState
  }) => _extends$1({
    display: "flex",
    height: "0.01em",
    // Fix IE11 flexbox alignment. To remove at some point.
    maxHeight: "2em",
    alignItems: "center",
    whiteSpace: "nowrap",
    color: (theme.vars || theme).palette.action.active
  }, ownerState.variant === "filled" && {
    // Styles applied to the root element if `variant="filled"`.
    [`&.${inputAdornmentClasses.positionStart}&:not(.${inputAdornmentClasses.hiddenLabel})`]: {
      marginTop: 16
    }
  }, ownerState.position === "start" && {
    // Styles applied to the root element if `position="start"`.
    marginRight: 8
  }, ownerState.position === "end" && {
    // Styles applied to the root element if `position="end"`.
    marginLeft: 8
  }, ownerState.disablePointerEvents === true && {
    // Styles applied to the root element if `disablePointerEvents={true}`.
    pointerEvents: "none"
  }));
  const InputAdornment = /* @__PURE__ */ reactExports.forwardRef(function InputAdornment2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiInputAdornment"
    });
    const {
      children,
      className,
      component = "div",
      disablePointerEvents = false,
      disableTypography = false,
      position: position2,
      variant: variantProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$U);
    const muiFormControl = useFormControl() || {};
    let variant = variantProp;
    if (variantProp && muiFormControl.variant)
      ;
    if (muiFormControl && !variant) {
      variant = muiFormControl.variant;
    }
    const ownerState = _extends$1({}, props, {
      hiddenLabel: muiFormControl.hiddenLabel,
      size: muiFormControl.size,
      disablePointerEvents,
      position: position2,
      variant
    });
    const classes = useUtilityClasses$J(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
      value: null,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornmentRoot, _extends$1({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other, {
        children: typeof children === "string" && !disableTypography ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
          color: "text.secondary",
          children
        }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [position2 === "start" ? (
            /* notranslate needed while Google Translate will not fix zero-width space issue */
            _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
              className: "notranslate",
              children: "​"
            }))
          ) : null, children]
        })
      }))
    });
  });
  const ArrowDropDownIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M7 10l5 5 5-5z"
  }), "ArrowDropDown");
  const ArrowLeftIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
  }), "ArrowLeft");
  const ArrowRightIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
  }), "ArrowRight");
  const CalendarIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
  }), "Calendar");
  const ClockIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
    })]
  }), "Clock");
  const DateRangeIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
  }), "DateRange");
  const TimeIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
    })]
  }), "Time");
  const ClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
  }), "Clear");
  const _excluded$T = ["clearable", "onClear", "InputProps", "sx", "slots", "slotProps"], _excluded2$8 = ["ownerState"];
  const useClearableField = (props) => {
    const translations = usePickersTranslations();
    const {
      clearable,
      onClear,
      InputProps,
      sx,
      slots,
      slotProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$T);
    const IconButton$1 = (slots == null ? void 0 : slots.clearButton) ?? IconButton;
    const _useSlotProps = useSlotProps({
      elementType: IconButton$1,
      externalSlotProps: slotProps == null ? void 0 : slotProps.clearButton,
      ownerState: {},
      className: "clearButton",
      additionalProps: {
        title: translations.fieldClearLabel
      }
    }), iconButtonProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$8);
    const EndClearIcon = (slots == null ? void 0 : slots.clearIcon) ?? ClearIcon;
    const endClearIconProps = useSlotProps({
      elementType: EndClearIcon,
      externalSlotProps: slotProps == null ? void 0 : slotProps.clearIcon,
      ownerState: {}
    });
    return _extends$1({}, other, {
      InputProps: _extends$1({}, InputProps, {
        endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [clearable && /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment, {
            position: "end",
            sx: {
              marginRight: (InputProps == null ? void 0 : InputProps.endAdornment) ? -1 : -1.5
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, _extends$1({}, iconButtonProps, {
              onClick: onClear,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(EndClearIcon, _extends$1({
                fontSize: "small"
              }, endClearIconProps))
            }))
          }), InputProps == null ? void 0 : InputProps.endAdornment]
        })
      }),
      sx: [{
        "& .clearButton": {
          opacity: 1
        },
        "@media (pointer: fine)": {
          "& .clearButton": {
            opacity: 0
          },
          "&:hover, &:focus-within": {
            ".clearButton": {
              opacity: 1
            }
          }
        }
      }, ...Array.isArray(sx) ? sx : [sx]]
    });
  };
  function getPickersTextFieldUtilityClass(slot) {
    return generateUtilityClass("MuiPickersTextField", slot);
  }
  generateUtilityClasses("MuiPickersTextField", ["root", "focused", "disabled", "error", "required"]);
  function getPickersInputBaseUtilityClass(slot) {
    return generateUtilityClass("MuiPickersInputBase", slot);
  }
  const pickersInputBaseClasses = generateUtilityClasses("MuiPickersInputBase", ["root", "focused", "disabled", "error", "notchedOutline", "sectionContent", "sectionBefore", "sectionAfter", "adornedStart", "adornedEnd", "input"]);
  function getPickersSectionListUtilityClass(slot) {
    return generateUtilityClass("MuiPickersSectionList", slot);
  }
  const pickersSectionListClasses = generateUtilityClasses("MuiPickersSectionList", ["root", "section", "sectionContent"]);
  const _excluded$S = ["slots", "slotProps", "elements", "sectionListRef"];
  const PickersSectionListRoot = styled("div", {
    name: "MuiPickersSectionList",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    direction: "ltr /*! @noflip */",
    outline: "none"
  });
  const PickersSectionListSection = styled("span", {
    name: "MuiPickersSectionList",
    slot: "Section",
    overridesResolver: (props, styles2) => styles2.section
  })({});
  const PickersSectionListSectionSeparator = styled("span", {
    name: "MuiPickersSectionList",
    slot: "SectionSeparator",
    overridesResolver: (props, styles2) => styles2.sectionSeparator
  })({
    whiteSpace: "pre"
  });
  const PickersSectionListSectionContent = styled("span", {
    name: "MuiPickersSectionList",
    slot: "SectionContent",
    overridesResolver: (props, styles2) => styles2.sectionContent
  })({
    outline: "none"
  });
  const useUtilityClasses$I = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      section: ["section"],
      sectionContent: ["sectionContent"]
    };
    return composeClasses(slots, getPickersSectionListUtilityClass, classes);
  };
  function PickersSection(props) {
    const {
      slots,
      slotProps,
      element,
      classes
    } = props;
    const Section = (slots == null ? void 0 : slots.section) ?? PickersSectionListSection;
    const sectionProps = useSlotProps({
      elementType: Section,
      externalSlotProps: slotProps == null ? void 0 : slotProps.section,
      externalForwardedProps: element.container,
      className: classes.section,
      ownerState: {}
    });
    const SectionContent = (slots == null ? void 0 : slots.sectionContent) ?? PickersSectionListSectionContent;
    const sectionContentProps = useSlotProps({
      elementType: SectionContent,
      externalSlotProps: slotProps == null ? void 0 : slotProps.sectionContent,
      externalForwardedProps: element.content,
      additionalProps: {
        suppressContentEditableWarning: true
      },
      className: classes.sectionContent,
      ownerState: {}
    });
    const SectionSeparator = (slots == null ? void 0 : slots.sectionSeparator) ?? PickersSectionListSectionSeparator;
    const sectionSeparatorBeforeProps = useSlotProps({
      elementType: SectionSeparator,
      externalSlotProps: slotProps == null ? void 0 : slotProps.sectionSeparator,
      externalForwardedProps: element.before,
      ownerState: {
        position: "before"
      }
    });
    const sectionSeparatorAfterProps = useSlotProps({
      elementType: SectionSeparator,
      externalSlotProps: slotProps == null ? void 0 : slotProps.sectionSeparator,
      externalForwardedProps: element.after,
      ownerState: {
        position: "after"
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, _extends$1({}, sectionProps, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SectionSeparator, _extends$1({}, sectionSeparatorBeforeProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(SectionContent, _extends$1({}, sectionContentProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(SectionSeparator, _extends$1({}, sectionSeparatorAfterProps))]
    }));
  }
  const PickersSectionList = /* @__PURE__ */ reactExports.forwardRef(function PickersSectionList2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersSectionList"
    });
    const {
      slots,
      slotProps,
      elements,
      sectionListRef
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$S);
    const classes = useUtilityClasses$I(props);
    const rootRef = reactExports.useRef(null);
    const handleRootRef = useForkRef(ref, rootRef);
    const getRoot = (methodName) => {
      if (!rootRef.current) {
        throw new Error(`MUI X: Cannot call sectionListRef.${methodName} before the mount of the component.`);
      }
      return rootRef.current;
    };
    reactExports.useImperativeHandle(sectionListRef, () => ({
      getRoot() {
        return getRoot("getRoot");
      },
      getSectionContainer(index) {
        const root = getRoot("getSectionContainer");
        return root.querySelector(`.${pickersSectionListClasses.section}[data-sectionindex="${index}"]`);
      },
      getSectionContent(index) {
        const root = getRoot("getSectionContent");
        return root.querySelector(`.${pickersSectionListClasses.section}[data-sectionindex="${index}"] .${pickersSectionListClasses.sectionContent}`);
      },
      getSectionIndexFromDOMElement(element) {
        const root = getRoot("getSectionIndexFromDOMElement");
        if (element == null || !root.contains(element)) {
          return null;
        }
        let sectionContainer = null;
        if (element.classList.contains(pickersSectionListClasses.section)) {
          sectionContainer = element;
        } else if (element.classList.contains(pickersSectionListClasses.sectionContent)) {
          sectionContainer = element.parentElement;
        }
        if (sectionContainer == null) {
          return null;
        }
        return Number(sectionContainer.dataset.sectionindex);
      }
    }));
    const Root2 = (slots == null ? void 0 : slots.root) ?? PickersSectionListRoot;
    const rootProps = useSlotProps({
      elementType: Root2,
      externalSlotProps: slotProps == null ? void 0 : slotProps.root,
      externalForwardedProps: other,
      additionalProps: {
        ref: handleRootRef,
        suppressContentEditableWarning: true
      },
      className: classes.root,
      ownerState: {}
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2, _extends$1({}, rootProps, {
      children: rootProps.contentEditable ? elements.map(({
        content,
        before,
        after
      }) => `${before.children}${content.children}${after.children}`).join("") : /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: elements.map((element, elementIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSection, {
          slots,
          slotProps,
          element,
          classes
        }, elementIndex))
      })
    }));
  });
  const _excluded$R = ["elements", "areAllSectionsEmpty", "defaultValue", "label", "value", "onChange", "id", "autoFocus", "endAdornment", "startAdornment", "renderSuffix", "slots", "slotProps", "contentEditable", "tabIndex", "onInput", "onPaste", "onKeyDown", "fullWidth", "name", "readOnly", "inputProps", "inputRef", "sectionListRef"];
  const round$1 = (value) => Math.round(value * 1e5) / 1e5;
  const PickersInputBaseRoot = styled("div", {
    name: "MuiPickersInputBase",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })(({
    theme
  }) => _extends$1({}, theme.typography.body1, {
    color: (theme.vars || theme).palette.text.primary,
    cursor: "text",
    padding: 0,
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    boxSizing: "border-box",
    // Prevent padding issue with fullWidth.
    letterSpacing: `${round$1(0.15 / 16)}em`,
    variants: [{
      props: {
        fullWidth: true
      },
      style: {
        width: "100%"
      }
    }]
  }));
  const PickersInputBaseSectionsContainer = styled(PickersSectionListRoot, {
    name: "MuiPickersInputBase",
    slot: "SectionsContainer",
    overridesResolver: (props, styles2) => styles2.sectionsContainer
  })(({
    theme
  }) => ({
    padding: "4px 0 5px",
    fontFamily: theme.typography.fontFamily,
    fontSize: "inherit",
    lineHeight: "1.4375em",
    // 23px
    flexGrow: 1,
    outline: "none",
    display: "flex",
    flexWrap: "nowrap",
    overflow: "hidden",
    letterSpacing: "inherit",
    // Baseline behavior
    width: "182px",
    variants: [{
      props: {
        isRtl: true
      },
      style: {
        textAlign: "right /*! @noflip */"
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: {
        adornedStart: false,
        focused: false,
        filled: false
      },
      style: {
        color: "currentColor",
        opacity: 0
      }
    }, {
      // Can't use the object notation because label can be null or undefined
      props: ({
        adornedStart,
        focused,
        filled,
        label
      }) => !adornedStart && !focused && !filled && label == null,
      style: theme.vars ? {
        opacity: theme.vars.opacity.inputPlaceholder
      } : {
        opacity: theme.palette.mode === "light" ? 0.42 : 0.5
      }
    }]
  }));
  const PickersInputBaseSection = styled(PickersSectionListSection, {
    name: "MuiPickersInputBase",
    slot: "Section",
    overridesResolver: (props, styles2) => styles2.section
  })(({
    theme
  }) => ({
    fontFamily: theme.typography.fontFamily,
    fontSize: "inherit",
    letterSpacing: "inherit",
    lineHeight: "1.4375em",
    // 23px
    display: "flex"
  }));
  const PickersInputBaseSectionContent = styled(PickersSectionListSectionContent, {
    name: "MuiPickersInputBase",
    slot: "SectionContent",
    overridesResolver: (props, styles2) => styles2.content
  })(({
    theme
  }) => ({
    fontFamily: theme.typography.fontFamily,
    lineHeight: "1.4375em",
    // 23px
    letterSpacing: "inherit",
    width: "fit-content",
    outline: "none"
  }));
  const PickersInputBaseSectionSeparator = styled(PickersSectionListSectionSeparator, {
    name: "MuiPickersInputBase",
    slot: "Separator",
    overridesResolver: (props, styles2) => styles2.separator
  })(() => ({
    whiteSpace: "pre",
    letterSpacing: "inherit"
  }));
  const PickersInputBaseInput = styled("input", {
    name: "MuiPickersInputBase",
    slot: "Input",
    overridesResolver: (props, styles2) => styles2.hiddenInput
  })(_extends$1({}, visuallyHidden));
  const useUtilityClasses$H = (ownerState) => {
    const {
      focused,
      disabled,
      error,
      classes,
      fullWidth,
      readOnly,
      color: color2,
      size,
      endAdornment,
      startAdornment
    } = ownerState;
    const slots = {
      root: ["root", focused && !disabled && "focused", disabled && "disabled", readOnly && "readOnly", error && "error", fullWidth && "fullWidth", `color${capitalize$1(color2)}`, size === "small" && "inputSizeSmall", Boolean(startAdornment) && "adornedStart", Boolean(endAdornment) && "adornedEnd"],
      notchedOutline: ["notchedOutline"],
      input: ["input"],
      sectionsContainer: ["sectionsContainer"],
      sectionContent: ["sectionContent"],
      sectionBefore: ["sectionBefore"],
      sectionAfter: ["sectionAfter"]
    };
    return composeClasses(slots, getPickersInputBaseUtilityClass, classes);
  };
  const PickersInputBase = /* @__PURE__ */ reactExports.forwardRef(function PickersInputBase2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersInputBase"
    });
    const {
      elements,
      areAllSectionsEmpty,
      value,
      onChange,
      id: id2,
      endAdornment,
      startAdornment,
      renderSuffix,
      slots,
      slotProps,
      contentEditable,
      tabIndex,
      onInput,
      onPaste,
      onKeyDown,
      name,
      readOnly,
      inputProps,
      inputRef,
      sectionListRef
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$R);
    const rootRef = reactExports.useRef(null);
    const handleRootRef = useForkRef(ref, rootRef);
    const handleInputRef = useForkRef(inputProps == null ? void 0 : inputProps.ref, inputRef);
    const isRtl = useRtl();
    const muiFormControl = useFormControl();
    if (!muiFormControl) {
      throw new Error("MUI X: PickersInputBase should always be used inside a PickersTextField component");
    }
    const handleInputFocus = (event) => {
      var _a;
      if (muiFormControl.disabled) {
        event.stopPropagation();
        return;
      }
      (_a = muiFormControl.onFocus) == null ? void 0 : _a.call(muiFormControl, event);
    };
    reactExports.useEffect(() => {
      if (muiFormControl) {
        muiFormControl.setAdornedStart(Boolean(startAdornment));
      }
    }, [muiFormControl, startAdornment]);
    reactExports.useEffect(() => {
      if (!muiFormControl) {
        return;
      }
      if (areAllSectionsEmpty) {
        muiFormControl.onEmpty();
      } else {
        muiFormControl.onFilled();
      }
    }, [muiFormControl, areAllSectionsEmpty]);
    const ownerState = _extends$1({}, props, muiFormControl, {
      isRtl
    });
    const classes = useUtilityClasses$H(ownerState);
    const InputRoot2 = (slots == null ? void 0 : slots.root) || PickersInputBaseRoot;
    const inputRootProps = useSlotProps({
      elementType: InputRoot2,
      externalSlotProps: slotProps == null ? void 0 : slotProps.root,
      externalForwardedProps: other,
      additionalProps: {
        "aria-invalid": muiFormControl.error,
        ref: handleRootRef
      },
      className: classes.root,
      ownerState
    });
    const InputSectionsContainer = (slots == null ? void 0 : slots.input) || PickersInputBaseSectionsContainer;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(InputRoot2, _extends$1({}, inputRootProps, {
      children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSectionList, {
        sectionListRef,
        elements,
        contentEditable,
        tabIndex,
        className: classes.sectionsContainer,
        onFocus: handleInputFocus,
        onBlur: muiFormControl.onBlur,
        onInput,
        onPaste,
        onKeyDown,
        slots: {
          root: InputSectionsContainer,
          section: PickersInputBaseSection,
          sectionContent: PickersInputBaseSectionContent,
          sectionSeparator: PickersInputBaseSectionSeparator
        },
        slotProps: {
          root: {
            ownerState
          },
          sectionContent: {
            className: pickersInputBaseClasses.sectionContent
          },
          sectionSeparator: ({
            position: position2
          }) => ({
            className: position2 === "before" ? pickersInputBaseClasses.sectionBefore : pickersInputBaseClasses.sectionAfter
          })
        }
      }), endAdornment, renderSuffix ? renderSuffix(_extends$1({}, muiFormControl)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBaseInput, _extends$1({
        name,
        className: classes.input,
        value,
        onChange,
        id: id2,
        "aria-hidden": "true",
        tabIndex: -1,
        readOnly,
        required: muiFormControl.required,
        disabled: muiFormControl.disabled
      }, inputProps, {
        ref: handleInputRef
      }))]
    }));
  });
  function getPickersOutlinedInputUtilityClass(slot) {
    return generateUtilityClass("MuiPickersOutlinedInput", slot);
  }
  const pickersOutlinedInputClasses = _extends$1({}, pickersInputBaseClasses, generateUtilityClasses("MuiPickersOutlinedInput", ["root", "notchedOutline", "input"]));
  const _excluded$Q = ["children", "className", "label", "notched", "shrink"];
  const OutlineRoot = styled("fieldset", {
    name: "MuiPickersOutlinedInput",
    slot: "NotchedOutline",
    overridesResolver: (props, styles2) => styles2.notchedOutline
  })(({
    theme
  }) => {
    const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
      textAlign: "left",
      position: "absolute",
      bottom: 0,
      right: 0,
      top: -5,
      left: 0,
      margin: 0,
      padding: "0 8px",
      pointerEvents: "none",
      borderRadius: "inherit",
      borderStyle: "solid",
      borderWidth: 1,
      overflow: "hidden",
      minWidth: "0%",
      borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
    };
  });
  const OutlineLabel = styled("span")(({
    theme
  }) => ({
    fontFamily: theme.typography.fontFamily,
    fontSize: "inherit"
  }));
  const OutlineLegend = styled("legend")(({
    theme
  }) => ({
    float: "unset",
    // Fix conflict with bootstrap
    width: "auto",
    // Fix conflict with bootstrap
    overflow: "hidden",
    // Fix Horizontal scroll when label too long
    variants: [{
      props: {
        withLabel: false
      },
      style: {
        padding: 0,
        lineHeight: "11px",
        // sync with `height` in `legend` styles
        transition: theme.transitions.create("width", {
          duration: 150,
          easing: theme.transitions.easing.easeOut
        })
      }
    }, {
      props: {
        withLabel: true
      },
      style: {
        display: "block",
        // Fix conflict with normalize.css and sanitize.css
        padding: 0,
        height: 11,
        // sync with `lineHeight` in `legend` styles
        fontSize: "0.75em",
        visibility: "hidden",
        maxWidth: 0.01,
        transition: theme.transitions.create("max-width", {
          duration: 50,
          easing: theme.transitions.easing.easeOut
        }),
        whiteSpace: "nowrap",
        "& > span": {
          paddingLeft: 5,
          paddingRight: 5,
          display: "inline-block",
          opacity: 0,
          visibility: "visible"
        }
      }
    }, {
      props: {
        withLabel: true,
        notched: true
      },
      style: {
        maxWidth: "100%",
        transition: theme.transitions.create("max-width", {
          duration: 100,
          easing: theme.transitions.easing.easeOut,
          delay: 50
        })
      }
    }]
  }));
  function Outline(props) {
    const {
      className,
      label
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$Q);
    const withLabel = label != null && label !== "";
    const ownerState = _extends$1({}, props, {
      withLabel
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineRoot, _extends$1({
      "aria-hidden": true,
      className
    }, other, {
      ownerState,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineLegend, {
        ownerState,
        children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineLabel, {
          children: label
        }) : (
          // notranslate needed while Google Translate will not fix zero-width space issue
          /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineLabel, {
            className: "notranslate",
            children: "​"
          })
        )
      })
    }));
  }
  const _excluded$P = ["label", "autoFocus", "ownerState", "notched"];
  const PickersOutlinedInputRoot = styled(PickersInputBaseRoot, {
    name: "MuiPickersOutlinedInput",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })(({
    theme
  }) => {
    const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
      padding: "0 14px",
      borderRadius: (theme.vars || theme).shape.borderRadius,
      [`&:hover .${pickersOutlinedInputClasses.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette.text.primary
      },
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        [`&:hover .${pickersOutlinedInputClasses.notchedOutline}`]: {
          borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
        }
      },
      [`&.${pickersOutlinedInputClasses.focused} .${pickersOutlinedInputClasses.notchedOutline}`]: {
        borderStyle: "solid",
        borderWidth: 2
      },
      [`&.${pickersOutlinedInputClasses.disabled}`]: {
        [`& .${pickersOutlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.action.disabled
        },
        "*": {
          color: (theme.vars || theme).palette.action.disabled
        }
      },
      [`&.${pickersOutlinedInputClasses.error} .${pickersOutlinedInputClasses.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette.error.main
      },
      variants: Object.keys((theme.vars ?? theme).palette).filter((key) => {
        var _a;
        return ((_a = (theme.vars ?? theme).palette[key]) == null ? void 0 : _a.main) ?? false;
      }).map((color2) => ({
        props: {
          color: color2
        },
        style: {
          [`&.${pickersOutlinedInputClasses.focused}:not(.${pickersOutlinedInputClasses.error}) .${pickersOutlinedInputClasses.notchedOutline}`]: {
            // @ts-ignore
            borderColor: (theme.vars || theme).palette[color2].main
          }
        }
      }))
    };
  });
  const PickersOutlinedInputSectionsContainer = styled(PickersInputBaseSectionsContainer, {
    name: "MuiPickersOutlinedInput",
    slot: "SectionsContainer",
    overridesResolver: (props, styles2) => styles2.sectionsContainer
  })({
    padding: "16.5px 0",
    variants: [{
      props: {
        size: "small"
      },
      style: {
        padding: "8.5px 0"
      }
    }]
  });
  const useUtilityClasses$G = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      notchedOutline: ["notchedOutline"],
      input: ["input"]
    };
    const composedClasses = composeClasses(slots, getPickersOutlinedInputUtilityClass, classes);
    return _extends$1({}, classes, composedClasses);
  };
  const PickersOutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function PickersOutlinedInput2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersOutlinedInput"
    });
    const {
      label,
      ownerState: ownerStateProp,
      notched
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$P);
    const muiFormControl = useFormControl();
    const ownerState = _extends$1({}, props, ownerStateProp, muiFormControl, {
      color: (muiFormControl == null ? void 0 : muiFormControl.color) || "primary"
    });
    const classes = useUtilityClasses$G(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$1({
      slots: {
        root: PickersOutlinedInputRoot,
        input: PickersOutlinedInputSectionsContainer
      },
      renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(Outline, {
        shrink: Boolean(notched || state.adornedStart || state.focused || state.filled),
        notched: Boolean(notched || state.adornedStart || state.focused || state.filled),
        className: classes.notchedOutline,
        label: label != null && label !== "" && (muiFormControl == null ? void 0 : muiFormControl.required) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [label, " ", "*"]
        }) : label,
        ownerState
      })
    }, other, {
      label,
      classes,
      ref
    }));
  });
  PickersOutlinedInput.muiName = "Input";
  function getPickersFilledInputUtilityClass(slot) {
    return generateUtilityClass("MuiPickersFilledInput", slot);
  }
  const pickersFilledInputClasses = _extends$1({}, pickersInputBaseClasses, generateUtilityClasses("MuiPickersFilledInput", ["root", "underline", "input"]));
  const _excluded$O = ["label", "autoFocus", "disableUnderline", "ownerState"];
  const PickersFilledInputRoot = styled(PickersInputBaseRoot, {
    name: "MuiPickersFilledInput",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root,
    shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "disableUnderline"
  })(({
    theme
  }) => {
    const light2 = theme.palette.mode === "light";
    const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
    const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
    const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
      borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
      borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
      transition: theme.transitions.create("background-color", {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      "&:hover": {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
        }
      },
      [`&.${pickersFilledInputClasses.focused}`]: {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
      },
      [`&.${pickersFilledInputClasses.disabled}`]: {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
      },
      variants: [...Object.keys((theme.vars ?? theme).palette).filter((key) => (theme.vars ?? theme).palette[key].main).map((color2) => {
        var _a;
        return {
          props: {
            color: color2,
            disableUnderline: false
          },
          style: {
            "&::after": {
              // @ts-ignore
              borderBottom: `2px solid ${(_a = (theme.vars || theme).palette[color2]) == null ? void 0 : _a.main}`
            }
          }
        };
      }), {
        props: {
          disableUnderline: false
        },
        style: {
          "&::after": {
            left: 0,
            bottom: 0,
            // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
            content: '""',
            position: "absolute",
            right: 0,
            transform: "scaleX(0)",
            transition: theme.transitions.create("transform", {
              duration: theme.transitions.duration.shorter,
              easing: theme.transitions.easing.easeOut
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&.${pickersFilledInputClasses.focused}:after`]: {
            // translateX(0) is a workaround for Safari transform scale bug
            // See https://github.com/mui/material-ui/issues/31766
            transform: "scaleX(1) translateX(0)"
          },
          [`&.${pickersFilledInputClasses.error}`]: {
            "&:before, &:after": {
              borderBottomColor: (theme.vars || theme).palette.error.main
            }
          },
          "&::before": {
            borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
            left: 0,
            bottom: 0,
            // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
            content: '"\\00a0"',
            position: "absolute",
            right: 0,
            transition: theme.transitions.create("border-bottom-color", {
              duration: theme.transitions.duration.shorter
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&:hover:not(.${pickersFilledInputClasses.disabled}, .${pickersFilledInputClasses.error}):before`]: {
            borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
          },
          [`&.${pickersFilledInputClasses.disabled}:before`]: {
            borderBottomStyle: "dotted"
          }
        }
      }, {
        props: ({
          startAdornment
        }) => !!startAdornment,
        style: {
          paddingLeft: 12
        }
      }, {
        props: ({
          endAdornment
        }) => !!endAdornment,
        style: {
          paddingRight: 12
        }
      }]
    };
  });
  const PickersFilledSectionsContainer = styled(PickersInputBaseSectionsContainer, {
    name: "MuiPickersFilledInput",
    slot: "sectionsContainer",
    overridesResolver: (props, styles2) => styles2.sectionsContainer
  })({
    paddingTop: 25,
    paddingRight: 12,
    paddingBottom: 8,
    paddingLeft: 12,
    variants: [{
      props: {
        size: "small"
      },
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        startAdornment
      }) => !!startAdornment,
      style: {
        paddingLeft: 0
      }
    }, {
      props: ({
        endAdornment
      }) => !!endAdornment,
      style: {
        paddingRight: 0
      }
    }, {
      props: {
        hiddenLabel: true
      },
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: {
        hiddenLabel: true,
        size: "small"
      },
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  });
  const useUtilityClasses$F = (ownerState) => {
    const {
      classes,
      disableUnderline
    } = ownerState;
    const slots = {
      root: ["root", !disableUnderline && "underline"],
      input: ["input"]
    };
    const composedClasses = composeClasses(slots, getPickersFilledInputUtilityClass, classes);
    return _extends$1({}, classes, composedClasses);
  };
  const PickersFilledInput = /* @__PURE__ */ reactExports.forwardRef(function PickersFilledInput2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersFilledInput"
    });
    const {
      label,
      disableUnderline = false,
      ownerState: ownerStateProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$O);
    const muiFormControl = useFormControl();
    const ownerState = _extends$1({}, props, ownerStateProp, muiFormControl, {
      color: (muiFormControl == null ? void 0 : muiFormControl.color) || "primary"
    });
    const classes = useUtilityClasses$F(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$1({
      slots: {
        root: PickersFilledInputRoot,
        input: PickersFilledSectionsContainer
      },
      slotProps: {
        root: {
          disableUnderline
        }
      }
    }, other, {
      label,
      classes,
      ref
    }));
  });
  PickersFilledInput.muiName = "Input";
  function getPickersInputUtilityClass(slot) {
    return generateUtilityClass("MuiPickersFilledInput", slot);
  }
  const pickersInputClasses = _extends$1({}, pickersInputBaseClasses, generateUtilityClasses("MuiPickersInput", ["root", "input"]));
  const _excluded$N = ["label", "autoFocus", "disableUnderline", "ownerState"];
  const PickersInputRoot = styled(PickersInputBaseRoot, {
    name: "MuiPickersInput",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })(({
    theme
  }) => {
    const light2 = theme.palette.mode === "light";
    let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    if (theme.vars) {
      bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
    }
    return {
      "label + &": {
        marginTop: 16
      },
      variants: [...Object.keys((theme.vars ?? theme).palette).filter((key) => (theme.vars ?? theme).palette[key].main).map((color2) => ({
        props: {
          color: color2
        },
        style: {
          "&::after": {
            // @ts-ignore
            borderBottom: `2px solid ${(theme.vars || theme).palette[color2].main}`
          }
        }
      })), {
        props: {
          disableUnderline: false
        },
        style: {
          "&::after": {
            background: "red",
            left: 0,
            bottom: 0,
            // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
            content: '""',
            position: "absolute",
            right: 0,
            transform: "scaleX(0)",
            transition: theme.transitions.create("transform", {
              duration: theme.transitions.duration.shorter,
              easing: theme.transitions.easing.easeOut
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&.${pickersInputClasses.focused}:after`]: {
            // translateX(0) is a workaround for Safari transform scale bug
            // See https://github.com/mui/material-ui/issues/31766
            transform: "scaleX(1) translateX(0)"
          },
          [`&.${pickersInputClasses.error}`]: {
            "&:before, &:after": {
              borderBottomColor: (theme.vars || theme).palette.error.main
            }
          },
          "&::before": {
            borderBottom: `1px solid ${bottomLineColor}`,
            left: 0,
            bottom: 0,
            // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
            content: '"\\00a0"',
            position: "absolute",
            right: 0,
            transition: theme.transitions.create("border-bottom-color", {
              duration: theme.transitions.duration.shorter
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&:hover:not(.${pickersInputClasses.disabled}, .${pickersInputClasses.error}):before`]: {
            borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              borderBottom: `1px solid ${bottomLineColor}`
            }
          },
          [`&.${pickersInputClasses.disabled}:before`]: {
            borderBottomStyle: "dotted"
          }
        }
      }]
    };
  });
  const useUtilityClasses$E = (ownerState) => {
    const {
      classes,
      disableUnderline
    } = ownerState;
    const slots = {
      root: ["root", !disableUnderline && "underline"],
      input: ["input"]
    };
    const composedClasses = composeClasses(slots, getPickersInputUtilityClass, classes);
    return _extends$1({}, classes, composedClasses);
  };
  const PickersInput = /* @__PURE__ */ reactExports.forwardRef(function PickersInput2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersInput"
    });
    const {
      label,
      disableUnderline = false,
      ownerState: ownerStateProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$N);
    const muiFormControl = useFormControl();
    const ownerState = _extends$1({}, props, ownerStateProp, muiFormControl, {
      disableUnderline,
      color: (muiFormControl == null ? void 0 : muiFormControl.color) || "primary"
    });
    const classes = useUtilityClasses$E(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$1({
      slots: {
        root: PickersInputRoot
      }
    }, other, {
      label,
      classes,
      ref
    }));
  });
  PickersInput.muiName = "Input";
  const _excluded$M = ["onFocus", "onBlur", "className", "color", "disabled", "error", "variant", "required", "InputProps", "inputProps", "inputRef", "sectionListRef", "elements", "areAllSectionsEmpty", "onClick", "onKeyDown", "onKeyUp", "onPaste", "onInput", "endAdornment", "startAdornment", "tabIndex", "contentEditable", "focused", "value", "onChange", "fullWidth", "id", "name", "helperText", "FormHelperTextProps", "label", "InputLabelProps"];
  const VARIANT_COMPONENT = {
    standard: PickersInput,
    filled: PickersFilledInput,
    outlined: PickersOutlinedInput
  };
  const PickersTextFieldRoot = styled(FormControl, {
    name: "MuiPickersTextField",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const useUtilityClasses$D = (ownerState) => {
    const {
      focused,
      disabled,
      classes,
      required
    } = ownerState;
    const slots = {
      root: ["root", focused && !disabled && "focused", disabled && "disabled", required && "required"]
    };
    return composeClasses(slots, getPickersTextFieldUtilityClass, classes);
  };
  const PickersTextField = /* @__PURE__ */ reactExports.forwardRef(function PickersTextField2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersTextField"
    });
    const {
      // Props used by FormControl
      onFocus,
      onBlur,
      className,
      color: color2 = "primary",
      disabled = false,
      error = false,
      variant = "outlined",
      required = false,
      // Props used by PickersInput
      InputProps,
      inputProps,
      inputRef,
      sectionListRef,
      elements,
      areAllSectionsEmpty,
      onClick,
      onKeyDown,
      onKeyUp,
      onPaste,
      onInput,
      endAdornment,
      startAdornment,
      tabIndex,
      contentEditable,
      focused,
      value,
      onChange,
      fullWidth,
      id: idProp,
      name,
      // Props used by FormHelperText
      helperText,
      FormHelperTextProps,
      // Props used by InputLabel
      label,
      InputLabelProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$M);
    const rootRef = reactExports.useRef(null);
    const handleRootRef = useForkRef(ref, rootRef);
    const id2 = useId(idProp);
    const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
    const inputLabelId = label && id2 ? `${id2}-label` : void 0;
    const ownerState = _extends$1({}, props, {
      color: color2,
      disabled,
      error,
      focused,
      required,
      variant
    });
    const classes = useUtilityClasses$D(ownerState);
    const PickersInputComponent = VARIANT_COMPONENT[variant];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersTextFieldRoot, _extends$1({
      className: clsx(classes.root, className),
      ref: handleRootRef,
      focused,
      onFocus,
      onBlur,
      disabled,
      variant,
      error,
      color: color2,
      fullWidth,
      required,
      ownerState
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, _extends$1({
        htmlFor: id2,
        id: inputLabelId
      }, InputLabelProps, {
        children: label
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputComponent, _extends$1({
        elements,
        areAllSectionsEmpty,
        onClick,
        onKeyDown,
        onKeyUp,
        onInput,
        onPaste,
        endAdornment,
        startAdornment,
        tabIndex,
        contentEditable,
        value,
        onChange,
        id: id2,
        fullWidth,
        inputProps,
        inputRef,
        sectionListRef,
        label,
        name,
        role: "group",
        "aria-labelledby": inputLabelId
      }, InputProps)), helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText, _extends$1({
        id: helperTextId
      }, FormHelperTextProps, {
        children: helperText
      }))]
    }));
  });
  const _excluded$L = ["enableAccessibleFieldDOMStructure"], _excluded2$7 = ["InputProps", "readOnly"], _excluded3$2 = ["onPaste", "onKeyDown", "inputMode", "readOnly", "InputProps", "inputProps", "inputRef"];
  const convertFieldResponseIntoMuiTextFieldProps = (_ref) => {
    let {
      enableAccessibleFieldDOMStructure
    } = _ref, fieldResponse = _objectWithoutPropertiesLoose(_ref, _excluded$L);
    if (enableAccessibleFieldDOMStructure) {
      const {
        InputProps: InputProps2,
        readOnly: readOnly2
      } = fieldResponse, other2 = _objectWithoutPropertiesLoose(fieldResponse, _excluded2$7);
      return _extends$1({}, other2, {
        InputProps: _extends$1({}, InputProps2 ?? {}, {
          readOnly: readOnly2
        })
      });
    }
    const {
      onPaste,
      onKeyDown,
      inputMode,
      readOnly,
      InputProps,
      inputProps,
      inputRef
    } = fieldResponse, other = _objectWithoutPropertiesLoose(fieldResponse, _excluded3$2);
    return _extends$1({}, other, {
      InputProps: _extends$1({}, InputProps ?? {}, {
        readOnly
      }),
      inputProps: _extends$1({}, inputProps ?? {}, {
        inputMode,
        onPaste,
        onKeyDown,
        ref: inputRef
      })
    });
  };
  const _excluded$K = ["slots", "slotProps", "InputProps", "inputProps"];
  const DateTimeField = /* @__PURE__ */ reactExports.forwardRef(function DateTimeField2(inProps, inRef) {
    const themeProps = useThemeProps({
      props: inProps,
      name: "MuiDateTimeField"
    });
    const {
      slots,
      slotProps,
      InputProps,
      inputProps
    } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded$K);
    const ownerState = themeProps;
    const TextField$1 = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField);
    const textFieldProps = useSlotProps({
      elementType: TextField$1,
      externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
      externalForwardedProps: other,
      ownerState,
      additionalProps: {
        ref: inRef
      }
    });
    textFieldProps.inputProps = _extends$1({}, inputProps, textFieldProps.inputProps);
    textFieldProps.InputProps = _extends$1({}, InputProps, textFieldProps.InputProps);
    const fieldResponse = useDateTimeField(textFieldProps);
    const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
    const processedFieldProps = useClearableField(_extends$1({}, convertedFieldResponse, {
      slots,
      slotProps
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, _extends$1({}, processedFieldProps));
  });
  function getTabUtilityClass(slot) {
    return generateUtilityClass("MuiTab", slot);
  }
  const tabClasses = generateUtilityClasses("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper"]);
  const _excluded$J = ["className", "disabled", "disableFocusRipple", "fullWidth", "icon", "iconPosition", "indicator", "label", "onChange", "onClick", "onFocus", "selected", "selectionFollowsFocus", "textColor", "value", "wrapped"];
  const useUtilityClasses$C = (ownerState) => {
    const {
      classes,
      textColor,
      fullWidth,
      wrapped,
      icon,
      label,
      selected,
      disabled
    } = ownerState;
    const slots = {
      root: ["root", icon && label && "labelIcon", `textColor${capitalize$1(textColor)}`, fullWidth && "fullWidth", wrapped && "wrapped", selected && "selected", disabled && "disabled"],
      iconWrapper: ["iconWrapper"]
    };
    return composeClasses(slots, getTabUtilityClass, classes);
  };
  const TabRoot = styled(ButtonBase, {
    name: "MuiTab",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.label && ownerState.icon && styles2.labelIcon, styles2[`textColor${capitalize$1(ownerState.textColor)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.wrapped && styles2.wrapped, {
        [`& .${tabClasses.iconWrapper}`]: styles2.iconWrapper
      }];
    }
  })(({
    theme,
    ownerState
  }) => _extends$1({}, theme.typography.button, {
    maxWidth: 360,
    minWidth: 90,
    position: "relative",
    minHeight: 48,
    flexShrink: 0,
    padding: "12px 16px",
    overflow: "hidden",
    whiteSpace: "normal",
    textAlign: "center"
  }, ownerState.label && {
    flexDirection: ownerState.iconPosition === "top" || ownerState.iconPosition === "bottom" ? "column" : "row"
  }, {
    lineHeight: 1.25
  }, ownerState.icon && ownerState.label && {
    minHeight: 72,
    paddingTop: 9,
    paddingBottom: 9,
    [`& > .${tabClasses.iconWrapper}`]: _extends$1({}, ownerState.iconPosition === "top" && {
      marginBottom: 6
    }, ownerState.iconPosition === "bottom" && {
      marginTop: 6
    }, ownerState.iconPosition === "start" && {
      marginRight: theme.spacing(1)
    }, ownerState.iconPosition === "end" && {
      marginLeft: theme.spacing(1)
    })
  }, ownerState.textColor === "inherit" && {
    color: "inherit",
    opacity: 0.6,
    // same opacity as theme.palette.text.secondary
    [`&.${tabClasses.selected}`]: {
      opacity: 1
    },
    [`&.${tabClasses.disabled}`]: {
      opacity: (theme.vars || theme).palette.action.disabledOpacity
    }
  }, ownerState.textColor === "primary" && {
    color: (theme.vars || theme).palette.text.secondary,
    [`&.${tabClasses.selected}`]: {
      color: (theme.vars || theme).palette.primary.main
    },
    [`&.${tabClasses.disabled}`]: {
      color: (theme.vars || theme).palette.text.disabled
    }
  }, ownerState.textColor === "secondary" && {
    color: (theme.vars || theme).palette.text.secondary,
    [`&.${tabClasses.selected}`]: {
      color: (theme.vars || theme).palette.secondary.main
    },
    [`&.${tabClasses.disabled}`]: {
      color: (theme.vars || theme).palette.text.disabled
    }
  }, ownerState.fullWidth && {
    flexShrink: 1,
    flexGrow: 1,
    flexBasis: 0,
    maxWidth: "none"
  }, ownerState.wrapped && {
    fontSize: theme.typography.pxToRem(12)
  }));
  const Tab = /* @__PURE__ */ reactExports.forwardRef(function Tab2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTab"
    });
    const {
      className,
      disabled = false,
      disableFocusRipple = false,
      // eslint-disable-next-line react/prop-types
      fullWidth,
      icon: iconProp,
      iconPosition = "top",
      // eslint-disable-next-line react/prop-types
      indicator,
      label,
      onChange,
      onClick,
      onFocus,
      // eslint-disable-next-line react/prop-types
      selected,
      // eslint-disable-next-line react/prop-types
      selectionFollowsFocus,
      // eslint-disable-next-line react/prop-types
      textColor = "inherit",
      value,
      wrapped = false
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$J);
    const ownerState = _extends$1({}, props, {
      disabled,
      disableFocusRipple,
      selected,
      icon: !!iconProp,
      iconPosition,
      label: !!label,
      fullWidth,
      textColor,
      wrapped
    });
    const classes = useUtilityClasses$C(ownerState);
    const icon = iconProp && label && /* @__PURE__ */ reactExports.isValidElement(iconProp) ? /* @__PURE__ */ reactExports.cloneElement(iconProp, {
      className: clsx(classes.iconWrapper, iconProp.props.className)
    }) : iconProp;
    const handleClick = (event) => {
      if (!selected && onChange) {
        onChange(event, value);
      }
      if (onClick) {
        onClick(event);
      }
    };
    const handleFocus = (event) => {
      if (selectionFollowsFocus && !selected && onChange) {
        onChange(event, value);
      }
      if (onFocus) {
        onFocus(event);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TabRoot, _extends$1({
      focusRipple: !disableFocusRipple,
      className: clsx(classes.root, className),
      ref,
      role: "tab",
      "aria-selected": selected,
      disabled,
      onClick: handleClick,
      onFocus: handleFocus,
      ownerState,
      tabIndex: selected ? 0 : -1
    }, other, {
      children: [iconPosition === "top" || iconPosition === "start" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [icon, label]
      }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [label, icon]
      }), indicator]
    }));
  });
  function easeInOutSin(time) {
    return (1 + Math.sin(Math.PI * time - Math.PI / 2)) / 2;
  }
  function animate(property, element, to, options2 = {}, cb2 = () => {
  }) {
    const {
      ease = easeInOutSin,
      duration: duration2 = 300
      // standard
    } = options2;
    let start2 = null;
    const from2 = element[property];
    let cancelled = false;
    const cancel = () => {
      cancelled = true;
    };
    const step = (timestamp) => {
      if (cancelled) {
        cb2(new Error("Animation cancelled"));
        return;
      }
      if (start2 === null) {
        start2 = timestamp;
      }
      const time = Math.min(1, (timestamp - start2) / duration2);
      element[property] = ease(time) * (to - from2) + from2;
      if (time >= 1) {
        requestAnimationFrame(() => {
          cb2(null);
        });
        return;
      }
      requestAnimationFrame(step);
    };
    if (from2 === to) {
      cb2(new Error("Element already at target position"));
      return cancel;
    }
    requestAnimationFrame(step);
    return cancel;
  }
  const _excluded$I = ["onChange"];
  const styles = {
    width: 99,
    height: 99,
    position: "absolute",
    top: -9999,
    overflow: "scroll"
  };
  function ScrollbarSize(props) {
    const {
      onChange
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$I);
    const scrollbarHeight = reactExports.useRef();
    const nodeRef = reactExports.useRef(null);
    const setMeasurements = () => {
      scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
    };
    useEnhancedEffect(() => {
      const handleResize = debounce$1(() => {
        const prevHeight = scrollbarHeight.current;
        setMeasurements();
        if (prevHeight !== scrollbarHeight.current) {
          onChange(scrollbarHeight.current);
        }
      });
      const containerWindow = ownerWindow(nodeRef.current);
      containerWindow.addEventListener("resize", handleResize);
      return () => {
        handleResize.clear();
        containerWindow.removeEventListener("resize", handleResize);
      };
    }, [onChange]);
    reactExports.useEffect(() => {
      setMeasurements();
      onChange(scrollbarHeight.current);
    }, [onChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends$1({
      style: styles,
      ref: nodeRef
    }, other));
  }
  const KeyboardArrowLeft = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
  }), "KeyboardArrowLeft");
  const KeyboardArrowRight = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
  }), "KeyboardArrowRight");
  function getTabScrollButtonUtilityClass(slot) {
    return generateUtilityClass("MuiTabScrollButton", slot);
  }
  const tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]);
  const _excluded$H = ["className", "slots", "slotProps", "direction", "orientation", "disabled"];
  const useUtilityClasses$B = (ownerState) => {
    const {
      classes,
      orientation,
      disabled
    } = ownerState;
    const slots = {
      root: ["root", orientation, disabled && "disabled"]
    };
    return composeClasses(slots, getTabScrollButtonUtilityClass, classes);
  };
  const TabScrollButtonRoot = styled(ButtonBase, {
    name: "MuiTabScrollButton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.orientation && styles2[ownerState.orientation]];
    }
  })(({
    ownerState
  }) => _extends$1({
    width: 40,
    flexShrink: 0,
    opacity: 0.8,
    [`&.${tabScrollButtonClasses.disabled}`]: {
      opacity: 0
    }
  }, ownerState.orientation === "vertical" && {
    width: "100%",
    height: 40,
    "& svg": {
      transform: `rotate(${ownerState.isRtl ? -90 : 90}deg)`
    }
  }));
  const TabScrollButton = /* @__PURE__ */ reactExports.forwardRef(function TabScrollButton2(inProps, ref) {
    var _slots$StartScrollBut, _slots$EndScrollButto;
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTabScrollButton"
    });
    const {
      className,
      slots = {},
      slotProps = {},
      direction
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$H);
    const isRtl = useRtl();
    const ownerState = _extends$1({
      isRtl
    }, props);
    const classes = useUtilityClasses$B(ownerState);
    const StartButtonIcon = (_slots$StartScrollBut = slots.StartScrollButtonIcon) != null ? _slots$StartScrollBut : KeyboardArrowLeft;
    const EndButtonIcon = (_slots$EndScrollButto = slots.EndScrollButtonIcon) != null ? _slots$EndScrollButto : KeyboardArrowRight;
    const startButtonIconProps = useSlotProps({
      elementType: StartButtonIcon,
      externalSlotProps: slotProps.startScrollButtonIcon,
      additionalProps: {
        fontSize: "small"
      },
      ownerState
    });
    const endButtonIconProps = useSlotProps({
      elementType: EndButtonIcon,
      externalSlotProps: slotProps.endScrollButtonIcon,
      additionalProps: {
        fontSize: "small"
      },
      ownerState
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TabScrollButtonRoot, _extends$1({
      component: "div",
      className: clsx(classes.root, className),
      ref,
      role: null,
      ownerState,
      tabIndex: null
    }, other, {
      children: direction === "left" ? /* @__PURE__ */ jsxRuntimeExports.jsx(StartButtonIcon, _extends$1({}, startButtonIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(EndButtonIcon, _extends$1({}, endButtonIconProps))
    }));
  });
  function getTabsUtilityClass(slot) {
    return generateUtilityClass("MuiTabs", slot);
  }
  const tabsClasses = generateUtilityClasses("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]);
  const _excluded$G = ["aria-label", "aria-labelledby", "action", "centered", "children", "className", "component", "allowScrollButtonsMobile", "indicatorColor", "onChange", "orientation", "ScrollButtonComponent", "scrollButtons", "selectionFollowsFocus", "slots", "slotProps", "TabIndicatorProps", "TabScrollButtonProps", "textColor", "value", "variant", "visibleScrollbar"];
  const nextItem = (list, item) => {
    if (list === item) {
      return list.firstChild;
    }
    if (item && item.nextElementSibling) {
      return item.nextElementSibling;
    }
    return list.firstChild;
  };
  const previousItem = (list, item) => {
    if (list === item) {
      return list.lastChild;
    }
    if (item && item.previousElementSibling) {
      return item.previousElementSibling;
    }
    return list.lastChild;
  };
  const moveFocus = (list, currentFocus, traversalFunction) => {
    let wrappedOnce = false;
    let nextFocus = traversalFunction(list, currentFocus);
    while (nextFocus) {
      if (nextFocus === list.firstChild) {
        if (wrappedOnce) {
          return;
        }
        wrappedOnce = true;
      }
      const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
      if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
        nextFocus = traversalFunction(list, nextFocus);
      } else {
        nextFocus.focus();
        return;
      }
    }
  };
  const useUtilityClasses$A = (ownerState) => {
    const {
      vertical,
      fixed,
      hideScrollbar,
      scrollableX,
      scrollableY,
      centered,
      scrollButtonsHideMobile,
      classes
    } = ownerState;
    const slots = {
      root: ["root", vertical && "vertical"],
      scroller: ["scroller", fixed && "fixed", hideScrollbar && "hideScrollbar", scrollableX && "scrollableX", scrollableY && "scrollableY"],
      flexContainer: ["flexContainer", vertical && "flexContainerVertical", centered && "centered"],
      indicator: ["indicator"],
      scrollButtons: ["scrollButtons", scrollButtonsHideMobile && "scrollButtonsHideMobile"],
      scrollableX: [scrollableX && "scrollableX"],
      hideScrollbar: [hideScrollbar && "hideScrollbar"]
    };
    return composeClasses(slots, getTabsUtilityClass, classes);
  };
  const TabsRoot = styled("div", {
    name: "MuiTabs",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [{
        [`& .${tabsClasses.scrollButtons}`]: styles2.scrollButtons
      }, {
        [`& .${tabsClasses.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles2.scrollButtonsHideMobile
      }, styles2.root, ownerState.vertical && styles2.vertical];
    }
  })(({
    ownerState,
    theme
  }) => _extends$1({
    overflow: "hidden",
    minHeight: 48,
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: "touch",
    display: "flex"
  }, ownerState.vertical && {
    flexDirection: "column"
  }, ownerState.scrollButtonsHideMobile && {
    [`& .${tabsClasses.scrollButtons}`]: {
      [theme.breakpoints.down("sm")]: {
        display: "none"
      }
    }
  }));
  const TabsScroller = styled("div", {
    name: "MuiTabs",
    slot: "Scroller",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.scroller, ownerState.fixed && styles2.fixed, ownerState.hideScrollbar && styles2.hideScrollbar, ownerState.scrollableX && styles2.scrollableX, ownerState.scrollableY && styles2.scrollableY];
    }
  })(({
    ownerState
  }) => _extends$1({
    position: "relative",
    display: "inline-block",
    flex: "1 1 auto",
    whiteSpace: "nowrap"
  }, ownerState.fixed && {
    overflowX: "hidden",
    width: "100%"
  }, ownerState.hideScrollbar && {
    // Hide dimensionless scrollbar on macOS
    scrollbarWidth: "none",
    // Firefox
    "&::-webkit-scrollbar": {
      display: "none"
      // Safari + Chrome
    }
  }, ownerState.scrollableX && {
    overflowX: "auto",
    overflowY: "hidden"
  }, ownerState.scrollableY && {
    overflowY: "auto",
    overflowX: "hidden"
  }));
  const FlexContainer = styled("div", {
    name: "MuiTabs",
    slot: "FlexContainer",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.flexContainer, ownerState.vertical && styles2.flexContainerVertical, ownerState.centered && styles2.centered];
    }
  })(({
    ownerState
  }) => _extends$1({
    display: "flex"
  }, ownerState.vertical && {
    flexDirection: "column"
  }, ownerState.centered && {
    justifyContent: "center"
  }));
  const TabsIndicator = styled("span", {
    name: "MuiTabs",
    slot: "Indicator",
    overridesResolver: (props, styles2) => styles2.indicator
  })(({
    ownerState,
    theme
  }) => _extends$1({
    position: "absolute",
    height: 2,
    bottom: 0,
    width: "100%",
    transition: theme.transitions.create()
  }, ownerState.indicatorColor === "primary" && {
    backgroundColor: (theme.vars || theme).palette.primary.main
  }, ownerState.indicatorColor === "secondary" && {
    backgroundColor: (theme.vars || theme).palette.secondary.main
  }, ownerState.vertical && {
    height: "100%",
    width: 2,
    right: 0
  }));
  const TabsScrollbarSize = styled(ScrollbarSize)({
    overflowX: "auto",
    overflowY: "hidden",
    // Hide dimensionless scrollbar on macOS
    scrollbarWidth: "none",
    // Firefox
    "&::-webkit-scrollbar": {
      display: "none"
      // Safari + Chrome
    }
  });
  const defaultIndicatorStyle = {};
  const Tabs = /* @__PURE__ */ reactExports.forwardRef(function Tabs2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTabs"
    });
    const theme = useTheme$1();
    const isRtl = useRtl();
    const {
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      action,
      centered = false,
      children: childrenProp,
      className,
      component = "div",
      allowScrollButtonsMobile = false,
      indicatorColor = "primary",
      onChange,
      orientation = "horizontal",
      ScrollButtonComponent = TabScrollButton,
      scrollButtons = "auto",
      selectionFollowsFocus,
      slots = {},
      slotProps = {},
      TabIndicatorProps = {},
      TabScrollButtonProps = {},
      textColor = "primary",
      value,
      variant = "standard",
      visibleScrollbar = false
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$G);
    const scrollable = variant === "scrollable";
    const vertical = orientation === "vertical";
    const scrollStart = vertical ? "scrollTop" : "scrollLeft";
    const start2 = vertical ? "top" : "left";
    const end2 = vertical ? "bottom" : "right";
    const clientSize = vertical ? "clientHeight" : "clientWidth";
    const size = vertical ? "height" : "width";
    const ownerState = _extends$1({}, props, {
      component,
      allowScrollButtonsMobile,
      indicatorColor,
      orientation,
      vertical,
      scrollButtons,
      textColor,
      variant,
      visibleScrollbar,
      fixed: !scrollable,
      hideScrollbar: scrollable && !visibleScrollbar,
      scrollableX: scrollable && !vertical,
      scrollableY: scrollable && vertical,
      centered: centered && !scrollable,
      scrollButtonsHideMobile: !allowScrollButtonsMobile
    });
    const classes = useUtilityClasses$A(ownerState);
    const startScrollButtonIconProps = useSlotProps({
      elementType: slots.StartScrollButtonIcon,
      externalSlotProps: slotProps.startScrollButtonIcon,
      ownerState
    });
    const endScrollButtonIconProps = useSlotProps({
      elementType: slots.EndScrollButtonIcon,
      externalSlotProps: slotProps.endScrollButtonIcon,
      ownerState
    });
    const [mounted, setMounted] = reactExports.useState(false);
    const [indicatorStyle, setIndicatorStyle] = reactExports.useState(defaultIndicatorStyle);
    const [displayStartScroll, setDisplayStartScroll] = reactExports.useState(false);
    const [displayEndScroll, setDisplayEndScroll] = reactExports.useState(false);
    const [updateScrollObserver, setUpdateScrollObserver] = reactExports.useState(false);
    const [scrollerStyle, setScrollerStyle] = reactExports.useState({
      overflow: "hidden",
      scrollbarWidth: 0
    });
    const valueToIndex = /* @__PURE__ */ new Map();
    const tabsRef = reactExports.useRef(null);
    const tabListRef = reactExports.useRef(null);
    const getTabsMeta = () => {
      const tabsNode = tabsRef.current;
      let tabsMeta;
      if (tabsNode) {
        const rect = tabsNode.getBoundingClientRect();
        tabsMeta = {
          clientWidth: tabsNode.clientWidth,
          scrollLeft: tabsNode.scrollLeft,
          scrollTop: tabsNode.scrollTop,
          scrollLeftNormalized: getNormalizedScrollLeft(tabsNode, isRtl ? "rtl" : "ltr"),
          scrollWidth: tabsNode.scrollWidth,
          top: rect.top,
          bottom: rect.bottom,
          left: rect.left,
          right: rect.right
        };
      }
      let tabMeta;
      if (tabsNode && value !== false) {
        const children2 = tabListRef.current.children;
        if (children2.length > 0) {
          const tab = children2[valueToIndex.get(value)];
          tabMeta = tab ? tab.getBoundingClientRect() : null;
        }
      }
      return {
        tabsMeta,
        tabMeta
      };
    };
    const updateIndicatorState = useEventCallback(() => {
      const {
        tabsMeta,
        tabMeta
      } = getTabsMeta();
      let startValue = 0;
      let startIndicator;
      if (vertical) {
        startIndicator = "top";
        if (tabMeta && tabsMeta) {
          startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
        }
      } else {
        startIndicator = isRtl ? "right" : "left";
        if (tabMeta && tabsMeta) {
          const correction = isRtl ? tabsMeta.scrollLeftNormalized + tabsMeta.clientWidth - tabsMeta.scrollWidth : tabsMeta.scrollLeft;
          startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + correction);
        }
      }
      const newIndicatorStyle = {
        [startIndicator]: startValue,
        // May be wrong until the font is loaded.
        [size]: tabMeta ? tabMeta[size] : 0
      };
      if (isNaN(indicatorStyle[startIndicator]) || isNaN(indicatorStyle[size])) {
        setIndicatorStyle(newIndicatorStyle);
      } else {
        const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
        const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);
        if (dStart >= 1 || dSize >= 1) {
          setIndicatorStyle(newIndicatorStyle);
        }
      }
    });
    const scroll = (scrollValue, {
      animation = true
    } = {}) => {
      if (animation) {
        animate(scrollStart, tabsRef.current, scrollValue, {
          duration: theme.transitions.duration.standard
        });
      } else {
        tabsRef.current[scrollStart] = scrollValue;
      }
    };
    const moveTabsScroll = (delta) => {
      let scrollValue = tabsRef.current[scrollStart];
      if (vertical) {
        scrollValue += delta;
      } else {
        scrollValue += delta * (isRtl ? -1 : 1);
        scrollValue *= isRtl && detectScrollType() === "reverse" ? -1 : 1;
      }
      scroll(scrollValue);
    };
    const getScrollSize = () => {
      const containerSize = tabsRef.current[clientSize];
      let totalSize = 0;
      const children2 = Array.from(tabListRef.current.children);
      for (let i = 0; i < children2.length; i += 1) {
        const tab = children2[i];
        if (totalSize + tab[clientSize] > containerSize) {
          if (i === 0) {
            totalSize = containerSize;
          }
          break;
        }
        totalSize += tab[clientSize];
      }
      return totalSize;
    };
    const handleStartScrollClick = () => {
      moveTabsScroll(-1 * getScrollSize());
    };
    const handleEndScrollClick = () => {
      moveTabsScroll(getScrollSize());
    };
    const handleScrollbarSizeChange = reactExports.useCallback((scrollbarWidth) => {
      setScrollerStyle({
        overflow: null,
        scrollbarWidth
      });
    }, []);
    const getConditionalElements = () => {
      const conditionalElements2 = {};
      conditionalElements2.scrollbarSizeListener = scrollable ? /* @__PURE__ */ jsxRuntimeExports.jsx(TabsScrollbarSize, {
        onChange: handleScrollbarSizeChange,
        className: clsx(classes.scrollableX, classes.hideScrollbar)
      }) : null;
      const scrollButtonsActive = displayStartScroll || displayEndScroll;
      const showScrollButtons = scrollable && (scrollButtons === "auto" && scrollButtonsActive || scrollButtons === true);
      conditionalElements2.scrollButtonStart = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonComponent, _extends$1({
        slots: {
          StartScrollButtonIcon: slots.StartScrollButtonIcon
        },
        slotProps: {
          startScrollButtonIcon: startScrollButtonIconProps
        },
        orientation,
        direction: isRtl ? "right" : "left",
        onClick: handleStartScrollClick,
        disabled: !displayStartScroll
      }, TabScrollButtonProps, {
        className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
      })) : null;
      conditionalElements2.scrollButtonEnd = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonComponent, _extends$1({
        slots: {
          EndScrollButtonIcon: slots.EndScrollButtonIcon
        },
        slotProps: {
          endScrollButtonIcon: endScrollButtonIconProps
        },
        orientation,
        direction: isRtl ? "left" : "right",
        onClick: handleEndScrollClick,
        disabled: !displayEndScroll
      }, TabScrollButtonProps, {
        className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
      })) : null;
      return conditionalElements2;
    };
    const scrollSelectedIntoView = useEventCallback((animation) => {
      const {
        tabsMeta,
        tabMeta
      } = getTabsMeta();
      if (!tabMeta || !tabsMeta) {
        return;
      }
      if (tabMeta[start2] < tabsMeta[start2]) {
        const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start2] - tabsMeta[start2]);
        scroll(nextScrollStart, {
          animation
        });
      } else if (tabMeta[end2] > tabsMeta[end2]) {
        const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end2] - tabsMeta[end2]);
        scroll(nextScrollStart, {
          animation
        });
      }
    });
    const updateScrollButtonState = useEventCallback(() => {
      if (scrollable && scrollButtons !== false) {
        setUpdateScrollObserver(!updateScrollObserver);
      }
    });
    reactExports.useEffect(() => {
      const handleResize = debounce$1(() => {
        if (tabsRef.current) {
          updateIndicatorState();
        }
      });
      let resizeObserver;
      const handleMutation = (records) => {
        records.forEach((record) => {
          record.removedNodes.forEach((item) => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.unobserve(item);
          });
          record.addedNodes.forEach((item) => {
            var _resizeObserver2;
            (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.observe(item);
          });
        });
        handleResize();
        updateScrollButtonState();
      };
      const win = ownerWindow(tabsRef.current);
      win.addEventListener("resize", handleResize);
      let mutationObserver;
      if (typeof ResizeObserver !== "undefined") {
        resizeObserver = new ResizeObserver(handleResize);
        Array.from(tabListRef.current.children).forEach((child) => {
          resizeObserver.observe(child);
        });
      }
      if (typeof MutationObserver !== "undefined") {
        mutationObserver = new MutationObserver(handleMutation);
        mutationObserver.observe(tabListRef.current, {
          childList: true
        });
      }
      return () => {
        var _mutationObserver, _resizeObserver3;
        handleResize.clear();
        win.removeEventListener("resize", handleResize);
        (_mutationObserver = mutationObserver) == null || _mutationObserver.disconnect();
        (_resizeObserver3 = resizeObserver) == null || _resizeObserver3.disconnect();
      };
    }, [updateIndicatorState, updateScrollButtonState]);
    reactExports.useEffect(() => {
      const tabListChildren = Array.from(tabListRef.current.children);
      const length2 = tabListChildren.length;
      if (typeof IntersectionObserver !== "undefined" && length2 > 0 && scrollable && scrollButtons !== false) {
        const firstTab = tabListChildren[0];
        const lastTab = tabListChildren[length2 - 1];
        const observerOptions = {
          root: tabsRef.current,
          threshold: 0.99
        };
        const handleScrollButtonStart = (entries) => {
          setDisplayStartScroll(!entries[0].isIntersecting);
        };
        const firstObserver = new IntersectionObserver(handleScrollButtonStart, observerOptions);
        firstObserver.observe(firstTab);
        const handleScrollButtonEnd = (entries) => {
          setDisplayEndScroll(!entries[0].isIntersecting);
        };
        const lastObserver = new IntersectionObserver(handleScrollButtonEnd, observerOptions);
        lastObserver.observe(lastTab);
        return () => {
          firstObserver.disconnect();
          lastObserver.disconnect();
        };
      }
      return void 0;
    }, [scrollable, scrollButtons, updateScrollObserver, childrenProp == null ? void 0 : childrenProp.length]);
    reactExports.useEffect(() => {
      setMounted(true);
    }, []);
    reactExports.useEffect(() => {
      updateIndicatorState();
    });
    reactExports.useEffect(() => {
      scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
    }, [scrollSelectedIntoView, indicatorStyle]);
    reactExports.useImperativeHandle(action, () => ({
      updateIndicator: updateIndicatorState,
      updateScrollButtons: updateScrollButtonState
    }), [updateIndicatorState, updateScrollButtonState]);
    const indicator = /* @__PURE__ */ jsxRuntimeExports.jsx(TabsIndicator, _extends$1({}, TabIndicatorProps, {
      className: clsx(classes.indicator, TabIndicatorProps.className),
      ownerState,
      style: _extends$1({}, indicatorStyle, TabIndicatorProps.style)
    }));
    let childIndex = 0;
    const children = reactExports.Children.map(childrenProp, (child) => {
      if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
        return null;
      }
      const childValue = child.props.value === void 0 ? childIndex : child.props.value;
      valueToIndex.set(childValue, childIndex);
      const selected = childValue === value;
      childIndex += 1;
      return /* @__PURE__ */ reactExports.cloneElement(child, _extends$1({
        fullWidth: variant === "fullWidth",
        indicator: selected && !mounted && indicator,
        selected,
        selectionFollowsFocus,
        onChange,
        textColor,
        value: childValue
      }, childIndex === 1 && value === false && !child.props.tabIndex ? {
        tabIndex: 0
      } : {}));
    });
    const handleKeyDown2 = (event) => {
      const list = tabListRef.current;
      const currentFocus = ownerDocument(list).activeElement;
      const role = currentFocus.getAttribute("role");
      if (role !== "tab") {
        return;
      }
      let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
      let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
      if (orientation === "horizontal" && isRtl) {
        previousItemKey = "ArrowRight";
        nextItemKey = "ArrowLeft";
      }
      switch (event.key) {
        case previousItemKey:
          event.preventDefault();
          moveFocus(list, currentFocus, previousItem);
          break;
        case nextItemKey:
          event.preventDefault();
          moveFocus(list, currentFocus, nextItem);
          break;
        case "Home":
          event.preventDefault();
          moveFocus(list, null, nextItem);
          break;
        case "End":
          event.preventDefault();
          moveFocus(list, null, previousItem);
          break;
      }
    };
    const conditionalElements = getConditionalElements();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsRoot, _extends$1({
      className: clsx(classes.root, className),
      ownerState,
      ref,
      as: component
    }, other, {
      children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsScroller, {
        className: classes.scroller,
        ownerState,
        style: {
          overflow: scrollerStyle.overflow,
          [vertical ? `margin${isRtl ? "Left" : "Right"}` : "marginBottom"]: visibleScrollbar ? void 0 : -scrollerStyle.scrollbarWidth
        },
        ref: tabsRef,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(FlexContainer, {
          "aria-label": ariaLabel,
          "aria-labelledby": ariaLabelledBy,
          "aria-orientation": orientation === "vertical" ? "vertical" : null,
          className: classes.flexContainer,
          ownerState,
          onKeyDown: handleKeyDown2,
          ref: tabListRef,
          role: "tablist",
          children
        }), mounted && indicator]
      }), conditionalElements.scrollButtonEnd]
    }));
  });
  function getDateTimePickerTabsUtilityClass(slot) {
    return generateUtilityClass("MuiDateTimePickerTabs", slot);
  }
  generateUtilityClasses("MuiDateTimePickerTabs", ["root"]);
  const viewToTab = (view) => {
    if (isDatePickerView(view)) {
      return "date";
    }
    return "time";
  };
  const tabToView = (tab) => {
    if (tab === "date") {
      return "day";
    }
    return "hours";
  };
  const useUtilityClasses$z = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getDateTimePickerTabsUtilityClass, classes);
  };
  const DateTimePickerTabsRoot = styled(Tabs, {
    name: "MuiDateTimePickerTabs",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })(({
    theme
  }) => ({
    boxShadow: `0 -1px 0 0 inset ${(theme.vars || theme).palette.divider}`,
    "&:last-child": {
      boxShadow: `0 1px 0 0 inset ${(theme.vars || theme).palette.divider}`,
      [`& .${tabsClasses.indicator}`]: {
        bottom: "auto",
        top: 0
      }
    }
  }));
  const DateTimePickerTabs = function DateTimePickerTabs2(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiDateTimePickerTabs"
    });
    const {
      dateIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(DateRangeIcon, {}),
      onViewChange,
      timeIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(TimeIcon, {}),
      view,
      hidden = typeof window === "undefined" || window.innerHeight < 667,
      className,
      sx
    } = props;
    const translations = usePickersTranslations();
    const classes = useUtilityClasses$z(props);
    const handleChange = (event, value) => {
      onViewChange(tabToView(value));
    };
    if (hidden) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerTabsRoot, {
      ownerState: props,
      variant: "fullWidth",
      value: viewToTab(view),
      onChange: handleChange,
      className: clsx(className, classes.root),
      sx,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Tab, {
        value: "date",
        "aria-label": translations.dateTableLabel,
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
          children: dateIcon
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, {
        value: "time",
        "aria-label": translations.timeTableLabel,
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
          children: timeIcon
        })
      })]
    });
  };
  function getPickersToolbarTextUtilityClass(slot) {
    return generateUtilityClass("MuiPickersToolbarText", slot);
  }
  const pickersToolbarTextClasses = generateUtilityClasses("MuiPickersToolbarText", ["root", "selected"]);
  const _excluded$F = ["className", "selected", "value"];
  const useUtilityClasses$y = (ownerState) => {
    const {
      classes,
      selected
    } = ownerState;
    const slots = {
      root: ["root", selected && "selected"]
    };
    return composeClasses(slots, getPickersToolbarTextUtilityClass, classes);
  };
  const PickersToolbarTextRoot = styled(Typography, {
    name: "MuiPickersToolbarText",
    slot: "Root",
    overridesResolver: (_2, styles2) => [styles2.root, {
      [`&.${pickersToolbarTextClasses.selected}`]: styles2.selected
    }]
  })(({
    theme
  }) => ({
    transition: theme.transitions.create("color"),
    color: (theme.vars || theme).palette.text.secondary,
    [`&.${pickersToolbarTextClasses.selected}`]: {
      color: (theme.vars || theme).palette.text.primary
    }
  }));
  const PickersToolbarText = /* @__PURE__ */ reactExports.forwardRef(function PickersToolbarText2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersToolbarText"
    });
    const {
      className,
      value
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$F);
    const classes = useUtilityClasses$y(props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarTextRoot, _extends$1({
      ref,
      className: clsx(className, classes.root),
      component: "span"
    }, other, {
      children: value
    }));
  });
  function getPickersToolbarUtilityClass(slot) {
    return generateUtilityClass("MuiPickersToolbar", slot);
  }
  const pickersToolbarClasses = generateUtilityClasses("MuiPickersToolbar", ["root", "content"]);
  const _excluded$E = ["children", "className", "toolbarTitle", "hidden", "titleId", "isLandscape", "classes", "landscapeDirection"];
  const useUtilityClasses$x = (ownerState) => {
    const {
      classes,
      isLandscape
    } = ownerState;
    const slots = {
      root: ["root"],
      content: ["content"],
      penIconButton: ["penIconButton", isLandscape && "penIconButtonLandscape"]
    };
    return composeClasses(slots, getPickersToolbarUtilityClass, classes);
  };
  const PickersToolbarRoot = styled("div", {
    name: "MuiPickersToolbar",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })(({
    theme
  }) => ({
    display: "flex",
    flexDirection: "column",
    alignItems: "flex-start",
    justifyContent: "space-between",
    padding: theme.spacing(2, 3),
    variants: [{
      props: {
        isLandscape: true
      },
      style: {
        height: "auto",
        maxWidth: 160,
        padding: 16,
        justifyContent: "flex-start",
        flexWrap: "wrap"
      }
    }]
  }));
  const PickersToolbarContent = styled("div", {
    name: "MuiPickersToolbar",
    slot: "Content",
    overridesResolver: (props, styles2) => styles2.content
  })({
    display: "flex",
    flexWrap: "wrap",
    width: "100%",
    flex: 1,
    justifyContent: "space-between",
    alignItems: "center",
    flexDirection: "row",
    variants: [{
      props: {
        isLandscape: true
      },
      style: {
        justifyContent: "flex-start",
        alignItems: "flex-start",
        flexDirection: "column"
      }
    }, {
      props: {
        isLandscape: true,
        landscapeDirection: "row"
      },
      style: {
        flexDirection: "row"
      }
    }]
  });
  const PickersToolbar = /* @__PURE__ */ reactExports.forwardRef(function PickersToolbar2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersToolbar"
    });
    const {
      children,
      className,
      toolbarTitle,
      hidden,
      titleId
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$E);
    const ownerState = props;
    const classes = useUtilityClasses$x(ownerState);
    if (hidden) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersToolbarRoot, _extends$1({
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
        color: "text.secondary",
        variant: "overline",
        id: titleId,
        children: toolbarTitle
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarContent, {
        className: classes.content,
        ownerState,
        children
      })]
    }));
  });
  function getButtonUtilityClass(slot) {
    return generateUtilityClass("MuiButton", slot);
  }
  const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
  const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
  const ButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
  const _excluded$D = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
  const useUtilityClasses$w = (ownerState) => {
    const {
      color: color2,
      disableElevation,
      fullWidth,
      size,
      variant,
      classes
    } = ownerState;
    const slots = {
      root: ["root", variant, `${variant}${capitalize$1(color2)}`, `size${capitalize$1(size)}`, `${variant}Size${capitalize$1(size)}`, `color${capitalize$1(color2)}`, disableElevation && "disableElevation", fullWidth && "fullWidth"],
      label: ["label"],
      startIcon: ["icon", "startIcon", `iconSize${capitalize$1(size)}`],
      endIcon: ["icon", "endIcon", `iconSize${capitalize$1(size)}`]
    };
    const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
    return _extends$1({}, classes, composedClasses);
  };
  const commonIconStyles = (ownerState) => _extends$1({}, ownerState.size === "small" && {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }, ownerState.size === "medium" && {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }, ownerState.size === "large" && {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  });
  const ButtonRoot = styled(ButtonBase, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize$1(ownerState.color)}`], styles2[`size${capitalize$1(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize$1(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
    }
  })(({
    theme,
    ownerState
  }) => {
    var _theme$palette$getCon, _theme$palette;
    const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
    const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
    return _extends$1({}, theme.typography.button, {
      minWidth: 64,
      padding: "6px 16px",
      borderRadius: (theme.vars || theme).shape.borderRadius,
      transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
        duration: theme.transitions.duration.short
      }),
      "&:hover": _extends$1({
        textDecoration: "none",
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette.text.primary, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
        border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }, ownerState.variant === "contained" && {
        backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
        boxShadow: (theme.vars || theme).shadows[4],
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          boxShadow: (theme.vars || theme).shadows[2],
          backgroundColor: (theme.vars || theme).palette.grey[300]
        }
      }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: (theme.vars || theme).palette[ownerState.color].main
        }
      }),
      "&:active": _extends$1({}, ownerState.variant === "contained" && {
        boxShadow: (theme.vars || theme).shadows[8]
      }),
      [`&.${buttonClasses.focusVisible}`]: _extends$1({}, ownerState.variant === "contained" && {
        boxShadow: (theme.vars || theme).shadows[6]
      }),
      [`&.${buttonClasses.disabled}`]: _extends$1({
        color: (theme.vars || theme).palette.action.disabled
      }, ownerState.variant === "outlined" && {
        border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
      }, ownerState.variant === "contained" && {
        color: (theme.vars || theme).palette.action.disabled,
        boxShadow: (theme.vars || theme).shadows[0],
        backgroundColor: (theme.vars || theme).palette.action.disabledBackground
      })
    }, ownerState.variant === "text" && {
      padding: "6px 8px"
    }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
      color: (theme.vars || theme).palette[ownerState.color].main
    }, ownerState.variant === "outlined" && {
      padding: "5px 15px",
      border: "1px solid currentColor"
    }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
      color: (theme.vars || theme).palette[ownerState.color].main,
      border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha_1(theme.palette[ownerState.color].main, 0.5)}`
    }, ownerState.variant === "contained" && {
      color: theme.vars ? (
        // this is safe because grey does not change between default light/dark mode
        theme.vars.palette.text.primary
      ) : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
      backgroundColor: theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
      boxShadow: (theme.vars || theme).shadows[2]
    }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
      color: (theme.vars || theme).palette[ownerState.color].contrastText,
      backgroundColor: (theme.vars || theme).palette[ownerState.color].main
    }, ownerState.color === "inherit" && {
      color: "inherit",
      borderColor: "currentColor"
    }, ownerState.size === "small" && ownerState.variant === "text" && {
      padding: "4px 5px",
      fontSize: theme.typography.pxToRem(13)
    }, ownerState.size === "large" && ownerState.variant === "text" && {
      padding: "8px 11px",
      fontSize: theme.typography.pxToRem(15)
    }, ownerState.size === "small" && ownerState.variant === "outlined" && {
      padding: "3px 9px",
      fontSize: theme.typography.pxToRem(13)
    }, ownerState.size === "large" && ownerState.variant === "outlined" && {
      padding: "7px 21px",
      fontSize: theme.typography.pxToRem(15)
    }, ownerState.size === "small" && ownerState.variant === "contained" && {
      padding: "4px 10px",
      fontSize: theme.typography.pxToRem(13)
    }, ownerState.size === "large" && ownerState.variant === "contained" && {
      padding: "8px 22px",
      fontSize: theme.typography.pxToRem(15)
    }, ownerState.fullWidth && {
      width: "100%"
    });
  }, ({
    ownerState
  }) => ownerState.disableElevation && {
    boxShadow: "none",
    "&:hover": {
      boxShadow: "none"
    },
    [`&.${buttonClasses.focusVisible}`]: {
      boxShadow: "none"
    },
    "&:active": {
      boxShadow: "none"
    },
    [`&.${buttonClasses.disabled}`]: {
      boxShadow: "none"
    }
  });
  const ButtonStartIcon = styled("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.startIcon, styles2[`iconSize${capitalize$1(ownerState.size)}`]];
    }
  })(({
    ownerState
  }) => _extends$1({
    display: "inherit",
    marginRight: 8,
    marginLeft: -4
  }, ownerState.size === "small" && {
    marginLeft: -2
  }, commonIconStyles(ownerState)));
  const ButtonEndIcon = styled("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.endIcon, styles2[`iconSize${capitalize$1(ownerState.size)}`]];
    }
  })(({
    ownerState
  }) => _extends$1({
    display: "inherit",
    marginRight: -4,
    marginLeft: 8
  }, ownerState.size === "small" && {
    marginRight: -2
  }, commonIconStyles(ownerState)));
  const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref) {
    const contextProps = reactExports.useContext(ButtonGroupContext);
    const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext);
    const resolvedProps = resolveProps(contextProps, inProps);
    const props = useDefaultProps({
      props: resolvedProps,
      name: "MuiButton"
    });
    const {
      children,
      color: color2 = "primary",
      component = "button",
      className,
      disabled = false,
      disableElevation = false,
      disableFocusRipple = false,
      endIcon: endIconProp,
      focusVisibleClassName,
      fullWidth = false,
      size = "medium",
      startIcon: startIconProp,
      type,
      variant = "text"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$D);
    const ownerState = _extends$1({}, props, {
      color: color2,
      component,
      disabled,
      disableElevation,
      disableFocusRipple,
      fullWidth,
      size,
      type,
      variant
    });
    const classes = useUtilityClasses$w(ownerState);
    const startIcon = startIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
      className: classes.startIcon,
      ownerState,
      children: startIconProp
    });
    const endIcon = endIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
      className: classes.endIcon,
      ownerState,
      children: endIconProp
    });
    const positionClassName = buttonGroupButtonContextPositionClassName || "";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, _extends$1({
      ownerState,
      className: clsx(contextProps.className, classes.root, className, positionClassName),
      component,
      disabled,
      focusRipple: !disableFocusRipple,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      ref,
      type
    }, other, {
      classes,
      children: [startIcon, children, endIcon]
    }));
  });
  const _excluded$C = ["align", "className", "selected", "typographyClassName", "value", "variant", "width"];
  const useUtilityClasses$v = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getPickersToolbarUtilityClass, classes);
  };
  const PickersToolbarButtonRoot = styled(Button, {
    name: "MuiPickersToolbarButton",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })({
    padding: 0,
    minWidth: 16,
    textTransform: "none"
  });
  const PickersToolbarButton = /* @__PURE__ */ reactExports.forwardRef(function PickersToolbarButton2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersToolbarButton"
    });
    const {
      align,
      className,
      selected,
      typographyClassName,
      value,
      variant,
      width: width2
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$C);
    const classes = useUtilityClasses$v(props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButtonRoot, _extends$1({
      variant: "text",
      ref,
      className: clsx(className, classes.root)
    }, width2 ? {
      sx: {
        width: width2
      }
    } : {}, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarText, {
        align,
        className: typographyClassName,
        variant,
        value,
        selected
      })
    }));
  });
  function getDateTimePickerToolbarUtilityClass(slot) {
    return generateUtilityClass("MuiDateTimePickerToolbar", slot);
  }
  const dateTimePickerToolbarClasses = generateUtilityClasses("MuiDateTimePickerToolbar", ["root", "dateContainer", "timeContainer", "timeDigitsContainer", "separator", "timeLabelReverse", "ampmSelection", "ampmLandscape", "ampmLabel"]);
  function useNextMonthDisabled(month, {
    disableFuture,
    maxDate,
    timezone
  }) {
    const utils2 = useUtils();
    return reactExports.useMemo(() => {
      const now = utils2.date(void 0, timezone);
      const lastEnabledMonth = utils2.startOfMonth(disableFuture && utils2.isBefore(now, maxDate) ? now : maxDate);
      return !utils2.isAfter(lastEnabledMonth, month);
    }, [disableFuture, maxDate, month, utils2, timezone]);
  }
  function usePreviousMonthDisabled(month, {
    disablePast,
    minDate,
    timezone
  }) {
    const utils2 = useUtils();
    return reactExports.useMemo(() => {
      const now = utils2.date(void 0, timezone);
      const firstEnabledMonth = utils2.startOfMonth(disablePast && utils2.isAfter(now, minDate) ? now : minDate);
      return !utils2.isBefore(firstEnabledMonth, month);
    }, [disablePast, minDate, month, utils2, timezone]);
  }
  function useMeridiemMode(date, ampm, onChange, selectionState) {
    const utils2 = useUtils();
    const meridiemMode = getMeridiem(date, utils2);
    const handleMeridiemChange = reactExports.useCallback((mode) => {
      const timeWithMeridiem = date == null ? null : convertToMeridiem(date, mode, Boolean(ampm), utils2);
      onChange(timeWithMeridiem, selectionState ?? "partial");
    }, [ampm, date, onChange, selectionState, utils2]);
    return {
      meridiemMode,
      handleMeridiemChange
    };
  }
  const DAY_SIZE = 36;
  const DAY_MARGIN = 2;
  const DIALOG_WIDTH = 320;
  const MAX_CALENDAR_HEIGHT = 280;
  const VIEW_HEIGHT = 336;
  const DIGITAL_CLOCK_VIEW_HEIGHT = 232;
  const MULTI_SECTION_CLOCK_SECTION_WIDTH = 48;
  const _excluded$B = ["ampm", "ampmInClock", "value", "onChange", "view", "isLandscape", "onViewChange", "toolbarFormat", "toolbarPlaceholder", "views", "disabled", "readOnly", "toolbarVariant", "toolbarTitle", "className"];
  const useUtilityClasses$u = (ownerState) => {
    const {
      classes,
      isLandscape,
      isRtl
    } = ownerState;
    const slots = {
      root: ["root"],
      dateContainer: ["dateContainer"],
      timeContainer: ["timeContainer", isRtl && "timeLabelReverse"],
      timeDigitsContainer: ["timeDigitsContainer", isRtl && "timeLabelReverse"],
      separator: ["separator"],
      ampmSelection: ["ampmSelection", isLandscape && "ampmLandscape"],
      ampmLabel: ["ampmLabel"]
    };
    return composeClasses(slots, getDateTimePickerToolbarUtilityClass, classes);
  };
  const DateTimePickerToolbarRoot = styled(PickersToolbar, {
    name: "MuiDateTimePickerToolbar",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })(({
    theme
  }) => ({
    paddingLeft: 16,
    paddingRight: 16,
    justifyContent: "space-around",
    position: "relative",
    variants: [{
      props: {
        toolbarVariant: "desktop"
      },
      style: {
        borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
        [`& .${pickersToolbarClasses.content} .${pickersToolbarTextClasses.selected}`]: {
          color: (theme.vars || theme).palette.primary.main,
          fontWeight: theme.typography.fontWeightBold
        }
      }
    }, {
      props: {
        toolbarVariant: "desktop",
        isLandscape: true
      },
      style: {
        borderRight: `1px solid ${(theme.vars || theme).palette.divider}`
      }
    }, {
      props: {
        toolbarVariant: "desktop",
        isLandscape: false
      },
      style: {
        paddingLeft: 24,
        paddingRight: 0
      }
    }]
  }));
  const DateTimePickerToolbarDateContainer = styled("div", {
    name: "MuiDateTimePickerToolbar",
    slot: "DateContainer",
    overridesResolver: (props, styles2) => styles2.dateContainer
  })({
    display: "flex",
    flexDirection: "column",
    alignItems: "flex-start"
  });
  const DateTimePickerToolbarTimeContainer = styled("div", {
    name: "MuiDateTimePickerToolbar",
    slot: "TimeContainer",
    overridesResolver: (props, styles2) => styles2.timeContainer
  })({
    display: "flex",
    flexDirection: "row",
    variants: [{
      props: {
        isRtl: true
      },
      style: {
        flexDirection: "row-reverse"
      }
    }, {
      props: {
        toolbarVariant: "desktop",
        isLandscape: false
      },
      style: {
        gap: 9,
        marginRight: 4,
        alignSelf: "flex-end"
      }
    }, {
      props: ({
        isLandscape,
        toolbarVariant
      }) => isLandscape && toolbarVariant !== "desktop",
      style: {
        flexDirection: "column"
      }
    }, {
      props: ({
        isLandscape,
        toolbarVariant,
        isRtl
      }) => isLandscape && toolbarVariant !== "desktop" && isRtl,
      style: {
        flexDirection: "column-reverse"
      }
    }]
  });
  const DateTimePickerToolbarTimeDigitsContainer = styled("div", {
    name: "MuiDateTimePickerToolbar",
    slot: "TimeDigitsContainer",
    overridesResolver: (props, styles2) => styles2.timeDigitsContainer
  })({
    display: "flex",
    variants: [{
      props: {
        isRtl: true
      },
      style: {
        flexDirection: "row-reverse"
      }
    }, {
      props: {
        toolbarVariant: "desktop"
      },
      style: {
        gap: 1.5
      }
    }]
  });
  const DateTimePickerToolbarSeparator = styled(PickersToolbarText, {
    name: "MuiDateTimePickerToolbar",
    slot: "Separator",
    overridesResolver: (props, styles2) => styles2.separator
  })({
    margin: "0 4px 0 2px",
    cursor: "default",
    variants: [{
      props: {
        toolbarVariant: "desktop"
      },
      style: {
        margin: 0
      }
    }]
  });
  const DateTimePickerToolbarAmPmSelection = styled("div", {
    name: "MuiDateTimePickerToolbar",
    slot: "AmPmSelection",
    overridesResolver: (props, styles2) => [{
      [`.${dateTimePickerToolbarClasses.ampmLabel}`]: styles2.ampmLabel
    }, {
      [`&.${dateTimePickerToolbarClasses.ampmLandscape}`]: styles2.ampmLandscape
    }, styles2.ampmSelection]
  })({
    display: "flex",
    flexDirection: "column",
    marginRight: "auto",
    marginLeft: 12,
    [`& .${dateTimePickerToolbarClasses.ampmLabel}`]: {
      fontSize: 17
    },
    variants: [{
      props: {
        isLandscape: true
      },
      style: {
        margin: "4px 0 auto",
        flexDirection: "row",
        justifyContent: "space-around",
        width: "100%"
      }
    }]
  });
  function DateTimePickerToolbar(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiDateTimePickerToolbar"
    });
    const {
      ampm,
      ampmInClock,
      value,
      onChange,
      view,
      isLandscape,
      onViewChange,
      toolbarFormat,
      toolbarPlaceholder = "––",
      views,
      disabled,
      readOnly,
      toolbarVariant = "mobile",
      toolbarTitle: inToolbarTitle,
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$B);
    const isRtl = useRtl();
    const ownerState = _extends$1({}, props, {
      isRtl
    });
    const utils2 = useUtils();
    const {
      meridiemMode,
      handleMeridiemChange
    } = useMeridiemMode(value, ampm, onChange);
    const showAmPmControl = Boolean(ampm && !ampmInClock);
    const isDesktop = toolbarVariant === "desktop";
    const translations = usePickersTranslations();
    const classes = useUtilityClasses$u(ownerState);
    const toolbarTitle = inToolbarTitle ?? translations.dateTimePickerToolbarTitle;
    const formatHours = (time) => ampm ? utils2.format(time, "hours12h") : utils2.format(time, "hours24h");
    const dateText = reactExports.useMemo(() => {
      if (!value) {
        return toolbarPlaceholder;
      }
      if (toolbarFormat) {
        return utils2.formatByString(value, toolbarFormat);
      }
      return utils2.format(value, "shortDate");
    }, [value, toolbarFormat, toolbarPlaceholder, utils2]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerToolbarRoot, _extends$1({
      isLandscape,
      className: clsx(classes.root, className),
      toolbarTitle
    }, other, {
      ownerState,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerToolbarDateContainer, {
        className: classes.dateContainer,
        ownerState,
        children: [views.includes("year") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
          tabIndex: -1,
          variant: "subtitle1",
          onClick: () => onViewChange("year"),
          selected: view === "year",
          value: value ? utils2.format(value, "year") : "–"
        }), views.includes("day") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
          tabIndex: -1,
          variant: isDesktop ? "h5" : "h4",
          onClick: () => onViewChange("day"),
          selected: view === "day",
          value: dateText
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerToolbarTimeContainer, {
        className: classes.timeContainer,
        ownerState,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerToolbarTimeDigitsContainer, {
          className: classes.timeDigitsContainer,
          ownerState,
          children: [views.includes("hours") && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
              variant: isDesktop ? "h5" : "h3",
              width: isDesktop && !isLandscape ? MULTI_SECTION_CLOCK_SECTION_WIDTH : void 0,
              onClick: () => onViewChange("hours"),
              selected: view === "hours",
              value: value ? formatHours(value) : "--"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimePickerToolbarSeparator, {
              variant: isDesktop ? "h5" : "h3",
              value: ":",
              className: classes.separator,
              ownerState
            }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
              variant: isDesktop ? "h5" : "h3",
              width: isDesktop && !isLandscape ? MULTI_SECTION_CLOCK_SECTION_WIDTH : void 0,
              onClick: () => onViewChange("minutes"),
              selected: view === "minutes" || !views.includes("minutes") && view === "hours",
              value: value ? utils2.format(value, "minutes") : "--",
              disabled: !views.includes("minutes")
            })]
          }), views.includes("seconds") && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(DateTimePickerToolbarSeparator, {
              variant: isDesktop ? "h5" : "h3",
              value: ":",
              className: classes.separator,
              ownerState
            }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
              variant: isDesktop ? "h5" : "h3",
              width: isDesktop && !isLandscape ? MULTI_SECTION_CLOCK_SECTION_WIDTH : void 0,
              onClick: () => onViewChange("seconds"),
              selected: view === "seconds",
              value: value ? utils2.format(value, "seconds") : "--"
            })]
          })]
        }), showAmPmControl && !isDesktop && /* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerToolbarAmPmSelection, {
          className: classes.ampmSelection,
          ownerState,
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
            variant: "subtitle2",
            selected: meridiemMode === "am",
            typographyClassName: classes.ampmLabel,
            value: formatMeridiem(utils2, "am"),
            onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
            disabled
          }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
            variant: "subtitle2",
            selected: meridiemMode === "pm",
            typographyClassName: classes.ampmLabel,
            value: formatMeridiem(utils2, "pm"),
            onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
            disabled
          })]
        }), ampm && isDesktop && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
          variant: "h5",
          onClick: () => onViewChange("meridiem"),
          selected: view === "meridiem",
          value: value && meridiemMode ? formatMeridiem(utils2, meridiemMode) : "--",
          width: MULTI_SECTION_CLOCK_SECTION_WIDTH
        })]
      })]
    }));
  }
  function useDateTimePickerDefaultizedProps(props, name) {
    var _a;
    const utils2 = useUtils();
    const defaultDates = useDefaultDates();
    const themeProps = useThemeProps({
      props,
      name
    });
    const ampm = themeProps.ampm ?? utils2.is12HourCycleInCurrentLocale();
    const localeText = reactExports.useMemo(() => {
      var _a2;
      if (((_a2 = themeProps.localeText) == null ? void 0 : _a2.toolbarTitle) == null) {
        return themeProps.localeText;
      }
      return _extends$1({}, themeProps.localeText, {
        dateTimePickerToolbarTitle: themeProps.localeText.toolbarTitle
      });
    }, [themeProps.localeText]);
    return _extends$1({}, themeProps, applyDefaultViewProps({
      views: themeProps.views,
      openTo: themeProps.openTo,
      defaultViews: ["year", "day", "hours", "minutes"],
      defaultOpenTo: "day"
    }), {
      ampm,
      localeText,
      orientation: themeProps.orientation ?? "portrait",
      // TODO: Remove from public API
      disableIgnoringDatePartForTimeValidation: themeProps.disableIgnoringDatePartForTimeValidation ?? Boolean(themeProps.minDateTime || themeProps.maxDateTime || // allow time clock to correctly check time validity: https://github.com/mui/mui-x/issues/8520
      themeProps.disablePast || themeProps.disableFuture),
      disableFuture: themeProps.disableFuture ?? false,
      disablePast: themeProps.disablePast ?? false,
      minDate: applyDefaultDate(utils2, themeProps.minDateTime ?? themeProps.minDate, defaultDates.minDate),
      maxDate: applyDefaultDate(utils2, themeProps.maxDateTime ?? themeProps.maxDate, defaultDates.maxDate),
      minTime: themeProps.minDateTime ?? themeProps.minTime,
      maxTime: themeProps.maxDateTime ?? themeProps.maxTime,
      slots: _extends$1({
        toolbar: DateTimePickerToolbar,
        tabs: DateTimePickerTabs
      }, themeProps.slots),
      slotProps: _extends$1({}, themeProps.slotProps, {
        toolbar: _extends$1({
          ampm
        }, (_a = themeProps.slotProps) == null ? void 0 : _a.toolbar)
      })
    });
  }
  const useIsDateDisabled = ({
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    minDate,
    maxDate,
    disableFuture,
    disablePast,
    timezone
  }) => {
    const adapter = useLocalizationContext();
    return reactExports.useCallback((day) => validateDate({
      adapter,
      value: day,
      props: {
        shouldDisableDate,
        shouldDisableMonth,
        shouldDisableYear,
        minDate,
        maxDate,
        disableFuture,
        disablePast,
        timezone
      }
    }) !== null, [adapter, shouldDisableDate, shouldDisableMonth, shouldDisableYear, minDate, maxDate, disableFuture, disablePast, timezone]);
  };
  const createCalendarStateReducer = (reduceAnimations, disableSwitchToMonthOnDayFocus, utils2) => (state, action) => {
    switch (action.type) {
      case "changeMonth":
        return _extends$1({}, state, {
          slideDirection: action.direction,
          currentMonth: action.newMonth,
          isMonthSwitchingAnimating: !reduceAnimations
        });
      case "finishMonthSwitchingAnimation":
        return _extends$1({}, state, {
          isMonthSwitchingAnimating: false
        });
      case "changeFocusedDay": {
        if (state.focusedDay != null && action.focusedDay != null && utils2.isSameDay(action.focusedDay, state.focusedDay)) {
          return state;
        }
        const needMonthSwitch = action.focusedDay != null && !disableSwitchToMonthOnDayFocus && !utils2.isSameMonth(state.currentMonth, action.focusedDay);
        return _extends$1({}, state, {
          focusedDay: action.focusedDay,
          isMonthSwitchingAnimating: needMonthSwitch && !reduceAnimations && !action.withoutMonthSwitchingAnimation,
          currentMonth: needMonthSwitch ? utils2.startOfMonth(action.focusedDay) : state.currentMonth,
          slideDirection: action.focusedDay != null && utils2.isAfterDay(action.focusedDay, state.currentMonth) ? "left" : "right"
        });
      }
      default:
        throw new Error("missing support");
    }
  };
  const useCalendarState = (params) => {
    const {
      value,
      referenceDate: referenceDateProp,
      disableFuture,
      disablePast,
      disableSwitchToMonthOnDayFocus = false,
      maxDate,
      minDate,
      onMonthChange,
      reduceAnimations,
      shouldDisableDate,
      timezone
    } = params;
    const utils2 = useUtils();
    const reducerFn = reactExports.useRef(createCalendarStateReducer(Boolean(reduceAnimations), disableSwitchToMonthOnDayFocus, utils2)).current;
    const referenceDate = reactExports.useMemo(
      () => {
        return singleItemValueManager.getInitialReferenceValue({
          value,
          utils: utils2,
          timezone,
          props: params,
          referenceDate: referenceDateProp,
          granularity: SECTION_TYPE_GRANULARITY.day
        });
      },
      []
      // eslint-disable-line react-hooks/exhaustive-deps
    );
    const [calendarState, dispatch] = reactExports.useReducer(reducerFn, {
      isMonthSwitchingAnimating: false,
      focusedDay: referenceDate,
      currentMonth: utils2.startOfMonth(referenceDate),
      slideDirection: "left"
    });
    const handleChangeMonth = reactExports.useCallback((payload) => {
      dispatch(_extends$1({
        type: "changeMonth"
      }, payload));
      if (onMonthChange) {
        onMonthChange(payload.newMonth);
      }
    }, [onMonthChange]);
    const changeMonth = reactExports.useCallback((newDate) => {
      const newDateRequested = newDate;
      if (utils2.isSameMonth(newDateRequested, calendarState.currentMonth)) {
        return;
      }
      handleChangeMonth({
        newMonth: utils2.startOfMonth(newDateRequested),
        direction: utils2.isAfterDay(newDateRequested, calendarState.currentMonth) ? "left" : "right"
      });
    }, [calendarState.currentMonth, handleChangeMonth, utils2]);
    const isDateDisabled = useIsDateDisabled({
      shouldDisableDate,
      minDate,
      maxDate,
      disableFuture,
      disablePast,
      timezone
    });
    const onMonthSwitchingAnimationEnd = reactExports.useCallback(() => {
      dispatch({
        type: "finishMonthSwitchingAnimation"
      });
    }, []);
    const changeFocusedDay = useEventCallback((newFocusedDate, withoutMonthSwitchingAnimation) => {
      if (!isDateDisabled(newFocusedDate)) {
        dispatch({
          type: "changeFocusedDay",
          focusedDay: newFocusedDate,
          withoutMonthSwitchingAnimation
        });
      }
    });
    return {
      referenceDate,
      calendarState,
      changeMonth,
      changeFocusedDay,
      isDateDisabled,
      onMonthSwitchingAnimationEnd,
      handleChangeMonth
    };
  };
  const getPickersFadeTransitionGroupUtilityClass = (slot) => generateUtilityClass("MuiPickersFadeTransitionGroup", slot);
  generateUtilityClasses("MuiPickersFadeTransitionGroup", ["root"]);
  const useUtilityClasses$t = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getPickersFadeTransitionGroupUtilityClass, classes);
  };
  const PickersFadeTransitionGroupRoot = styled(TransitionGroup, {
    name: "MuiPickersFadeTransitionGroup",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })({
    display: "block",
    position: "relative"
  });
  function PickersFadeTransitionGroup(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersFadeTransitionGroup"
    });
    const {
      children,
      className,
      reduceAnimations,
      transKey
    } = props;
    const classes = useUtilityClasses$t(props);
    const theme = useTheme$1();
    if (reduceAnimations) {
      return children;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersFadeTransitionGroupRoot, {
      className: clsx(classes.root, className),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, {
        appear: false,
        mountOnEnter: true,
        unmountOnExit: true,
        timeout: {
          appear: theme.transitions.duration.enteringScreen,
          enter: theme.transitions.duration.enteringScreen,
          exit: 0
        },
        children
      }, transKey)
    });
  }
  function getPickersDayUtilityClass(slot) {
    return generateUtilityClass("MuiPickersDay", slot);
  }
  const pickersDayClasses = generateUtilityClasses("MuiPickersDay", ["root", "dayWithMargin", "dayOutsideMonth", "hiddenDaySpacingFiller", "today", "selected", "disabled"]);
  const _excluded$A = ["autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDaySelect", "onFocus", "onBlur", "onKeyDown", "onMouseDown", "onMouseEnter", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today", "isFirstVisibleCell", "isLastVisibleCell"];
  const useUtilityClasses$s = (ownerState) => {
    const {
      selected,
      disableMargin,
      disableHighlightToday,
      today,
      disabled,
      outsideCurrentMonth,
      showDaysOutsideCurrentMonth,
      classes
    } = ownerState;
    const isHiddenDaySpacingFiller = outsideCurrentMonth && !showDaysOutsideCurrentMonth;
    const slots = {
      root: ["root", selected && !isHiddenDaySpacingFiller && "selected", disabled && "disabled", !disableMargin && "dayWithMargin", !disableHighlightToday && today && "today", outsideCurrentMonth && showDaysOutsideCurrentMonth && "dayOutsideMonth", isHiddenDaySpacingFiller && "hiddenDaySpacingFiller"],
      hiddenDaySpacingFiller: ["hiddenDaySpacingFiller"]
    };
    return composeClasses(slots, getPickersDayUtilityClass, classes);
  };
  const styleArg = ({
    theme
  }) => _extends$1({}, theme.typography.caption, {
    width: DAY_SIZE,
    height: DAY_SIZE,
    borderRadius: "50%",
    padding: 0,
    // explicitly setting to `transparent` to avoid potentially getting impacted by change from the overridden component
    backgroundColor: "transparent",
    transition: theme.transitions.create("background-color", {
      duration: theme.transitions.duration.short
    }),
    color: (theme.vars || theme).palette.text.primary,
    "@media (pointer: fine)": {
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
      }
    },
    "&:focus": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity),
      [`&.${pickersDayClasses.selected}`]: {
        willChange: "background-color",
        backgroundColor: (theme.vars || theme).palette.primary.dark
      }
    },
    [`&.${pickersDayClasses.selected}`]: {
      color: (theme.vars || theme).palette.primary.contrastText,
      backgroundColor: (theme.vars || theme).palette.primary.main,
      fontWeight: theme.typography.fontWeightMedium,
      "&:hover": {
        willChange: "background-color",
        backgroundColor: (theme.vars || theme).palette.primary.dark
      }
    },
    [`&.${pickersDayClasses.disabled}:not(.${pickersDayClasses.selected})`]: {
      color: (theme.vars || theme).palette.text.disabled
    },
    [`&.${pickersDayClasses.disabled}&.${pickersDayClasses.selected}`]: {
      opacity: 0.6
    },
    variants: [{
      props: {
        disableMargin: false
      },
      style: {
        margin: `0 ${DAY_MARGIN}px`
      }
    }, {
      props: {
        outsideCurrentMonth: true,
        showDaysOutsideCurrentMonth: true
      },
      style: {
        color: (theme.vars || theme).palette.text.secondary
      }
    }, {
      props: {
        disableHighlightToday: false,
        today: true
      },
      style: {
        [`&:not(.${pickersDayClasses.selected})`]: {
          border: `1px solid ${(theme.vars || theme).palette.text.secondary}`
        }
      }
    }]
  });
  const overridesResolver$2 = (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableMargin && styles2.dayWithMargin, !ownerState.disableHighlightToday && ownerState.today && styles2.today, !ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && styles2.dayOutsideMonth, ownerState.outsideCurrentMonth && !ownerState.showDaysOutsideCurrentMonth && styles2.hiddenDaySpacingFiller];
  };
  const PickersDayRoot = styled(ButtonBase, {
    name: "MuiPickersDay",
    slot: "Root",
    overridesResolver: overridesResolver$2
  })(styleArg);
  const PickersDayFiller = styled("div", {
    name: "MuiPickersDay",
    slot: "Root",
    overridesResolver: overridesResolver$2
  })(({
    theme
  }) => _extends$1({}, styleArg({
    theme
  }), {
    // visibility: 'hidden' does not work here as it hides the element from screen readers as well
    opacity: 0,
    pointerEvents: "none"
  }));
  const noop$1 = () => {
  };
  const PickersDayRaw = /* @__PURE__ */ reactExports.forwardRef(function PickersDay2(inProps, forwardedRef) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersDay"
    });
    const {
      autoFocus = false,
      className,
      day,
      disabled = false,
      disableHighlightToday = false,
      disableMargin = false,
      isAnimating,
      onClick,
      onDaySelect,
      onFocus = noop$1,
      onBlur = noop$1,
      onKeyDown = noop$1,
      onMouseDown = noop$1,
      onMouseEnter = noop$1,
      outsideCurrentMonth,
      selected = false,
      showDaysOutsideCurrentMonth = false,
      children,
      today: isToday = false
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$A);
    const ownerState = _extends$1({}, props, {
      autoFocus,
      disabled,
      disableHighlightToday,
      disableMargin,
      selected,
      showDaysOutsideCurrentMonth,
      today: isToday
    });
    const classes = useUtilityClasses$s(ownerState);
    const utils2 = useUtils();
    const ref = reactExports.useRef(null);
    const handleRef = useForkRef(ref, forwardedRef);
    useEnhancedEffect(() => {
      if (autoFocus && !disabled && !isAnimating && !outsideCurrentMonth) {
        ref.current.focus();
      }
    }, [autoFocus, disabled, isAnimating, outsideCurrentMonth]);
    const handleMouseDown = (event) => {
      onMouseDown(event);
      if (outsideCurrentMonth) {
        event.preventDefault();
      }
    };
    const handleClick = (event) => {
      if (!disabled) {
        onDaySelect(day);
      }
      if (outsideCurrentMonth) {
        event.currentTarget.focus();
      }
      if (onClick) {
        onClick(event);
      }
    };
    if (outsideCurrentMonth && !showDaysOutsideCurrentMonth) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersDayFiller, {
        className: clsx(classes.root, classes.hiddenDaySpacingFiller, className),
        ownerState,
        role: other.role
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersDayRoot, _extends$1({
      className: clsx(classes.root, className),
      ref: handleRef,
      centerRipple: true,
      disabled,
      tabIndex: selected ? 0 : -1,
      onKeyDown: (event) => onKeyDown(event, day),
      onFocus: (event) => onFocus(event, day),
      onBlur: (event) => onBlur(event, day),
      onMouseEnter: (event) => onMouseEnter(event, day),
      onClick: handleClick,
      onMouseDown: handleMouseDown
    }, other, {
      ownerState,
      children: !children ? utils2.format(day, "dayOfMonth") : children
    }));
  });
  const PickersDay = /* @__PURE__ */ reactExports.memo(PickersDayRaw);
  const getPickersSlideTransitionUtilityClass = (slot) => generateUtilityClass("MuiPickersSlideTransition", slot);
  const pickersSlideTransitionClasses = generateUtilityClasses("MuiPickersSlideTransition", ["root", "slideEnter-left", "slideEnter-right", "slideEnterActive", "slideExit", "slideExitActiveLeft-left", "slideExitActiveLeft-right"]);
  const _excluded$z = ["children", "className", "reduceAnimations", "slideDirection", "transKey", "classes"];
  const useUtilityClasses$r = (ownerState) => {
    const {
      classes,
      slideDirection
    } = ownerState;
    const slots = {
      root: ["root"],
      exit: ["slideExit"],
      enterActive: ["slideEnterActive"],
      enter: [`slideEnter-${slideDirection}`],
      exitActive: [`slideExitActiveLeft-${slideDirection}`]
    };
    return composeClasses(slots, getPickersSlideTransitionUtilityClass, classes);
  };
  const PickersSlideTransitionRoot = styled(TransitionGroup, {
    name: "MuiPickersSlideTransition",
    slot: "Root",
    overridesResolver: (_2, styles2) => [styles2.root, {
      [`.${pickersSlideTransitionClasses["slideEnter-left"]}`]: styles2["slideEnter-left"]
    }, {
      [`.${pickersSlideTransitionClasses["slideEnter-right"]}`]: styles2["slideEnter-right"]
    }, {
      [`.${pickersSlideTransitionClasses.slideEnterActive}`]: styles2.slideEnterActive
    }, {
      [`.${pickersSlideTransitionClasses.slideExit}`]: styles2.slideExit
    }, {
      [`.${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: styles2["slideExitActiveLeft-left"]
    }, {
      [`.${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: styles2["slideExitActiveLeft-right"]
    }]
  })(({
    theme
  }) => {
    const slideTransition = theme.transitions.create("transform", {
      duration: theme.transitions.duration.complex,
      easing: "cubic-bezier(0.35, 0.8, 0.4, 1)"
    });
    return {
      display: "block",
      position: "relative",
      overflowX: "hidden",
      "& > *": {
        position: "absolute",
        top: 0,
        right: 0,
        left: 0
      },
      [`& .${pickersSlideTransitionClasses["slideEnter-left"]}`]: {
        willChange: "transform",
        transform: "translate(100%)",
        zIndex: 1
      },
      [`& .${pickersSlideTransitionClasses["slideEnter-right"]}`]: {
        willChange: "transform",
        transform: "translate(-100%)",
        zIndex: 1
      },
      [`& .${pickersSlideTransitionClasses.slideEnterActive}`]: {
        transform: "translate(0%)",
        transition: slideTransition
      },
      [`& .${pickersSlideTransitionClasses.slideExit}`]: {
        transform: "translate(0%)"
      },
      [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: {
        willChange: "transform",
        transform: "translate(-100%)",
        transition: slideTransition,
        zIndex: 0
      },
      [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: {
        willChange: "transform",
        transform: "translate(100%)",
        transition: slideTransition,
        zIndex: 0
      }
    };
  });
  function PickersSlideTransition(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersSlideTransition"
    });
    const {
      children,
      className,
      reduceAnimations,
      transKey
      // extracting `classes` from `other`
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$z);
    const classes = useUtilityClasses$r(props);
    const theme = useTheme$1();
    if (reduceAnimations) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        className: clsx(classes.root, className),
        children
      });
    }
    const transitionClasses = {
      exit: classes.exit,
      enterActive: classes.enterActive,
      enter: classes.enter,
      exitActive: classes.exitActive
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSlideTransitionRoot, {
      className: clsx(classes.root, className),
      childFactory: (element) => /* @__PURE__ */ reactExports.cloneElement(element, {
        classNames: transitionClasses
      }),
      role: "presentation",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CSSTransition, _extends$1({
        mountOnEnter: true,
        unmountOnExit: true,
        timeout: theme.transitions.duration.complex,
        classNames: transitionClasses
      }, other, {
        children
      }), transKey)
    });
  }
  const getDayCalendarUtilityClass = (slot) => generateUtilityClass("MuiDayCalendar", slot);
  generateUtilityClasses("MuiDayCalendar", ["root", "header", "weekDayLabel", "loadingContainer", "slideTransition", "monthContainer", "weekContainer", "weekNumberLabel", "weekNumber"]);
  const _excluded$y = ["parentProps", "day", "focusableDay", "selectedDays", "isDateDisabled", "currentMonthNumber", "isViewFocused"], _excluded2$6 = ["ownerState"];
  const useUtilityClasses$q = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      header: ["header"],
      weekDayLabel: ["weekDayLabel"],
      loadingContainer: ["loadingContainer"],
      slideTransition: ["slideTransition"],
      monthContainer: ["monthContainer"],
      weekContainer: ["weekContainer"],
      weekNumberLabel: ["weekNumberLabel"],
      weekNumber: ["weekNumber"]
    };
    return composeClasses(slots, getDayCalendarUtilityClass, classes);
  };
  const weeksContainerHeight = (DAY_SIZE + DAY_MARGIN * 2) * 6;
  const PickersCalendarDayRoot = styled("div", {
    name: "MuiDayCalendar",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })({});
  const PickersCalendarDayHeader = styled("div", {
    name: "MuiDayCalendar",
    slot: "Header",
    overridesResolver: (_2, styles2) => styles2.header
  })({
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  });
  const PickersCalendarWeekDayLabel = styled(Typography, {
    name: "MuiDayCalendar",
    slot: "WeekDayLabel",
    overridesResolver: (_2, styles2) => styles2.weekDayLabel
  })(({
    theme
  }) => ({
    width: 36,
    height: 40,
    margin: "0 2px",
    textAlign: "center",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    color: (theme.vars || theme).palette.text.secondary
  }));
  const PickersCalendarWeekNumberLabel = styled(Typography, {
    name: "MuiDayCalendar",
    slot: "WeekNumberLabel",
    overridesResolver: (_2, styles2) => styles2.weekNumberLabel
  })(({
    theme
  }) => ({
    width: 36,
    height: 40,
    margin: "0 2px",
    textAlign: "center",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    color: theme.palette.text.disabled
  }));
  const PickersCalendarWeekNumber = styled(Typography, {
    name: "MuiDayCalendar",
    slot: "WeekNumber",
    overridesResolver: (_2, styles2) => styles2.weekNumber
  })(({
    theme
  }) => _extends$1({}, theme.typography.caption, {
    width: DAY_SIZE,
    height: DAY_SIZE,
    padding: 0,
    margin: `0 ${DAY_MARGIN}px`,
    color: theme.palette.text.disabled,
    fontSize: "0.75rem",
    alignItems: "center",
    justifyContent: "center",
    display: "inline-flex"
  }));
  const PickersCalendarLoadingContainer = styled("div", {
    name: "MuiDayCalendar",
    slot: "LoadingContainer",
    overridesResolver: (_2, styles2) => styles2.loadingContainer
  })({
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    minHeight: weeksContainerHeight
  });
  const PickersCalendarSlideTransition = styled(PickersSlideTransition, {
    name: "MuiDayCalendar",
    slot: "SlideTransition",
    overridesResolver: (_2, styles2) => styles2.slideTransition
  })({
    minHeight: weeksContainerHeight
  });
  const PickersCalendarWeekContainer = styled("div", {
    name: "MuiDayCalendar",
    slot: "MonthContainer",
    overridesResolver: (_2, styles2) => styles2.monthContainer
  })({
    overflow: "hidden"
  });
  const PickersCalendarWeek = styled("div", {
    name: "MuiDayCalendar",
    slot: "WeekContainer",
    overridesResolver: (_2, styles2) => styles2.weekContainer
  })({
    margin: `${DAY_MARGIN}px 0`,
    display: "flex",
    justifyContent: "center"
  });
  function WrappedDay(_ref) {
    let {
      parentProps,
      day,
      focusableDay,
      selectedDays,
      isDateDisabled,
      currentMonthNumber,
      isViewFocused
    } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$y);
    const {
      disabled,
      disableHighlightToday,
      isMonthSwitchingAnimating,
      showDaysOutsideCurrentMonth,
      slots,
      slotProps,
      timezone
    } = parentProps;
    const utils2 = useUtils();
    const now = useNow(timezone);
    const isFocusableDay = focusableDay !== null && utils2.isSameDay(day, focusableDay);
    const isSelected = selectedDays.some((selectedDay) => utils2.isSameDay(selectedDay, day));
    const isToday = utils2.isSameDay(day, now);
    const Day = (slots == null ? void 0 : slots.day) ?? PickersDay;
    const _useSlotProps = useSlotProps({
      elementType: Day,
      externalSlotProps: slotProps == null ? void 0 : slotProps.day,
      additionalProps: _extends$1({
        disableHighlightToday,
        showDaysOutsideCurrentMonth,
        role: "gridcell",
        isAnimating: isMonthSwitchingAnimating,
        // it is used in date range dragging logic by accessing `dataset.timestamp`
        "data-timestamp": utils2.toJsDate(day).valueOf()
      }, other),
      ownerState: _extends$1({}, parentProps, {
        day,
        selected: isSelected
      })
    }), dayProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$6);
    const isDisabled = reactExports.useMemo(() => disabled || isDateDisabled(day), [disabled, isDateDisabled, day]);
    const outsideCurrentMonth = reactExports.useMemo(() => utils2.getMonth(day) !== currentMonthNumber, [utils2, day, currentMonthNumber]);
    const isFirstVisibleCell = reactExports.useMemo(() => {
      const startOfMonth = utils2.startOfMonth(utils2.setMonth(day, currentMonthNumber));
      if (!showDaysOutsideCurrentMonth) {
        return utils2.isSameDay(day, startOfMonth);
      }
      return utils2.isSameDay(day, utils2.startOfWeek(startOfMonth));
    }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils2]);
    const isLastVisibleCell = reactExports.useMemo(() => {
      const endOfMonth = utils2.endOfMonth(utils2.setMonth(day, currentMonthNumber));
      if (!showDaysOutsideCurrentMonth) {
        return utils2.isSameDay(day, endOfMonth);
      }
      return utils2.isSameDay(day, utils2.endOfWeek(endOfMonth));
    }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils2]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Day, _extends$1({}, dayProps, {
      day,
      disabled: isDisabled,
      autoFocus: isViewFocused && isFocusableDay,
      today: isToday,
      outsideCurrentMonth,
      isFirstVisibleCell,
      isLastVisibleCell,
      selected: isSelected,
      tabIndex: isFocusableDay ? 0 : -1,
      "aria-selected": isSelected,
      "aria-current": isToday ? "date" : void 0
    }));
  }
  function DayCalendar(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiDayCalendar"
    });
    const utils2 = useUtils();
    const {
      onFocusedDayChange,
      className,
      currentMonth,
      selectedDays,
      focusedDay,
      loading,
      onSelectedDaysChange,
      onMonthSwitchingAnimationEnd,
      readOnly,
      reduceAnimations,
      renderLoading = () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        children: "..."
      }),
      slideDirection,
      TransitionProps,
      disablePast,
      disableFuture,
      minDate,
      maxDate,
      shouldDisableDate,
      shouldDisableMonth,
      shouldDisableYear,
      dayOfWeekFormatter = (date) => utils2.format(date, "weekdayShort").charAt(0).toUpperCase(),
      hasFocus,
      onFocusedViewChange,
      gridLabelId,
      displayWeekNumber,
      fixedWeekNumber,
      autoFocus,
      timezone
    } = props;
    const now = useNow(timezone);
    const classes = useUtilityClasses$q(props);
    const isRtl = useRtl();
    const isDateDisabled = useIsDateDisabled({
      shouldDisableDate,
      shouldDisableMonth,
      shouldDisableYear,
      minDate,
      maxDate,
      disablePast,
      disableFuture,
      timezone
    });
    const translations = usePickersTranslations();
    const [internalHasFocus, setInternalHasFocus] = useControlled({
      name: "DayCalendar",
      state: "hasFocus",
      controlled: hasFocus,
      default: autoFocus ?? false
    });
    const [internalFocusedDay, setInternalFocusedDay] = reactExports.useState(() => focusedDay || now);
    const handleDaySelect = useEventCallback((day) => {
      if (readOnly) {
        return;
      }
      onSelectedDaysChange(day);
    });
    const focusDay = (day) => {
      if (!isDateDisabled(day)) {
        onFocusedDayChange(day);
        setInternalFocusedDay(day);
        onFocusedViewChange == null ? void 0 : onFocusedViewChange(true);
        setInternalHasFocus(true);
      }
    };
    const handleKeyDown2 = useEventCallback((event, day) => {
      switch (event.key) {
        case "ArrowUp":
          focusDay(utils2.addDays(day, -7));
          event.preventDefault();
          break;
        case "ArrowDown":
          focusDay(utils2.addDays(day, 7));
          event.preventDefault();
          break;
        case "ArrowLeft": {
          const newFocusedDayDefault = utils2.addDays(day, isRtl ? 1 : -1);
          const nextAvailableMonth = utils2.addMonths(day, isRtl ? 1 : -1);
          const closestDayToFocus = findClosestEnabledDate({
            utils: utils2,
            date: newFocusedDayDefault,
            minDate: isRtl ? newFocusedDayDefault : utils2.startOfMonth(nextAvailableMonth),
            maxDate: isRtl ? utils2.endOfMonth(nextAvailableMonth) : newFocusedDayDefault,
            isDateDisabled,
            timezone
          });
          focusDay(closestDayToFocus || newFocusedDayDefault);
          event.preventDefault();
          break;
        }
        case "ArrowRight": {
          const newFocusedDayDefault = utils2.addDays(day, isRtl ? -1 : 1);
          const nextAvailableMonth = utils2.addMonths(day, isRtl ? -1 : 1);
          const closestDayToFocus = findClosestEnabledDate({
            utils: utils2,
            date: newFocusedDayDefault,
            minDate: isRtl ? utils2.startOfMonth(nextAvailableMonth) : newFocusedDayDefault,
            maxDate: isRtl ? newFocusedDayDefault : utils2.endOfMonth(nextAvailableMonth),
            isDateDisabled,
            timezone
          });
          focusDay(closestDayToFocus || newFocusedDayDefault);
          event.preventDefault();
          break;
        }
        case "Home":
          focusDay(utils2.startOfWeek(day));
          event.preventDefault();
          break;
        case "End":
          focusDay(utils2.endOfWeek(day));
          event.preventDefault();
          break;
        case "PageUp":
          focusDay(utils2.addMonths(day, 1));
          event.preventDefault();
          break;
        case "PageDown":
          focusDay(utils2.addMonths(day, -1));
          event.preventDefault();
          break;
      }
    });
    const handleFocus = useEventCallback((event, day) => focusDay(day));
    const handleBlur = useEventCallback((event, day) => {
      if (internalHasFocus && utils2.isSameDay(internalFocusedDay, day)) {
        onFocusedViewChange == null ? void 0 : onFocusedViewChange(false);
      }
    });
    const currentMonthNumber = utils2.getMonth(currentMonth);
    const currentYearNumber = utils2.getYear(currentMonth);
    const validSelectedDays = reactExports.useMemo(() => selectedDays.filter((day) => !!day).map((day) => utils2.startOfDay(day)), [utils2, selectedDays]);
    const transitionKey = `${currentYearNumber}-${currentMonthNumber}`;
    const slideNodeRef = reactExports.useMemo(() => /* @__PURE__ */ reactExports.createRef(), [transitionKey]);
    const startOfCurrentWeek = utils2.startOfWeek(now);
    const focusableDay = reactExports.useMemo(() => {
      const startOfMonth = utils2.startOfMonth(currentMonth);
      const endOfMonth = utils2.endOfMonth(currentMonth);
      if (isDateDisabled(internalFocusedDay) || utils2.isAfterDay(internalFocusedDay, endOfMonth) || utils2.isBeforeDay(internalFocusedDay, startOfMonth)) {
        return findClosestEnabledDate({
          utils: utils2,
          date: internalFocusedDay,
          minDate: startOfMonth,
          maxDate: endOfMonth,
          disablePast,
          disableFuture,
          isDateDisabled,
          timezone
        });
      }
      return internalFocusedDay;
    }, [currentMonth, disableFuture, disablePast, internalFocusedDay, isDateDisabled, utils2, timezone]);
    const weeksToDisplay = reactExports.useMemo(() => {
      const currentMonthWithTimezone = utils2.setTimezone(currentMonth, timezone);
      const toDisplay = utils2.getWeekArray(currentMonthWithTimezone);
      let nextMonth = utils2.addMonths(currentMonthWithTimezone, 1);
      while (fixedWeekNumber && toDisplay.length < fixedWeekNumber) {
        const additionalWeeks = utils2.getWeekArray(nextMonth);
        const hasCommonWeek = utils2.isSameDay(toDisplay[toDisplay.length - 1][0], additionalWeeks[0][0]);
        additionalWeeks.slice(hasCommonWeek ? 1 : 0).forEach((week) => {
          if (toDisplay.length < fixedWeekNumber) {
            toDisplay.push(week);
          }
        });
        nextMonth = utils2.addMonths(nextMonth, 1);
      }
      return toDisplay;
    }, [currentMonth, fixedWeekNumber, utils2, timezone]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarDayRoot, {
      role: "grid",
      "aria-labelledby": gridLabelId,
      className: classes.root,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarDayHeader, {
        role: "row",
        className: classes.header,
        children: [displayWeekNumber && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekNumberLabel, {
          variant: "caption",
          role: "columnheader",
          "aria-label": translations.calendarWeekNumberHeaderLabel,
          className: classes.weekNumberLabel,
          children: translations.calendarWeekNumberHeaderText
        }), getWeekdays(utils2, now).map((weekday, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekDayLabel, {
          variant: "caption",
          role: "columnheader",
          "aria-label": utils2.format(utils2.addDays(startOfCurrentWeek, i), "weekday"),
          className: classes.weekDayLabel,
          children: dayOfWeekFormatter(weekday)
        }, i.toString()))]
      }), loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarLoadingContainer, {
        className: classes.loadingContainer,
        children: renderLoading()
      }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarSlideTransition, _extends$1({
        transKey: transitionKey,
        onExited: onMonthSwitchingAnimationEnd,
        reduceAnimations,
        slideDirection,
        className: clsx(className, classes.slideTransition)
      }, TransitionProps, {
        nodeRef: slideNodeRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekContainer, {
          ref: slideNodeRef,
          role: "rowgroup",
          className: classes.monthContainer,
          children: weeksToDisplay.map((week, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarWeek, {
            role: "row",
            className: classes.weekContainer,
            "aria-rowindex": index + 1,
            children: [displayWeekNumber && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekNumber, {
              className: classes.weekNumber,
              role: "rowheader",
              "aria-label": translations.calendarWeekNumberAriaLabelText(utils2.getWeekNumber(week[0])),
              children: translations.calendarWeekNumberText(utils2.getWeekNumber(week[0]))
            }), week.map((day, dayIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedDay, {
              parentProps: props,
              day,
              selectedDays: validSelectedDays,
              focusableDay,
              onKeyDown: handleKeyDown2,
              onFocus: handleFocus,
              onBlur: handleBlur,
              onDaySelect: handleDaySelect,
              isDateDisabled,
              currentMonthNumber,
              isViewFocused: internalHasFocus,
              "aria-colindex": dayIndex + 1
            }, day.toString()))]
          }, `week-${week[0]}`))
        })
      }))]
    });
  }
  function getPickersMonthUtilityClass(slot) {
    return generateUtilityClass("MuiPickersMonth", slot);
  }
  const pickersMonthClasses = generateUtilityClasses("MuiPickersMonth", ["root", "monthButton", "disabled", "selected"]);
  const _excluded$x = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "aria-label", "monthsPerRow", "slots", "slotProps"];
  const useUtilityClasses$p = (ownerState) => {
    const {
      disabled,
      selected,
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      monthButton: ["monthButton", disabled && "disabled", selected && "selected"]
    };
    return composeClasses(slots, getPickersMonthUtilityClass, classes);
  };
  const PickersMonthRoot = styled("div", {
    name: "MuiPickersMonth",
    slot: "Root",
    overridesResolver: (_2, styles2) => [styles2.root]
  })({
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexBasis: "33.3%",
    variants: [{
      props: {
        monthsPerRow: 4
      },
      style: {
        flexBasis: "25%"
      }
    }]
  });
  const MonthCalendarButton = styled("button", {
    name: "MuiPickersMonth",
    slot: "MonthButton",
    overridesResolver: (_2, styles2) => [styles2.monthButton, {
      [`&.${pickersMonthClasses.disabled}`]: styles2.disabled
    }, {
      [`&.${pickersMonthClasses.selected}`]: styles2.selected
    }]
  })(({
    theme
  }) => _extends$1({
    color: "unset",
    backgroundColor: "transparent",
    border: 0,
    outline: 0
  }, theme.typography.subtitle1, {
    margin: "8px 0",
    height: 36,
    width: 72,
    borderRadius: 18,
    cursor: "pointer",
    "&:focus": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
    },
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
    },
    "&:disabled": {
      cursor: "auto",
      pointerEvents: "none"
    },
    [`&.${pickersMonthClasses.disabled}`]: {
      color: (theme.vars || theme).palette.text.secondary
    },
    [`&.${pickersMonthClasses.selected}`]: {
      color: (theme.vars || theme).palette.primary.contrastText,
      backgroundColor: (theme.vars || theme).palette.primary.main,
      "&:focus, &:hover": {
        backgroundColor: (theme.vars || theme).palette.primary.dark
      }
    }
  }));
  const PickersMonth = /* @__PURE__ */ reactExports.memo(function PickersMonth2(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersMonth"
    });
    const {
      autoFocus,
      className,
      children,
      disabled,
      selected,
      value,
      tabIndex,
      onClick,
      onKeyDown,
      onFocus,
      onBlur,
      "aria-current": ariaCurrent,
      "aria-label": ariaLabel,
      slots,
      slotProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$x);
    const ref = reactExports.useRef(null);
    const classes = useUtilityClasses$p(props);
    useEnhancedEffect(() => {
      var _a;
      if (autoFocus) {
        (_a = ref.current) == null ? void 0 : _a.focus();
      }
    }, [autoFocus]);
    const MonthButton = (slots == null ? void 0 : slots.monthButton) ?? MonthCalendarButton;
    const monthButtonProps = useSlotProps({
      elementType: MonthButton,
      externalSlotProps: slotProps == null ? void 0 : slotProps.monthButton,
      additionalProps: {
        children,
        disabled,
        tabIndex,
        ref,
        type: "button",
        role: "radio",
        "aria-current": ariaCurrent,
        "aria-checked": selected,
        "aria-label": ariaLabel,
        onClick: (event) => onClick(event, value),
        onKeyDown: (event) => onKeyDown(event, value),
        onFocus: (event) => onFocus(event, value),
        onBlur: (event) => onBlur(event, value)
      },
      ownerState: props,
      className: classes.monthButton
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersMonthRoot, _extends$1({
      className: clsx(classes.root, className),
      ownerState: props
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MonthButton, _extends$1({}, monthButtonProps))
    }));
  });
  function getMonthCalendarUtilityClass(slot) {
    return generateUtilityClass("MuiMonthCalendar", slot);
  }
  generateUtilityClasses("MuiMonthCalendar", ["root"]);
  const _excluded$w = ["className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange", "monthsPerRow", "timezone", "gridLabelId", "slots", "slotProps"];
  const useUtilityClasses$o = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getMonthCalendarUtilityClass, classes);
  };
  function useMonthCalendarDefaultizedProps(props, name) {
    const utils2 = useUtils();
    const defaultDates = useDefaultDates();
    const themeProps = useThemeProps({
      props,
      name
    });
    return _extends$1({
      disableFuture: false,
      disablePast: false
    }, themeProps, {
      minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
      maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
    });
  }
  const MonthCalendarRoot = styled("div", {
    name: "MuiMonthCalendar",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "flex",
    flexWrap: "wrap",
    alignContent: "stretch",
    padding: "0 4px",
    width: DIALOG_WIDTH,
    // avoid padding increasing width over defined
    boxSizing: "border-box"
  });
  const MonthCalendar = /* @__PURE__ */ reactExports.forwardRef(function MonthCalendar2(inProps, ref) {
    const props = useMonthCalendarDefaultizedProps(inProps, "MuiMonthCalendar");
    const {
      className,
      value: valueProp,
      defaultValue,
      referenceDate: referenceDateProp,
      disabled,
      disableFuture,
      disablePast,
      maxDate,
      minDate,
      onChange,
      shouldDisableMonth,
      readOnly,
      autoFocus = false,
      onMonthFocus,
      hasFocus,
      onFocusedViewChange,
      monthsPerRow = 3,
      timezone: timezoneProp,
      gridLabelId,
      slots,
      slotProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$w);
    const {
      value,
      handleValueChange,
      timezone
    } = useControlledValueWithTimezone({
      name: "MonthCalendar",
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange,
      valueManager: singleItemValueManager
    });
    const now = useNow(timezone);
    const isRtl = useRtl();
    const utils2 = useUtils();
    const referenceDate = reactExports.useMemo(
      () => singleItemValueManager.getInitialReferenceValue({
        value,
        utils: utils2,
        props,
        timezone,
        referenceDate: referenceDateProp,
        granularity: SECTION_TYPE_GRANULARITY.month
      }),
      []
      // eslint-disable-line react-hooks/exhaustive-deps
    );
    const ownerState = props;
    const classes = useUtilityClasses$o(ownerState);
    const todayMonth = reactExports.useMemo(() => utils2.getMonth(now), [utils2, now]);
    const selectedMonth = reactExports.useMemo(() => {
      if (value != null) {
        return utils2.getMonth(value);
      }
      return null;
    }, [value, utils2]);
    const [focusedMonth, setFocusedMonth] = reactExports.useState(() => selectedMonth || utils2.getMonth(referenceDate));
    const [internalHasFocus, setInternalHasFocus] = useControlled({
      name: "MonthCalendar",
      state: "hasFocus",
      controlled: hasFocus,
      default: autoFocus ?? false
    });
    const changeHasFocus = useEventCallback((newHasFocus) => {
      setInternalHasFocus(newHasFocus);
      if (onFocusedViewChange) {
        onFocusedViewChange(newHasFocus);
      }
    });
    const isMonthDisabled = reactExports.useCallback((dateToValidate) => {
      const firstEnabledMonth = utils2.startOfMonth(disablePast && utils2.isAfter(now, minDate) ? now : minDate);
      const lastEnabledMonth = utils2.startOfMonth(disableFuture && utils2.isBefore(now, maxDate) ? now : maxDate);
      const monthToValidate = utils2.startOfMonth(dateToValidate);
      if (utils2.isBefore(monthToValidate, firstEnabledMonth)) {
        return true;
      }
      if (utils2.isAfter(monthToValidate, lastEnabledMonth)) {
        return true;
      }
      if (!shouldDisableMonth) {
        return false;
      }
      return shouldDisableMonth(monthToValidate);
    }, [disableFuture, disablePast, maxDate, minDate, now, shouldDisableMonth, utils2]);
    const handleMonthSelection = useEventCallback((event, month) => {
      if (readOnly) {
        return;
      }
      const newDate = utils2.setMonth(value ?? referenceDate, month);
      handleValueChange(newDate);
    });
    const focusMonth = useEventCallback((month) => {
      if (!isMonthDisabled(utils2.setMonth(value ?? referenceDate, month))) {
        setFocusedMonth(month);
        changeHasFocus(true);
        if (onMonthFocus) {
          onMonthFocus(month);
        }
      }
    });
    reactExports.useEffect(() => {
      setFocusedMonth((prevFocusedMonth) => selectedMonth !== null && prevFocusedMonth !== selectedMonth ? selectedMonth : prevFocusedMonth);
    }, [selectedMonth]);
    const handleKeyDown2 = useEventCallback((event, month) => {
      const monthsInYear = 12;
      const monthsInRow = 3;
      switch (event.key) {
        case "ArrowUp":
          focusMonth((monthsInYear + month - monthsInRow) % monthsInYear);
          event.preventDefault();
          break;
        case "ArrowDown":
          focusMonth((monthsInYear + month + monthsInRow) % monthsInYear);
          event.preventDefault();
          break;
        case "ArrowLeft":
          focusMonth((monthsInYear + month + (isRtl ? 1 : -1)) % monthsInYear);
          event.preventDefault();
          break;
        case "ArrowRight":
          focusMonth((monthsInYear + month + (isRtl ? -1 : 1)) % monthsInYear);
          event.preventDefault();
          break;
      }
    });
    const handleMonthFocus = useEventCallback((event, month) => {
      focusMonth(month);
    });
    const handleMonthBlur = useEventCallback((event, month) => {
      if (focusedMonth === month) {
        changeHasFocus(false);
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MonthCalendarRoot, _extends$1({
      ref,
      className: clsx(classes.root, className),
      ownerState,
      role: "radiogroup",
      "aria-labelledby": gridLabelId
    }, other, {
      children: getMonthsInYear(utils2, value ?? referenceDate).map((month) => {
        const monthNumber = utils2.getMonth(month);
        const monthText = utils2.format(month, "monthShort");
        const monthLabel = utils2.format(month, "month");
        const isSelected = monthNumber === selectedMonth;
        const isDisabled = disabled || isMonthDisabled(month);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersMonth, {
          selected: isSelected,
          value: monthNumber,
          onClick: handleMonthSelection,
          onKeyDown: handleKeyDown2,
          autoFocus: internalHasFocus && monthNumber === focusedMonth,
          disabled: isDisabled,
          tabIndex: monthNumber === focusedMonth && !isDisabled ? 0 : -1,
          onFocus: handleMonthFocus,
          onBlur: handleMonthBlur,
          "aria-current": todayMonth === monthNumber ? "date" : void 0,
          "aria-label": monthLabel,
          monthsPerRow,
          slots,
          slotProps,
          children: monthText
        }, monthText);
      })
    }));
  });
  function getPickersYearUtilityClass(slot) {
    return generateUtilityClass("MuiPickersYear", slot);
  }
  const pickersYearClasses = generateUtilityClasses("MuiPickersYear", ["root", "yearButton", "selected", "disabled"]);
  const _excluded$v = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "yearsPerRow", "slots", "slotProps"];
  const useUtilityClasses$n = (ownerState) => {
    const {
      disabled,
      selected,
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      yearButton: ["yearButton", disabled && "disabled", selected && "selected"]
    };
    return composeClasses(slots, getPickersYearUtilityClass, classes);
  };
  const PickersYearRoot = styled("div", {
    name: "MuiPickersYear",
    slot: "Root",
    overridesResolver: (_2, styles2) => [styles2.root]
  })({
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexBasis: "33.3%",
    variants: [{
      props: {
        yearsPerRow: 4
      },
      style: {
        flexBasis: "25%"
      }
    }]
  });
  const YearCalendarButton = styled("button", {
    name: "MuiPickersYear",
    slot: "YearButton",
    overridesResolver: (_2, styles2) => [styles2.yearButton, {
      [`&.${pickersYearClasses.disabled}`]: styles2.disabled
    }, {
      [`&.${pickersYearClasses.selected}`]: styles2.selected
    }]
  })(({
    theme
  }) => _extends$1({
    color: "unset",
    backgroundColor: "transparent",
    border: 0,
    outline: 0
  }, theme.typography.subtitle1, {
    margin: "6px 0",
    height: 36,
    width: 72,
    borderRadius: 18,
    cursor: "pointer",
    "&:focus": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.action.active, theme.palette.action.focusOpacity)
    },
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
    },
    "&:disabled": {
      cursor: "auto",
      pointerEvents: "none"
    },
    [`&.${pickersYearClasses.disabled}`]: {
      color: (theme.vars || theme).palette.text.secondary
    },
    [`&.${pickersYearClasses.selected}`]: {
      color: (theme.vars || theme).palette.primary.contrastText,
      backgroundColor: (theme.vars || theme).palette.primary.main,
      "&:focus, &:hover": {
        backgroundColor: (theme.vars || theme).palette.primary.dark
      }
    }
  }));
  const PickersYear = /* @__PURE__ */ reactExports.memo(function PickersYear2(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersYear"
    });
    const {
      autoFocus,
      className,
      children,
      disabled,
      selected,
      value,
      tabIndex,
      onClick,
      onKeyDown,
      onFocus,
      onBlur,
      "aria-current": ariaCurrent,
      slots,
      slotProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$v);
    const ref = reactExports.useRef(null);
    const classes = useUtilityClasses$n(props);
    useEnhancedEffect(() => {
      var _a;
      if (autoFocus) {
        (_a = ref.current) == null ? void 0 : _a.focus();
      }
    }, [autoFocus]);
    const YearButton = (slots == null ? void 0 : slots.yearButton) ?? YearCalendarButton;
    const yearButtonProps = useSlotProps({
      elementType: YearButton,
      externalSlotProps: slotProps == null ? void 0 : slotProps.yearButton,
      additionalProps: {
        children,
        disabled,
        tabIndex,
        ref,
        type: "button",
        role: "radio",
        "aria-current": ariaCurrent,
        "aria-checked": selected,
        onClick: (event) => onClick(event, value),
        onKeyDown: (event) => onKeyDown(event, value),
        onFocus: (event) => onFocus(event, value),
        onBlur: (event) => onBlur(event, value)
      },
      ownerState: props,
      className: classes.yearButton
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersYearRoot, _extends$1({
      className: clsx(classes.root, className),
      ownerState: props
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(YearButton, _extends$1({}, yearButtonProps))
    }));
  });
  function getYearCalendarUtilityClass(slot) {
    return generateUtilityClass("MuiYearCalendar", slot);
  }
  generateUtilityClasses("MuiYearCalendar", ["root"]);
  const _excluded$u = ["autoFocus", "className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "readOnly", "shouldDisableYear", "disableHighlightToday", "onYearFocus", "hasFocus", "onFocusedViewChange", "yearsPerRow", "timezone", "gridLabelId", "slots", "slotProps"];
  const useUtilityClasses$m = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getYearCalendarUtilityClass, classes);
  };
  function useYearCalendarDefaultizedProps(props, name) {
    const utils2 = useUtils();
    const defaultDates = useDefaultDates();
    const themeProps = useThemeProps({
      props,
      name
    });
    return _extends$1({
      disablePast: false,
      disableFuture: false
    }, themeProps, {
      yearsPerRow: themeProps.yearsPerRow ?? 3,
      minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
      maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
    });
  }
  const YearCalendarRoot = styled("div", {
    name: "MuiYearCalendar",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "flex",
    flexDirection: "row",
    flexWrap: "wrap",
    overflowY: "auto",
    height: "100%",
    padding: "0 4px",
    width: DIALOG_WIDTH,
    maxHeight: MAX_CALENDAR_HEIGHT,
    // avoid padding increasing width over defined
    boxSizing: "border-box",
    position: "relative"
  });
  const YearCalendar = /* @__PURE__ */ reactExports.forwardRef(function YearCalendar2(inProps, ref) {
    const props = useYearCalendarDefaultizedProps(inProps, "MuiYearCalendar");
    const {
      autoFocus,
      className,
      value: valueProp,
      defaultValue,
      referenceDate: referenceDateProp,
      disabled,
      disableFuture,
      disablePast,
      maxDate,
      minDate,
      onChange,
      readOnly,
      shouldDisableYear,
      onYearFocus,
      hasFocus,
      onFocusedViewChange,
      yearsPerRow,
      timezone: timezoneProp,
      gridLabelId,
      slots,
      slotProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$u);
    const {
      value,
      handleValueChange,
      timezone
    } = useControlledValueWithTimezone({
      name: "YearCalendar",
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange,
      valueManager: singleItemValueManager
    });
    const now = useNow(timezone);
    const isRtl = useRtl();
    const utils2 = useUtils();
    const referenceDate = reactExports.useMemo(
      () => singleItemValueManager.getInitialReferenceValue({
        value,
        utils: utils2,
        props,
        timezone,
        referenceDate: referenceDateProp,
        granularity: SECTION_TYPE_GRANULARITY.year
      }),
      []
      // eslint-disable-line react-hooks/exhaustive-deps
    );
    const ownerState = props;
    const classes = useUtilityClasses$m(ownerState);
    const todayYear = reactExports.useMemo(() => utils2.getYear(now), [utils2, now]);
    const selectedYear = reactExports.useMemo(() => {
      if (value != null) {
        return utils2.getYear(value);
      }
      return null;
    }, [value, utils2]);
    const [focusedYear, setFocusedYear] = reactExports.useState(() => selectedYear || utils2.getYear(referenceDate));
    const [internalHasFocus, setInternalHasFocus] = useControlled({
      name: "YearCalendar",
      state: "hasFocus",
      controlled: hasFocus,
      default: autoFocus ?? false
    });
    const changeHasFocus = useEventCallback((newHasFocus) => {
      setInternalHasFocus(newHasFocus);
      if (onFocusedViewChange) {
        onFocusedViewChange(newHasFocus);
      }
    });
    const isYearDisabled = reactExports.useCallback((dateToValidate) => {
      if (disablePast && utils2.isBeforeYear(dateToValidate, now)) {
        return true;
      }
      if (disableFuture && utils2.isAfterYear(dateToValidate, now)) {
        return true;
      }
      if (minDate && utils2.isBeforeYear(dateToValidate, minDate)) {
        return true;
      }
      if (maxDate && utils2.isAfterYear(dateToValidate, maxDate)) {
        return true;
      }
      if (!shouldDisableYear) {
        return false;
      }
      const yearToValidate = utils2.startOfYear(dateToValidate);
      return shouldDisableYear(yearToValidate);
    }, [disableFuture, disablePast, maxDate, minDate, now, shouldDisableYear, utils2]);
    const handleYearSelection = useEventCallback((event, year) => {
      if (readOnly) {
        return;
      }
      const newDate = utils2.setYear(value ?? referenceDate, year);
      handleValueChange(newDate);
    });
    const focusYear = useEventCallback((year) => {
      if (!isYearDisabled(utils2.setYear(value ?? referenceDate, year))) {
        setFocusedYear(year);
        changeHasFocus(true);
        onYearFocus == null ? void 0 : onYearFocus(year);
      }
    });
    reactExports.useEffect(() => {
      setFocusedYear((prevFocusedYear) => selectedYear !== null && prevFocusedYear !== selectedYear ? selectedYear : prevFocusedYear);
    }, [selectedYear]);
    const handleKeyDown2 = useEventCallback((event, year) => {
      switch (event.key) {
        case "ArrowUp":
          focusYear(year - yearsPerRow);
          event.preventDefault();
          break;
        case "ArrowDown":
          focusYear(year + yearsPerRow);
          event.preventDefault();
          break;
        case "ArrowLeft":
          focusYear(year + (isRtl ? 1 : -1));
          event.preventDefault();
          break;
        case "ArrowRight":
          focusYear(year + (isRtl ? -1 : 1));
          event.preventDefault();
          break;
      }
    });
    const handleYearFocus = useEventCallback((event, year) => {
      focusYear(year);
    });
    const handleYearBlur = useEventCallback((event, year) => {
      if (focusedYear === year) {
        changeHasFocus(false);
      }
    });
    const scrollerRef = reactExports.useRef(null);
    const handleRef = useForkRef(ref, scrollerRef);
    reactExports.useEffect(() => {
      if (autoFocus || scrollerRef.current === null) {
        return;
      }
      const tabbableButton = scrollerRef.current.querySelector('[tabindex="0"]');
      if (!tabbableButton) {
        return;
      }
      const offsetHeight = tabbableButton.offsetHeight;
      const offsetTop = tabbableButton.offsetTop;
      const clientHeight = scrollerRef.current.clientHeight;
      const scrollTop = scrollerRef.current.scrollTop;
      const elementBottom = offsetTop + offsetHeight;
      if (offsetHeight > clientHeight || offsetTop < scrollTop) {
        return;
      }
      scrollerRef.current.scrollTop = elementBottom - clientHeight / 2 - offsetHeight / 2;
    }, [autoFocus]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(YearCalendarRoot, _extends$1({
      ref: handleRef,
      className: clsx(classes.root, className),
      ownerState,
      role: "radiogroup",
      "aria-labelledby": gridLabelId
    }, other, {
      children: utils2.getYearRange([minDate, maxDate]).map((year) => {
        const yearNumber = utils2.getYear(year);
        const isSelected = yearNumber === selectedYear;
        const isDisabled = disabled || isYearDisabled(year);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersYear, {
          selected: isSelected,
          value: yearNumber,
          onClick: handleYearSelection,
          onKeyDown: handleKeyDown2,
          autoFocus: internalHasFocus && yearNumber === focusedYear,
          disabled: isDisabled,
          tabIndex: yearNumber === focusedYear && !isDisabled ? 0 : -1,
          onFocus: handleYearFocus,
          onBlur: handleYearBlur,
          "aria-current": todayYear === yearNumber ? "date" : void 0,
          yearsPerRow,
          slots,
          slotProps,
          children: utils2.format(year, "year")
        }, utils2.format(year, "year"));
      })
    }));
  });
  function useViews({
    onChange,
    onViewChange,
    openTo,
    view: inView,
    views,
    autoFocus,
    focusedView: inFocusedView,
    onFocusedViewChange
  }) {
    const previousOpenTo = reactExports.useRef(openTo);
    const previousViews = reactExports.useRef(views);
    const defaultView = reactExports.useRef(views.includes(openTo) ? openTo : views[0]);
    const [view, setView] = useControlled({
      name: "useViews",
      state: "view",
      controlled: inView,
      default: defaultView.current
    });
    const defaultFocusedView = reactExports.useRef(autoFocus ? view : null);
    const [focusedView, setFocusedView] = useControlled({
      name: "useViews",
      state: "focusedView",
      controlled: inFocusedView,
      default: defaultFocusedView.current
    });
    reactExports.useEffect(() => {
      if (previousOpenTo.current && previousOpenTo.current !== openTo || previousViews.current && previousViews.current.some((previousView2) => !views.includes(previousView2))) {
        setView(views.includes(openTo) ? openTo : views[0]);
        previousViews.current = views;
        previousOpenTo.current = openTo;
      }
    }, [openTo, setView, view, views]);
    const viewIndex = views.indexOf(view);
    const previousView = views[viewIndex - 1] ?? null;
    const nextView = views[viewIndex + 1] ?? null;
    const handleFocusedViewChange = useEventCallback((viewToFocus, hasFocus) => {
      if (hasFocus) {
        setFocusedView(viewToFocus);
      } else {
        setFocusedView(
          (prevFocusedView) => viewToFocus === prevFocusedView ? null : prevFocusedView
          // If false the blur is due to view switching
        );
      }
      onFocusedViewChange == null ? void 0 : onFocusedViewChange(viewToFocus, hasFocus);
    });
    const handleChangeView = useEventCallback((newView) => {
      handleFocusedViewChange(newView, true);
      if (newView === view) {
        return;
      }
      setView(newView);
      if (onViewChange) {
        onViewChange(newView);
      }
    });
    const goToNextView = useEventCallback(() => {
      if (nextView) {
        handleChangeView(nextView);
      }
    });
    const setValueAndGoToNextView = useEventCallback((value, currentViewSelectionState, selectedView) => {
      const isSelectionFinishedOnCurrentView = currentViewSelectionState === "finish";
      const hasMoreViews = selectedView ? (
        // handles case like `DateTimePicker`, where a view might return a `finish` selection state
        // but when it's not the final view given all `views` -> overall selection state should be `partial`.
        views.indexOf(selectedView) < views.length - 1
      ) : Boolean(nextView);
      const globalSelectionState = isSelectionFinishedOnCurrentView && hasMoreViews ? "partial" : currentViewSelectionState;
      onChange(value, globalSelectionState, selectedView);
      if (selectedView && selectedView !== view) {
        const nextViewAfterSelected = views[views.indexOf(selectedView) + 1];
        if (nextViewAfterSelected) {
          handleChangeView(nextViewAfterSelected);
        }
      } else if (isSelectionFinishedOnCurrentView) {
        goToNextView();
      }
    });
    return {
      view,
      setView: handleChangeView,
      focusedView,
      setFocusedView: handleFocusedViewChange,
      nextView,
      previousView,
      // Always return up-to-date default view instead of the initial one (i.e. defaultView.current)
      defaultView: views.includes(openTo) ? openTo : views[0],
      goToNextView,
      setValueAndGoToNextView
    };
  }
  const getPickersCalendarHeaderUtilityClass = (slot) => generateUtilityClass("MuiPickersCalendarHeader", slot);
  const pickersCalendarHeaderClasses = generateUtilityClasses("MuiPickersCalendarHeader", ["root", "labelContainer", "label", "switchViewButton", "switchViewIcon"]);
  function getPickersArrowSwitcherUtilityClass(slot) {
    return generateUtilityClass("MuiPickersArrowSwitcher", slot);
  }
  generateUtilityClasses("MuiPickersArrowSwitcher", ["root", "spacer", "button", "previousIconButton", "nextIconButton", "leftArrowIcon", "rightArrowIcon"]);
  const _excluded$t = ["children", "className", "slots", "slotProps", "isNextDisabled", "isNextHidden", "onGoToNext", "nextLabel", "isPreviousDisabled", "isPreviousHidden", "onGoToPrevious", "previousLabel", "labelId"], _excluded2$5 = ["ownerState"], _excluded3$1 = ["ownerState"];
  const PickersArrowSwitcherRoot = styled("div", {
    name: "MuiPickersArrowSwitcher",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "flex"
  });
  const PickersArrowSwitcherSpacer = styled("div", {
    name: "MuiPickersArrowSwitcher",
    slot: "Spacer",
    overridesResolver: (props, styles2) => styles2.spacer
  })(({
    theme
  }) => ({
    width: theme.spacing(3)
  }));
  const PickersArrowSwitcherButton = styled(IconButton, {
    name: "MuiPickersArrowSwitcher",
    slot: "Button",
    overridesResolver: (props, styles2) => styles2.button
  })({
    variants: [{
      props: {
        hidden: true
      },
      style: {
        visibility: "hidden"
      }
    }]
  });
  const useUtilityClasses$l = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      spacer: ["spacer"],
      button: ["button"],
      previousIconButton: ["previousIconButton"],
      nextIconButton: ["nextIconButton"],
      leftArrowIcon: ["leftArrowIcon"],
      rightArrowIcon: ["rightArrowIcon"]
    };
    return composeClasses(slots, getPickersArrowSwitcherUtilityClass, classes);
  };
  const PickersArrowSwitcher = /* @__PURE__ */ reactExports.forwardRef(function PickersArrowSwitcher2(inProps, ref) {
    const isRtl = useRtl();
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersArrowSwitcher"
    });
    const {
      children,
      className,
      slots,
      slotProps,
      isNextDisabled,
      isNextHidden,
      onGoToNext,
      nextLabel,
      isPreviousDisabled,
      isPreviousHidden,
      onGoToPrevious,
      previousLabel,
      labelId
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$t);
    const ownerState = props;
    const classes = useUtilityClasses$l(ownerState);
    const nextProps = {
      isDisabled: isNextDisabled,
      isHidden: isNextHidden,
      goTo: onGoToNext,
      label: nextLabel
    };
    const previousProps = {
      isDisabled: isPreviousDisabled,
      isHidden: isPreviousHidden,
      goTo: onGoToPrevious,
      label: previousLabel
    };
    const PreviousIconButton = (slots == null ? void 0 : slots.previousIconButton) ?? PickersArrowSwitcherButton;
    const previousIconButtonProps = useSlotProps({
      elementType: PreviousIconButton,
      externalSlotProps: slotProps == null ? void 0 : slotProps.previousIconButton,
      additionalProps: {
        size: "medium",
        title: previousProps.label,
        "aria-label": previousProps.label,
        disabled: previousProps.isDisabled,
        edge: "end",
        onClick: previousProps.goTo
      },
      ownerState: _extends$1({}, ownerState, {
        hidden: previousProps.isHidden
      }),
      className: clsx(classes.button, classes.previousIconButton)
    });
    const NextIconButton = (slots == null ? void 0 : slots.nextIconButton) ?? PickersArrowSwitcherButton;
    const nextIconButtonProps = useSlotProps({
      elementType: NextIconButton,
      externalSlotProps: slotProps == null ? void 0 : slotProps.nextIconButton,
      additionalProps: {
        size: "medium",
        title: nextProps.label,
        "aria-label": nextProps.label,
        disabled: nextProps.isDisabled,
        edge: "start",
        onClick: nextProps.goTo
      },
      ownerState: _extends$1({}, ownerState, {
        hidden: nextProps.isHidden
      }),
      className: clsx(classes.button, classes.nextIconButton)
    });
    const LeftArrowIcon = (slots == null ? void 0 : slots.leftArrowIcon) ?? ArrowLeftIcon;
    const _useSlotProps = useSlotProps({
      elementType: LeftArrowIcon,
      externalSlotProps: slotProps == null ? void 0 : slotProps.leftArrowIcon,
      additionalProps: {
        fontSize: "inherit"
      },
      ownerState,
      className: classes.leftArrowIcon
    }), leftArrowIconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$5);
    const RightArrowIcon = (slots == null ? void 0 : slots.rightArrowIcon) ?? ArrowRightIcon;
    const _useSlotProps2 = useSlotProps({
      elementType: RightArrowIcon,
      externalSlotProps: slotProps == null ? void 0 : slotProps.rightArrowIcon,
      additionalProps: {
        fontSize: "inherit"
      },
      ownerState,
      className: classes.rightArrowIcon
    }), rightArrowIconProps = _objectWithoutPropertiesLoose(_useSlotProps2, _excluded3$1);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersArrowSwitcherRoot, _extends$1({
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PreviousIconButton, _extends$1({}, previousIconButtonProps, {
        children: isRtl ? /* @__PURE__ */ jsxRuntimeExports.jsx(RightArrowIcon, _extends$1({}, rightArrowIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(LeftArrowIcon, _extends$1({}, leftArrowIconProps))
      })), children ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
        variant: "subtitle1",
        component: "span",
        id: labelId,
        children
      }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PickersArrowSwitcherSpacer, {
        className: classes.spacer,
        ownerState
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(NextIconButton, _extends$1({}, nextIconButtonProps, {
        children: isRtl ? /* @__PURE__ */ jsxRuntimeExports.jsx(LeftArrowIcon, _extends$1({}, leftArrowIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(RightArrowIcon, _extends$1({}, rightArrowIconProps))
      }))]
    }));
  });
  const _excluded$s = ["slots", "slotProps", "currentMonth", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onMonthChange", "onViewChange", "view", "reduceAnimations", "views", "labelId", "className", "timezone", "format"], _excluded2$4 = ["ownerState"];
  const useUtilityClasses$k = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      labelContainer: ["labelContainer"],
      label: ["label"],
      switchViewButton: ["switchViewButton"],
      switchViewIcon: ["switchViewIcon"]
    };
    return composeClasses(slots, getPickersCalendarHeaderUtilityClass, classes);
  };
  const PickersCalendarHeaderRoot = styled("div", {
    name: "MuiPickersCalendarHeader",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })({
    display: "flex",
    alignItems: "center",
    marginTop: 12,
    marginBottom: 4,
    paddingLeft: 24,
    paddingRight: 12,
    // prevent jumping in safari
    maxHeight: 40,
    minHeight: 40
  });
  const PickersCalendarHeaderLabelContainer = styled("div", {
    name: "MuiPickersCalendarHeader",
    slot: "LabelContainer",
    overridesResolver: (_2, styles2) => styles2.labelContainer
  })(({
    theme
  }) => _extends$1({
    display: "flex",
    overflow: "hidden",
    alignItems: "center",
    cursor: "pointer",
    marginRight: "auto"
  }, theme.typography.body1, {
    fontWeight: theme.typography.fontWeightMedium
  }));
  const PickersCalendarHeaderLabel = styled("div", {
    name: "MuiPickersCalendarHeader",
    slot: "Label",
    overridesResolver: (_2, styles2) => styles2.label
  })({
    marginRight: 6
  });
  const PickersCalendarHeaderSwitchViewButton = styled(IconButton, {
    name: "MuiPickersCalendarHeader",
    slot: "SwitchViewButton",
    overridesResolver: (_2, styles2) => styles2.switchViewButton
  })({
    marginRight: "auto",
    variants: [{
      props: {
        view: "year"
      },
      style: {
        [`.${pickersCalendarHeaderClasses.switchViewIcon}`]: {
          transform: "rotate(180deg)"
        }
      }
    }]
  });
  const PickersCalendarHeaderSwitchViewIcon = styled(ArrowDropDownIcon, {
    name: "MuiPickersCalendarHeader",
    slot: "SwitchViewIcon",
    overridesResolver: (_2, styles2) => styles2.switchViewIcon
  })(({
    theme
  }) => ({
    willChange: "transform",
    transition: theme.transitions.create("transform"),
    transform: "rotate(0deg)"
  }));
  const PickersCalendarHeader = /* @__PURE__ */ reactExports.forwardRef(function PickersCalendarHeader2(inProps, ref) {
    const translations = usePickersTranslations();
    const utils2 = useUtils();
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersCalendarHeader"
    });
    const {
      slots,
      slotProps,
      currentMonth: month,
      disabled,
      disableFuture,
      disablePast,
      maxDate,
      minDate,
      onMonthChange,
      onViewChange,
      view,
      reduceAnimations,
      views,
      labelId,
      className,
      timezone,
      format = `${utils2.formats.month} ${utils2.formats.year}`
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$s);
    const ownerState = props;
    const classes = useUtilityClasses$k(props);
    const SwitchViewButton = (slots == null ? void 0 : slots.switchViewButton) ?? PickersCalendarHeaderSwitchViewButton;
    const switchViewButtonProps = useSlotProps({
      elementType: SwitchViewButton,
      externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewButton,
      additionalProps: {
        size: "small",
        "aria-label": translations.calendarViewSwitchingButtonAriaLabel(view)
      },
      ownerState,
      className: classes.switchViewButton
    });
    const SwitchViewIcon = (slots == null ? void 0 : slots.switchViewIcon) ?? PickersCalendarHeaderSwitchViewIcon;
    const _useSlotProps = useSlotProps({
      elementType: SwitchViewIcon,
      externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewIcon,
      ownerState,
      className: classes.switchViewIcon
    }), switchViewIconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$4);
    const selectNextMonth = () => onMonthChange(utils2.addMonths(month, 1), "left");
    const selectPreviousMonth = () => onMonthChange(utils2.addMonths(month, -1), "right");
    const isNextMonthDisabled = useNextMonthDisabled(month, {
      disableFuture,
      maxDate,
      timezone
    });
    const isPreviousMonthDisabled = usePreviousMonthDisabled(month, {
      disablePast,
      minDate,
      timezone
    });
    const handleToggleView = () => {
      if (views.length === 1 || !onViewChange || disabled) {
        return;
      }
      if (views.length === 2) {
        onViewChange(views.find((el2) => el2 !== view) || views[0]);
      } else {
        const nextIndexToOpen = views.indexOf(view) !== 0 ? 0 : 1;
        onViewChange(views[nextIndexToOpen]);
      }
    };
    if (views.length === 1 && views[0] === "year") {
      return null;
    }
    const label = utils2.formatByString(month, format);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarHeaderRoot, _extends$1({}, other, {
      ownerState,
      className: clsx(className, classes.root),
      ref,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarHeaderLabelContainer, {
        role: "presentation",
        onClick: handleToggleView,
        ownerState,
        "aria-live": "polite",
        className: classes.labelContainer,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersFadeTransitionGroup, {
          reduceAnimations,
          transKey: label,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarHeaderLabel, {
            id: labelId,
            ownerState,
            className: classes.label,
            children: label
          })
        }), views.length > 1 && !disabled && /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchViewButton, _extends$1({}, switchViewButtonProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchViewIcon, _extends$1({}, switchViewIconProps))
        }))]
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, {
        in: view === "day",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersArrowSwitcher, {
          slots,
          slotProps,
          onGoToPrevious: selectPreviousMonth,
          isPreviousDisabled: isPreviousMonthDisabled,
          previousLabel: translations.previousMonth,
          onGoToNext: selectNextMonth,
          isNextDisabled: isNextMonthDisabled,
          nextLabel: translations.nextMonth
        })
      })]
    }));
  });
  const PickerViewRoot = styled("div")({
    overflow: "hidden",
    width: DIALOG_WIDTH,
    maxHeight: VIEW_HEIGHT,
    display: "flex",
    flexDirection: "column",
    margin: "0 auto"
  });
  const PREFERS_REDUCED_MOTION = "@media (prefers-reduced-motion: reduce)";
  const mobileVersionMatches = typeof navigator !== "undefined" && navigator.userAgent.match(/android\s(\d+)|OS\s(\d+)/i);
  const androidVersion = mobileVersionMatches && mobileVersionMatches[1] ? parseInt(mobileVersionMatches[1], 10) : null;
  const iOSVersion = mobileVersionMatches && mobileVersionMatches[2] ? parseInt(mobileVersionMatches[2], 10) : null;
  const slowAnimationDevices = androidVersion && androidVersion < 10 || iOSVersion && iOSVersion < 13 || false;
  const useDefaultReduceAnimations = () => {
    const prefersReduced = useMediaQuery(PREFERS_REDUCED_MOTION, {
      defaultMatches: false
    });
    return prefersReduced || slowAnimationDevices;
  };
  const getDateCalendarUtilityClass = (slot) => generateUtilityClass("MuiDateCalendar", slot);
  generateUtilityClasses("MuiDateCalendar", ["root", "viewTransitionContainer"]);
  const _excluded$r = ["autoFocus", "onViewChange", "value", "defaultValue", "referenceDate", "disableFuture", "disablePast", "onChange", "onYearChange", "onMonthChange", "reduceAnimations", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "className", "disabled", "readOnly", "minDate", "maxDate", "disableHighlightToday", "focusedView", "onFocusedViewChange", "showDaysOutsideCurrentMonth", "fixedWeekNumber", "dayOfWeekFormatter", "slots", "slotProps", "loading", "renderLoading", "displayWeekNumber", "yearsPerRow", "monthsPerRow", "timezone"];
  const useUtilityClasses$j = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      viewTransitionContainer: ["viewTransitionContainer"]
    };
    return composeClasses(slots, getDateCalendarUtilityClass, classes);
  };
  function useDateCalendarDefaultizedProps(props, name) {
    const utils2 = useUtils();
    const defaultDates = useDefaultDates();
    const defaultReduceAnimations = useDefaultReduceAnimations();
    const themeProps = useThemeProps({
      props,
      name
    });
    return _extends$1({}, themeProps, {
      loading: themeProps.loading ?? false,
      disablePast: themeProps.disablePast ?? false,
      disableFuture: themeProps.disableFuture ?? false,
      openTo: themeProps.openTo ?? "day",
      views: themeProps.views ?? ["year", "day"],
      reduceAnimations: themeProps.reduceAnimations ?? defaultReduceAnimations,
      renderLoading: themeProps.renderLoading ?? (() => /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        children: "..."
      })),
      minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
      maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
    });
  }
  const DateCalendarRoot = styled(PickerViewRoot, {
    name: "MuiDateCalendar",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "flex",
    flexDirection: "column",
    height: VIEW_HEIGHT
  });
  const DateCalendarViewTransitionContainer = styled(PickersFadeTransitionGroup, {
    name: "MuiDateCalendar",
    slot: "ViewTransitionContainer",
    overridesResolver: (props, styles2) => styles2.viewTransitionContainer
  })({});
  const DateCalendar = /* @__PURE__ */ reactExports.forwardRef(function DateCalendar2(inProps, ref) {
    const utils2 = useUtils();
    const id2 = useId();
    const props = useDateCalendarDefaultizedProps(inProps, "MuiDateCalendar");
    const {
      autoFocus,
      onViewChange,
      value: valueProp,
      defaultValue,
      referenceDate: referenceDateProp,
      disableFuture,
      disablePast,
      onChange,
      onYearChange,
      onMonthChange,
      reduceAnimations,
      shouldDisableDate,
      shouldDisableMonth,
      shouldDisableYear,
      view: inView,
      views,
      openTo,
      className,
      disabled,
      readOnly,
      minDate,
      maxDate,
      disableHighlightToday,
      focusedView: inFocusedView,
      onFocusedViewChange,
      showDaysOutsideCurrentMonth,
      fixedWeekNumber,
      dayOfWeekFormatter,
      slots,
      slotProps,
      loading,
      renderLoading,
      displayWeekNumber,
      yearsPerRow,
      monthsPerRow,
      timezone: timezoneProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$r);
    const {
      value,
      handleValueChange,
      timezone
    } = useControlledValueWithTimezone({
      name: "DateCalendar",
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange,
      valueManager: singleItemValueManager
    });
    const {
      view,
      setView,
      focusedView,
      setFocusedView,
      goToNextView,
      setValueAndGoToNextView
    } = useViews({
      view: inView,
      views,
      openTo,
      onChange: handleValueChange,
      onViewChange,
      autoFocus,
      focusedView: inFocusedView,
      onFocusedViewChange
    });
    const {
      referenceDate,
      calendarState,
      changeFocusedDay,
      changeMonth,
      handleChangeMonth,
      isDateDisabled,
      onMonthSwitchingAnimationEnd
    } = useCalendarState({
      value,
      referenceDate: referenceDateProp,
      reduceAnimations,
      onMonthChange,
      minDate,
      maxDate,
      shouldDisableDate,
      disablePast,
      disableFuture,
      timezone
    });
    const minDateWithDisabled = disabled && value || minDate;
    const maxDateWithDisabled = disabled && value || maxDate;
    const gridLabelId = `${id2}-grid-label`;
    const hasFocus = focusedView !== null;
    const CalendarHeader = (slots == null ? void 0 : slots.calendarHeader) ?? PickersCalendarHeader;
    const calendarHeaderProps = useSlotProps({
      elementType: CalendarHeader,
      externalSlotProps: slotProps == null ? void 0 : slotProps.calendarHeader,
      additionalProps: {
        views,
        view,
        currentMonth: calendarState.currentMonth,
        onViewChange: setView,
        onMonthChange: (newMonth, direction) => handleChangeMonth({
          newMonth,
          direction
        }),
        minDate: minDateWithDisabled,
        maxDate: maxDateWithDisabled,
        disabled,
        disablePast,
        disableFuture,
        reduceAnimations,
        timezone,
        labelId: gridLabelId
      },
      ownerState: props
    });
    const handleDateMonthChange = useEventCallback((newDate) => {
      const startOfMonth = utils2.startOfMonth(newDate);
      const endOfMonth = utils2.endOfMonth(newDate);
      const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
        utils: utils2,
        date: newDate,
        minDate: utils2.isBefore(minDate, startOfMonth) ? startOfMonth : minDate,
        maxDate: utils2.isAfter(maxDate, endOfMonth) ? endOfMonth : maxDate,
        disablePast,
        disableFuture,
        isDateDisabled,
        timezone
      }) : newDate;
      if (closestEnabledDate) {
        setValueAndGoToNextView(closestEnabledDate, "finish");
        onMonthChange == null ? void 0 : onMonthChange(startOfMonth);
      } else {
        goToNextView();
        changeMonth(startOfMonth);
      }
      changeFocusedDay(closestEnabledDate, true);
    });
    const handleDateYearChange = useEventCallback((newDate) => {
      const startOfYear = utils2.startOfYear(newDate);
      const endOfYear = utils2.endOfYear(newDate);
      const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
        utils: utils2,
        date: newDate,
        minDate: utils2.isBefore(minDate, startOfYear) ? startOfYear : minDate,
        maxDate: utils2.isAfter(maxDate, endOfYear) ? endOfYear : maxDate,
        disablePast,
        disableFuture,
        isDateDisabled,
        timezone
      }) : newDate;
      if (closestEnabledDate) {
        setValueAndGoToNextView(closestEnabledDate, "finish");
        onYearChange == null ? void 0 : onYearChange(closestEnabledDate);
      } else {
        goToNextView();
        changeMonth(startOfYear);
      }
      changeFocusedDay(closestEnabledDate, true);
    });
    const handleSelectedDayChange = useEventCallback((day) => {
      if (day) {
        return handleValueChange(mergeDateAndTime(utils2, day, value ?? referenceDate), "finish", view);
      }
      return handleValueChange(day, "finish", view);
    });
    reactExports.useEffect(() => {
      if (value != null && utils2.isValid(value)) {
        changeMonth(value);
      }
    }, [value]);
    const ownerState = props;
    const classes = useUtilityClasses$j(ownerState);
    const baseDateValidationProps = {
      disablePast,
      disableFuture,
      maxDate,
      minDate
    };
    const commonViewProps = {
      disableHighlightToday,
      readOnly,
      disabled,
      timezone,
      gridLabelId,
      slots,
      slotProps
    };
    const prevOpenViewRef = reactExports.useRef(view);
    reactExports.useEffect(() => {
      if (prevOpenViewRef.current === view) {
        return;
      }
      if (focusedView === prevOpenViewRef.current) {
        setFocusedView(view, true);
      }
      prevOpenViewRef.current = view;
    }, [focusedView, setFocusedView, view]);
    const selectedDays = reactExports.useMemo(() => [value], [value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(DateCalendarRoot, _extends$1({
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(CalendarHeader, _extends$1({}, calendarHeaderProps, {
        slots,
        slotProps
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(DateCalendarViewTransitionContainer, {
        reduceAnimations,
        className: classes.viewTransitionContainer,
        transKey: view,
        ownerState,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          children: [view === "year" && /* @__PURE__ */ jsxRuntimeExports.jsx(YearCalendar, _extends$1({}, baseDateValidationProps, commonViewProps, {
            value,
            onChange: handleDateYearChange,
            shouldDisableYear,
            hasFocus,
            onFocusedViewChange: (isViewFocused) => setFocusedView("year", isViewFocused),
            yearsPerRow,
            referenceDate
          })), view === "month" && /* @__PURE__ */ jsxRuntimeExports.jsx(MonthCalendar, _extends$1({}, baseDateValidationProps, commonViewProps, {
            hasFocus,
            className,
            value,
            onChange: handleDateMonthChange,
            shouldDisableMonth,
            onFocusedViewChange: (isViewFocused) => setFocusedView("month", isViewFocused),
            monthsPerRow,
            referenceDate
          })), view === "day" && /* @__PURE__ */ jsxRuntimeExports.jsx(DayCalendar, _extends$1({}, calendarState, baseDateValidationProps, commonViewProps, {
            onMonthSwitchingAnimationEnd,
            onFocusedDayChange: changeFocusedDay,
            reduceAnimations,
            selectedDays,
            onSelectedDaysChange: handleSelectedDayChange,
            shouldDisableDate,
            shouldDisableMonth,
            shouldDisableYear,
            hasFocus,
            onFocusedViewChange: (isViewFocused) => setFocusedView("day", isViewFocused),
            showDaysOutsideCurrentMonth,
            fixedWeekNumber,
            dayOfWeekFormatter,
            displayWeekNumber,
            loading,
            renderLoading
          }))]
        })
      })]
    }));
  });
  const renderDateViewCalendar = ({
    view,
    onViewChange,
    views,
    focusedView,
    onFocusedViewChange,
    value,
    defaultValue,
    referenceDate,
    onChange,
    className,
    classes,
    disableFuture,
    disablePast,
    minDate,
    maxDate,
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    reduceAnimations,
    onMonthChange,
    monthsPerRow,
    onYearChange,
    yearsPerRow,
    slots,
    slotProps,
    loading,
    renderLoading,
    disableHighlightToday,
    readOnly,
    disabled,
    showDaysOutsideCurrentMonth,
    dayOfWeekFormatter,
    sx,
    autoFocus,
    fixedWeekNumber,
    displayWeekNumber,
    timezone
  }) => /* @__PURE__ */ jsxRuntimeExports.jsx(DateCalendar, {
    view,
    onViewChange,
    views: views.filter(isDatePickerView),
    focusedView: focusedView && isDatePickerView(focusedView) ? focusedView : null,
    onFocusedViewChange,
    value,
    defaultValue,
    referenceDate,
    onChange,
    className,
    classes,
    disableFuture,
    disablePast,
    minDate,
    maxDate,
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    reduceAnimations,
    onMonthChange,
    monthsPerRow,
    onYearChange,
    yearsPerRow,
    slots,
    slotProps,
    loading,
    renderLoading,
    disableHighlightToday,
    readOnly,
    disabled,
    showDaysOutsideCurrentMonth,
    dayOfWeekFormatter,
    sx,
    autoFocus,
    fixedWeekNumber,
    displayWeekNumber,
    timezone
  });
  var useThemeWithoutDefault = {};
  Object.defineProperty(useThemeWithoutDefault, "__esModule", {
    value: true
  });
  var default_1 = useThemeWithoutDefault.default = void 0;
  var React = _interopRequireWildcard(reactExports);
  var _styledEngine = require$$1;
  function _getRequireWildcardCache(e2) {
    if ("function" != typeof WeakMap)
      return null;
    var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(e3) {
      return e3 ? t2 : r2;
    })(e2);
  }
  function _interopRequireWildcard(e2, r2) {
    if (e2 && e2.__esModule)
      return e2;
    if (null === e2 || "object" != typeof e2 && "function" != typeof e2)
      return { default: e2 };
    var t2 = _getRequireWildcardCache(r2);
    if (t2 && t2.has(e2))
      return t2.get(e2);
    var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u2 in e2)
      if ("default" !== u2 && Object.prototype.hasOwnProperty.call(e2, u2)) {
        var i = a ? Object.getOwnPropertyDescriptor(e2, u2) : null;
        i && (i.get || i.set) ? Object.defineProperty(n2, u2, i) : n2[u2] = e2[u2];
      }
    return n2.default = e2, t2 && t2.set(e2, n2), n2;
  }
  function isObjectEmpty(obj) {
    return Object.keys(obj).length === 0;
  }
  function useTheme(defaultTheme2 = null) {
    const contextTheme = React.useContext(_styledEngine.ThemeContext);
    return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
  }
  default_1 = useThemeWithoutDefault.default = useTheme;
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main$1 = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main$1, afterMain, beforeWrite, write, afterWrite];
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  function getWindow(node2) {
    if (node2 == null) {
      return window;
    }
    if (node2.toString() !== "[object Window]") {
      var ownerDocument2 = node2.ownerDocument;
      return ownerDocument2 ? ownerDocument2.defaultView || window : window;
    }
    return node2;
  }
  function isElement(node2) {
    var OwnElement = getWindow(node2).Element;
    return node2 instanceof OwnElement || node2 instanceof Element;
  }
  function isHTMLElement$1(node2) {
    var OwnElement = getWindow(node2).HTMLElement;
    return node2 instanceof OwnElement || node2 instanceof HTMLElement;
  }
  function isShadowRoot(node2) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node2).ShadowRoot;
    return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
  }
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style2 = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement$1(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style2 = styleProperties.reduce(function(style3, property) {
          style3[property] = "";
          return style3;
        }, {});
        if (!isHTMLElement$1(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  const applyStyles$1 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect$2,
    requires: ["computeStyles"]
  };
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement$1(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width2 = clientRect.width / scaleX;
    var height2 = clientRect.height / scaleY;
    return {
      width: width2,
      height: height2,
      top: y2,
      right: x2 + width2,
      bottom: y2 + height2,
      left: x2,
      x: x2,
      y: y2
    };
  }
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width2 = element.offsetWidth;
    var height2 = element.offsetHeight;
    if (Math.abs(clientRect.width - width2) <= 1) {
      width2 = clientRect.width;
    }
    if (Math.abs(clientRect.height - height2) <= 1) {
      height2 = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width2,
      height: height2
    };
  }
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next2 = child;
      do {
        if (next2 && parent.isSameNode(next2)) {
          return true;
        }
        next2 = next2.parentNode || next2.host;
      } while (next2);
    }
    return false;
  }
  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }
  function getTrueOffsetParent(element) {
    if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle$1(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement$1(element)) {
      var elementCss = getComputedStyle$1(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css2 = getComputedStyle$1(currentNode);
      if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }
  function withinMaxClamp(min2, value, max2) {
    var v2 = within(min2, value, max2);
    return v2 > max2 ? max2 : v2;
  }
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }
  var toPaddingObject = function toPaddingObject2(padding2, state) {
    padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding2;
    return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options2 = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options2.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect$1(_ref2) {
    var state = _ref2.state, options2 = _ref2.options;
    var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  const arrow$1 = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect$1,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x2 = _ref.x, y2 = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x2 * dpr) / dpr || 0,
      y: round(y2 * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x: x2,
      y: y2
    }) : {
      x: x2,
      y: y2
    };
    x2 = _ref3.x;
    y2 = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle$1(offsetParent).position !== "static" && position2 === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y2 -= offsetY - popperRect.height;
        y2 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x2 -= offsetX - popperRect.width;
        x2 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position: position2
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x2,
      y: y2
    }, getWindow(popper2)) : {
      x: x2,
      y: y2
    };
    x2 = _ref4.x;
    y2 = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options2 = _ref5.options;
    var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  const computeStyles$1 = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };
  var passive = {
    passive: true
  };
  function effect(_ref) {
    var state = _ref.state, instance = _ref.instance, options2 = _ref.options;
    var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  const eventListeners = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect,
    data: {}
  };
  var hash$1 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash$1[matched];
    });
  }
  var hash = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash[matched];
    });
  }
  function getWindowScroll(node2) {
    var win = getWindow(node2);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width2 = html.clientWidth;
    var height2 = html.clientHeight;
    var x2 = 0;
    var y2 = 0;
    if (visualViewport) {
      width2 = visualViewport.width;
      height2 = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    return {
      width: width2,
      height: height2,
      x: x2 + getWindowScrollBarX(element),
      y: y2
    };
  }
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width2 = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height2 = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y2 = -winScroll.scrollTop;
    if (getComputedStyle$1(body || html).direction === "rtl") {
      x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width2;
    }
    return {
      width: width2,
      height: height2,
      x: x2,
      y: y2
    };
  }
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  function getScrollParent(node2) {
    if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
      return node2.ownerDocument.body;
    }
    if (isHTMLElement$1(node2) && isScrollParent(node2)) {
      return node2;
    }
    return getScrollParent(getParentNode(node2));
  }
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
      }
    }
    return offsets;
  }
  function detectOverflow(state, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }
  function computeAutoPlacement(state, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding: padding2
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b2) {
      return overflows[a] - overflows[b2];
    });
  }
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options2 = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding2 = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding: padding2,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding: padding2
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  const flip$1 = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  const hide$1 = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options2 = _ref2.options, name = _ref2.name;
    var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x2;
      state.modifiersData.popperOffsets.y += y2;
    }
    state.modifiersData[name] = data;
  }
  const offset$1 = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  const popperOffsets$1 = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function preventOverflow(_ref) {
    var state = _ref.state, options2 = _ref.options, name = _ref.name;
    var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding2 = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding: padding2,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min$1 = offset2 + overflow[mainSide];
      var max$1 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  const preventOverflow$1 = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  function getNodeScroll(node2) {
    if (node2 === getWindow(node2) || !isHTMLElement$1(node2)) {
      return getWindowScroll(node2);
    } else {
      return getHTMLElementScroll(node2);
    }
  }
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
    var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement$1(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  function debounce(fn) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn());
          });
        });
      }
      return pending;
    };
  }
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options2) {
      if (options2 === void 0) {
        options2 = defaultOptions;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options3);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m2) {
            return m2.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn === "function") {
              state = fn({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance;
      }
      instance.setOptions(options2).then(function(state2) {
        if (!isDestroyed && options2.onFirstUpdate) {
          options2.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options3 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
          if (typeof effect2 === "function") {
            var cleanupFn = effect2({
              state,
              name,
              instance,
              options: options3
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn) {
          return fn();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });
  function getPopperUtilityClass(slot) {
    return generateUtilityClass("MuiPopper", slot);
  }
  generateUtilityClasses("MuiPopper", ["root"]);
  const _excluded$q = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"], _excluded2$3 = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
  function flipPlacement(placement, direction) {
    if (direction === "ltr") {
      return placement;
    }
    switch (placement) {
      case "bottom-end":
        return "bottom-start";
      case "bottom-start":
        return "bottom-end";
      case "top-end":
        return "top-start";
      case "top-start":
        return "top-end";
      default:
        return placement;
    }
  }
  function resolveAnchorEl(anchorEl) {
    return typeof anchorEl === "function" ? anchorEl() : anchorEl;
  }
  function isHTMLElement(element) {
    return element.nodeType !== void 0;
  }
  const useUtilityClasses$i = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getPopperUtilityClass, classes);
  };
  const defaultPopperOptions = {};
  const PopperTooltip = /* @__PURE__ */ reactExports.forwardRef(function PopperTooltip2(props, forwardedRef) {
    var _slots$root;
    const {
      anchorEl,
      children,
      direction,
      disablePortal,
      modifiers,
      open,
      placement: initialPlacement,
      popperOptions,
      popperRef: popperRefProp,
      slotProps = {},
      slots = {},
      TransitionProps
      // @ts-ignore internal logic
      // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$q);
    const tooltipRef = reactExports.useRef(null);
    const ownRef = useForkRef(tooltipRef, forwardedRef);
    const popperRef = reactExports.useRef(null);
    const handlePopperRef = useForkRef(popperRef, popperRefProp);
    const handlePopperRefRef = reactExports.useRef(handlePopperRef);
    useEnhancedEffect(() => {
      handlePopperRefRef.current = handlePopperRef;
    }, [handlePopperRef]);
    reactExports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
    const rtlPlacement = flipPlacement(initialPlacement, direction);
    const [placement, setPlacement] = reactExports.useState(rtlPlacement);
    const [resolvedAnchorElement, setResolvedAnchorElement] = reactExports.useState(resolveAnchorEl(anchorEl));
    reactExports.useEffect(() => {
      if (popperRef.current) {
        popperRef.current.forceUpdate();
      }
    });
    reactExports.useEffect(() => {
      if (anchorEl) {
        setResolvedAnchorElement(resolveAnchorEl(anchorEl));
      }
    }, [anchorEl]);
    useEnhancedEffect(() => {
      if (!resolvedAnchorElement || !open) {
        return void 0;
      }
      const handlePopperUpdate = (data) => {
        setPlacement(data.placement);
      };
      let popperModifiers = [{
        name: "preventOverflow",
        options: {
          altBoundary: disablePortal
        }
      }, {
        name: "flip",
        options: {
          altBoundary: disablePortal
        }
      }, {
        name: "onUpdate",
        enabled: true,
        phase: "afterWrite",
        fn: ({
          state
        }) => {
          handlePopperUpdate(state);
        }
      }];
      if (modifiers != null) {
        popperModifiers = popperModifiers.concat(modifiers);
      }
      if (popperOptions && popperOptions.modifiers != null) {
        popperModifiers = popperModifiers.concat(popperOptions.modifiers);
      }
      const popper2 = createPopper(resolvedAnchorElement, tooltipRef.current, _extends$1({
        placement: rtlPlacement
      }, popperOptions, {
        modifiers: popperModifiers
      }));
      handlePopperRefRef.current(popper2);
      return () => {
        popper2.destroy();
        handlePopperRefRef.current(null);
      };
    }, [resolvedAnchorElement, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
    const childProps = {
      placement
    };
    if (TransitionProps !== null) {
      childProps.TransitionProps = TransitionProps;
    }
    const classes = useUtilityClasses$i(props);
    const Root2 = (_slots$root = slots.root) != null ? _slots$root : "div";
    const rootProps = useSlotProps({
      elementType: Root2,
      externalSlotProps: slotProps.root,
      externalForwardedProps: other,
      additionalProps: {
        role: "tooltip",
        ref: ownRef
      },
      ownerState: props,
      className: classes.root
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2, _extends$1({}, rootProps, {
      children: typeof children === "function" ? children(childProps) : children
    }));
  });
  const Popper$1 = /* @__PURE__ */ reactExports.forwardRef(function Popper2(props, forwardedRef) {
    const {
      anchorEl,
      children,
      container: containerProp,
      direction = "ltr",
      disablePortal = false,
      keepMounted = false,
      modifiers,
      open,
      placement = "bottom",
      popperOptions = defaultPopperOptions,
      popperRef,
      style: style2,
      transition = false,
      slotProps = {},
      slots = {}
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded2$3);
    const [exited, setExited] = reactExports.useState(true);
    const handleEnter = () => {
      setExited(false);
    };
    const handleExited = () => {
      setExited(true);
    };
    if (!keepMounted && !open && (!transition || exited)) {
      return null;
    }
    let container;
    if (containerProp) {
      container = containerProp;
    } else if (anchorEl) {
      const resolvedAnchorEl = resolveAnchorEl(anchorEl);
      container = resolvedAnchorEl && isHTMLElement(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
    }
    const display = !open && keepMounted && (!transition || exited) ? "none" : void 0;
    const transitionProps = transition ? {
      in: open,
      onEnter: handleEnter,
      onExited: handleExited
    } : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
      disablePortal,
      container,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperTooltip, _extends$1({
        anchorEl,
        direction,
        disablePortal,
        modifiers,
        ref: forwardedRef,
        open: transition ? !exited : open,
        placement,
        popperOptions,
        popperRef,
        slotProps,
        slots
      }, other, {
        style: _extends$1({
          // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
          position: "fixed",
          // Fix Popper.js display issue
          top: 0,
          left: 0,
          display
        }, style2),
        TransitionProps: transitionProps,
        children
      }))
    });
  });
  const _excluded$p = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"];
  const PopperRoot = styled(Popper$1, {
    name: "MuiPopper",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const Popper = /* @__PURE__ */ reactExports.forwardRef(function Popper2(inProps, ref) {
    var _slots$root;
    const theme = default_1();
    const props = useDefaultProps({
      props: inProps,
      name: "MuiPopper"
    });
    const {
      anchorEl,
      component,
      components,
      componentsProps,
      container,
      disablePortal,
      keepMounted,
      modifiers,
      open,
      placement,
      popperOptions,
      popperRef,
      transition,
      slots,
      slotProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$p);
    const RootComponent = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components == null ? void 0 : components.Root;
    const otherProps = _extends$1({
      anchorEl,
      container,
      disablePortal,
      keepMounted,
      modifiers,
      open,
      placement,
      popperOptions,
      popperRef,
      transition
    }, other);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperRoot, _extends$1({
      as: component,
      direction: theme == null ? void 0 : theme.direction,
      slots: {
        root: RootComponent
      },
      slotProps: slotProps != null ? slotProps : componentsProps
    }, otherProps, {
      ref
    }));
  });
  function getPickersPopperUtilityClass(slot) {
    return generateUtilityClass("MuiPickersPopper", slot);
  }
  generateUtilityClasses("MuiPickersPopper", ["root", "paper"]);
  const _excluded$o = ["PaperComponent", "popperPlacement", "ownerState", "children", "paperSlotProps", "paperClasses", "onPaperClick", "onPaperTouchStart"];
  const useUtilityClasses$h = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      paper: ["paper"]
    };
    return composeClasses(slots, getPickersPopperUtilityClass, classes);
  };
  const PickersPopperRoot = styled(Popper, {
    name: "MuiPickersPopper",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })(({
    theme
  }) => ({
    zIndex: theme.zIndex.modal
  }));
  const PickersPopperPaper = styled(Paper, {
    name: "MuiPickersPopper",
    slot: "Paper",
    overridesResolver: (_2, styles2) => styles2.paper
  })({
    outline: 0,
    transformOrigin: "top center",
    variants: [{
      props: ({
        placement
      }) => ["top", "top-start", "top-end"].includes(placement),
      style: {
        transformOrigin: "bottom center"
      }
    }]
  });
  function clickedRootScrollbar(event, doc) {
    return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
  }
  function useClickAwayListener(active, onClickAway) {
    const movedRef = reactExports.useRef(false);
    const syntheticEventRef = reactExports.useRef(false);
    const nodeRef = reactExports.useRef(null);
    const activatedRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      if (!active) {
        return void 0;
      }
      function armClickAwayListener() {
        activatedRef.current = true;
      }
      document.addEventListener("mousedown", armClickAwayListener, true);
      document.addEventListener("touchstart", armClickAwayListener, true);
      return () => {
        document.removeEventListener("mousedown", armClickAwayListener, true);
        document.removeEventListener("touchstart", armClickAwayListener, true);
        activatedRef.current = false;
      };
    }, [active]);
    const handleClickAway = useEventCallback((event) => {
      if (!activatedRef.current) {
        return;
      }
      const insideReactTree = syntheticEventRef.current;
      syntheticEventRef.current = false;
      const doc = ownerDocument(nodeRef.current);
      if (!nodeRef.current || // is a TouchEvent?
      "clientX" in event && clickedRootScrollbar(event, doc)) {
        return;
      }
      if (movedRef.current) {
        movedRef.current = false;
        return;
      }
      let insideDOM;
      if (event.composedPath) {
        insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
      } else {
        insideDOM = !doc.documentElement.contains(event.target) || nodeRef.current.contains(event.target);
      }
      if (!insideDOM && !insideReactTree) {
        onClickAway(event);
      }
    });
    const handleSynthetic = () => {
      syntheticEventRef.current = true;
    };
    reactExports.useEffect(() => {
      if (active) {
        const doc = ownerDocument(nodeRef.current);
        const handleTouchMove = () => {
          movedRef.current = true;
        };
        doc.addEventListener("touchstart", handleClickAway);
        doc.addEventListener("touchmove", handleTouchMove);
        return () => {
          doc.removeEventListener("touchstart", handleClickAway);
          doc.removeEventListener("touchmove", handleTouchMove);
        };
      }
      return void 0;
    }, [active, handleClickAway]);
    reactExports.useEffect(() => {
      if (active) {
        const doc = ownerDocument(nodeRef.current);
        doc.addEventListener("click", handleClickAway);
        return () => {
          doc.removeEventListener("click", handleClickAway);
          syntheticEventRef.current = false;
        };
      }
      return void 0;
    }, [active, handleClickAway]);
    return [nodeRef, handleSynthetic, handleSynthetic];
  }
  const PickersPopperPaperWrapper = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
    const {
      PaperComponent,
      popperPlacement,
      ownerState: inOwnerState,
      children,
      paperSlotProps,
      paperClasses,
      onPaperClick,
      onPaperTouchStart
      // picks up the style props provided by `Transition`
      // https://mui.com/material-ui/transitions/#child-requirement
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$o);
    const ownerState = _extends$1({}, inOwnerState, {
      placement: popperPlacement
    });
    const paperProps = useSlotProps({
      elementType: PaperComponent,
      externalSlotProps: paperSlotProps,
      additionalProps: {
        tabIndex: -1,
        elevation: 8,
        ref
      },
      className: paperClasses,
      ownerState
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperComponent, _extends$1({}, other, paperProps, {
      onClick: (event) => {
        var _a;
        onPaperClick(event);
        (_a = paperProps.onClick) == null ? void 0 : _a.call(paperProps, event);
      },
      onTouchStart: (event) => {
        var _a;
        onPaperTouchStart(event);
        (_a = paperProps.onTouchStart) == null ? void 0 : _a.call(paperProps, event);
      },
      ownerState,
      children
    }));
  });
  function PickersPopper(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersPopper"
    });
    const {
      anchorEl,
      children,
      containerRef = null,
      shouldRestoreFocus,
      onBlur,
      onDismiss,
      open,
      role,
      placement,
      slots,
      slotProps,
      reduceAnimations: inReduceAnimations
    } = props;
    reactExports.useEffect(() => {
      function handleKeyDown3(nativeEvent) {
        if (open && nativeEvent.key === "Escape") {
          onDismiss();
        }
      }
      document.addEventListener("keydown", handleKeyDown3);
      return () => {
        document.removeEventListener("keydown", handleKeyDown3);
      };
    }, [onDismiss, open]);
    const lastFocusedElementRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      if (role === "tooltip" || shouldRestoreFocus && !shouldRestoreFocus()) {
        return;
      }
      if (open) {
        lastFocusedElementRef.current = getActiveElement(document);
      } else if (lastFocusedElementRef.current && lastFocusedElementRef.current instanceof HTMLElement) {
        setTimeout(() => {
          if (lastFocusedElementRef.current instanceof HTMLElement) {
            lastFocusedElementRef.current.focus();
          }
        });
      }
    }, [open, role, shouldRestoreFocus]);
    const [clickAwayRef, onPaperClick, onPaperTouchStart] = useClickAwayListener(open, onBlur ?? onDismiss);
    const paperRef = reactExports.useRef(null);
    const handleRef = useForkRef(paperRef, containerRef);
    const handlePaperRef = useForkRef(handleRef, clickAwayRef);
    const ownerState = props;
    const classes = useUtilityClasses$h(ownerState);
    const defaultReduceAnimations = useDefaultReduceAnimations();
    const reduceAnimations = inReduceAnimations ?? defaultReduceAnimations;
    const handleKeyDown2 = (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        onDismiss();
      }
    };
    const Transition2 = (slots == null ? void 0 : slots.desktopTransition) ?? reduceAnimations ? Fade : Grow;
    const FocusTrap$1 = (slots == null ? void 0 : slots.desktopTrapFocus) ?? FocusTrap;
    const Paper2 = (slots == null ? void 0 : slots.desktopPaper) ?? PickersPopperPaper;
    const Popper2 = (slots == null ? void 0 : slots.popper) ?? PickersPopperRoot;
    const popperProps = useSlotProps({
      elementType: Popper2,
      externalSlotProps: slotProps == null ? void 0 : slotProps.popper,
      additionalProps: {
        transition: true,
        role,
        open,
        anchorEl,
        placement,
        onKeyDown: handleKeyDown2
      },
      className: classes.root,
      ownerState: props
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Popper2, _extends$1({}, popperProps, {
      children: ({
        TransitionProps,
        placement: popperPlacement
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap$1, _extends$1({
        open,
        disableAutoFocus: true,
        disableRestoreFocus: true,
        disableEnforceFocus: role === "tooltip",
        isEnabled: () => true
      }, slotProps == null ? void 0 : slotProps.desktopTrapFocus, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Transition2, _extends$1({}, TransitionProps, slotProps == null ? void 0 : slotProps.desktopTransition, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersPopperPaperWrapper, {
            PaperComponent: Paper2,
            ownerState,
            popperPlacement,
            ref: handlePaperRef,
            onPaperClick,
            onPaperTouchStart,
            paperClasses: classes.paper,
            paperSlotProps: slotProps == null ? void 0 : slotProps.desktopPaper,
            children
          })
        }))
      }))
    }));
  }
  const useOpenState = ({
    open,
    onOpen,
    onClose
  }) => {
    const isControllingOpenProp = reactExports.useRef(typeof open === "boolean").current;
    const [openState, setIsOpenState] = reactExports.useState(false);
    reactExports.useEffect(() => {
      if (isControllingOpenProp) {
        if (typeof open !== "boolean") {
          throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");
        }
        setIsOpenState(open);
      }
    }, [isControllingOpenProp, open]);
    const setIsOpen = reactExports.useCallback((newIsOpen) => {
      if (!isControllingOpenProp) {
        setIsOpenState(newIsOpen);
      }
      if (newIsOpen && onOpen) {
        onOpen();
      }
      if (!newIsOpen && onClose) {
        onClose();
      }
    }, [isControllingOpenProp, onOpen, onClose]);
    return {
      isOpen: openState,
      setIsOpen
    };
  };
  const shouldPublishValue = (params) => {
    const {
      action,
      hasChanged,
      dateState,
      isControlled
    } = params;
    const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
    if (action.name === "setValueFromField") {
      return true;
    }
    if (action.name === "setValueFromAction") {
      if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
        return true;
      }
      return hasChanged(dateState.lastPublishedValue);
    }
    if (action.name === "setValueFromView" && action.selectionState !== "shallow") {
      if (isCurrentValueTheDefaultValue) {
        return true;
      }
      return hasChanged(dateState.lastPublishedValue);
    }
    if (action.name === "setValueFromShortcut") {
      if (isCurrentValueTheDefaultValue) {
        return true;
      }
      return hasChanged(dateState.lastPublishedValue);
    }
    return false;
  };
  const shouldCommitValue = (params) => {
    const {
      action,
      hasChanged,
      dateState,
      isControlled,
      closeOnSelect
    } = params;
    const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
    if (action.name === "setValueFromAction") {
      if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
        return true;
      }
      return hasChanged(dateState.lastCommittedValue);
    }
    if (action.name === "setValueFromView" && action.selectionState === "finish" && closeOnSelect) {
      if (isCurrentValueTheDefaultValue) {
        return true;
      }
      return hasChanged(dateState.lastCommittedValue);
    }
    if (action.name === "setValueFromShortcut") {
      return action.changeImportance === "accept" && hasChanged(dateState.lastCommittedValue);
    }
    return false;
  };
  const shouldClosePicker = (params) => {
    const {
      action,
      closeOnSelect
    } = params;
    if (action.name === "setValueFromAction") {
      return true;
    }
    if (action.name === "setValueFromView") {
      return action.selectionState === "finish" && closeOnSelect;
    }
    if (action.name === "setValueFromShortcut") {
      return action.changeImportance === "accept";
    }
    return false;
  };
  const usePickerValue = ({
    props,
    valueManager,
    valueType,
    wrapperVariant,
    validator: validator2
  }) => {
    const {
      onAccept,
      onChange,
      value: inValueWithoutRenderTimezone,
      defaultValue: inDefaultValue,
      closeOnSelect = wrapperVariant === "desktop",
      timezone: timezoneProp
    } = props;
    const {
      current: defaultValue
    } = reactExports.useRef(inDefaultValue);
    const {
      current: isControlled
    } = reactExports.useRef(inValueWithoutRenderTimezone !== void 0);
    const utils2 = useUtils();
    const adapter = useLocalizationContext();
    const {
      isOpen,
      setIsOpen
    } = useOpenState(props);
    const {
      timezone,
      value: inValueWithTimezoneToRender,
      handleValueChange
    } = useValueWithTimezone({
      timezone: timezoneProp,
      value: inValueWithoutRenderTimezone,
      defaultValue,
      onChange,
      valueManager
    });
    const [dateState, setDateState] = reactExports.useState(() => {
      let initialValue;
      if (inValueWithTimezoneToRender !== void 0) {
        initialValue = inValueWithTimezoneToRender;
      } else if (defaultValue !== void 0) {
        initialValue = defaultValue;
      } else {
        initialValue = valueManager.emptyValue;
      }
      return {
        draft: initialValue,
        lastPublishedValue: initialValue,
        lastCommittedValue: initialValue,
        lastControlledValue: inValueWithTimezoneToRender,
        hasBeenModifiedSinceMount: false
      };
    });
    useValidation(_extends$1({}, props, {
      value: dateState.draft,
      timezone
    }), validator2, valueManager.isSameError, valueManager.defaultErrorState);
    const updateDate = useEventCallback((action) => {
      const updaterParams = {
        action,
        dateState,
        hasChanged: (comparison) => !valueManager.areValuesEqual(utils2, action.value, comparison),
        isControlled,
        closeOnSelect
      };
      const shouldPublish = shouldPublishValue(updaterParams);
      const shouldCommit = shouldCommitValue(updaterParams);
      const shouldClose = shouldClosePicker(updaterParams);
      setDateState((prev2) => _extends$1({}, prev2, {
        draft: action.value,
        lastPublishedValue: shouldPublish ? action.value : prev2.lastPublishedValue,
        lastCommittedValue: shouldCommit ? action.value : prev2.lastCommittedValue,
        hasBeenModifiedSinceMount: true
      }));
      let cachedContext = null;
      const getContext = () => {
        if (!cachedContext) {
          const validationError = action.name === "setValueFromField" ? action.context.validationError : validator2({
            adapter,
            value: action.value,
            props: _extends$1({}, props, {
              value: action.value,
              timezone
            })
          });
          cachedContext = {
            validationError
          };
          if (action.name === "setValueFromShortcut") {
            cachedContext.shortcut = action.shortcut;
          }
        }
        return cachedContext;
      };
      if (shouldPublish) {
        handleValueChange(action.value, getContext());
      }
      if (shouldCommit && onAccept) {
        onAccept(action.value, getContext());
      }
      if (shouldClose) {
        setIsOpen(false);
      }
    });
    if (inValueWithTimezoneToRender !== void 0 && (dateState.lastControlledValue === void 0 || !valueManager.areValuesEqual(utils2, dateState.lastControlledValue, inValueWithTimezoneToRender))) {
      const isUpdateComingFromPicker = valueManager.areValuesEqual(utils2, dateState.draft, inValueWithTimezoneToRender);
      setDateState((prev2) => _extends$1({}, prev2, {
        lastControlledValue: inValueWithTimezoneToRender
      }, isUpdateComingFromPicker ? {} : {
        lastCommittedValue: inValueWithTimezoneToRender,
        lastPublishedValue: inValueWithTimezoneToRender,
        draft: inValueWithTimezoneToRender,
        hasBeenModifiedSinceMount: true
      }));
    }
    const handleClear = useEventCallback(() => {
      updateDate({
        value: valueManager.emptyValue,
        name: "setValueFromAction",
        pickerAction: "clear"
      });
    });
    const handleAccept = useEventCallback(() => {
      updateDate({
        value: dateState.lastPublishedValue,
        name: "setValueFromAction",
        pickerAction: "accept"
      });
    });
    const handleDismiss = useEventCallback(() => {
      updateDate({
        value: dateState.lastPublishedValue,
        name: "setValueFromAction",
        pickerAction: "dismiss"
      });
    });
    const handleCancel = useEventCallback(() => {
      updateDate({
        value: dateState.lastCommittedValue,
        name: "setValueFromAction",
        pickerAction: "cancel"
      });
    });
    const handleSetToday = useEventCallback(() => {
      updateDate({
        value: valueManager.getTodayValue(utils2, timezone, valueType),
        name: "setValueFromAction",
        pickerAction: "today"
      });
    });
    const handleOpen = useEventCallback((event) => {
      event.preventDefault();
      setIsOpen(true);
    });
    const handleClose = useEventCallback((event) => {
      event == null ? void 0 : event.preventDefault();
      setIsOpen(false);
    });
    const handleChange = useEventCallback((newValue, selectionState = "partial") => updateDate({
      name: "setValueFromView",
      value: newValue,
      selectionState
    }));
    const handleSelectShortcut = useEventCallback((newValue, changeImportance, shortcut) => updateDate({
      name: "setValueFromShortcut",
      value: newValue,
      changeImportance,
      shortcut
    }));
    const handleChangeFromField = useEventCallback((newValue, context) => updateDate({
      name: "setValueFromField",
      value: newValue,
      context
    }));
    const actions = {
      onClear: handleClear,
      onAccept: handleAccept,
      onDismiss: handleDismiss,
      onCancel: handleCancel,
      onSetToday: handleSetToday,
      onOpen: handleOpen,
      onClose: handleClose
    };
    const fieldResponse = {
      value: dateState.draft,
      onChange: handleChangeFromField
    };
    const viewValue = reactExports.useMemo(() => valueManager.cleanValue(utils2, dateState.draft), [utils2, valueManager, dateState.draft]);
    const viewResponse = {
      value: viewValue,
      onChange: handleChange,
      onClose: handleClose,
      open: isOpen
    };
    const isValid = (testedValue) => {
      const error = validator2({
        adapter,
        value: testedValue,
        props: _extends$1({}, props, {
          value: testedValue,
          timezone
        })
      });
      return !valueManager.hasError(error);
    };
    const layoutResponse = _extends$1({}, actions, {
      value: viewValue,
      onChange: handleChange,
      onSelectShortcut: handleSelectShortcut,
      isValid
    });
    return {
      open: isOpen,
      fieldProps: fieldResponse,
      viewProps: viewResponse,
      layoutProps: layoutResponse,
      actions
    };
  };
  const _excluded$n = ["className", "sx"];
  const usePickerViews = ({
    props,
    propsFromPickerValue,
    additionalViewProps,
    autoFocusView,
    rendererInterceptor: rendererInterceptor2,
    fieldRef
  }) => {
    const {
      onChange,
      open,
      onClose
    } = propsFromPickerValue;
    const {
      view: inView,
      views,
      openTo,
      onViewChange,
      viewRenderers,
      timezone
    } = props;
    const propsToForwardToView = _objectWithoutPropertiesLoose(props, _excluded$n);
    const {
      view,
      setView,
      defaultView,
      focusedView,
      setFocusedView,
      setValueAndGoToNextView
    } = useViews({
      view: inView,
      views,
      openTo,
      onChange,
      onViewChange,
      autoFocus: autoFocusView
    });
    const {
      hasUIView,
      viewModeLookup
    } = reactExports.useMemo(() => views.reduce((acc, viewForReduce) => {
      let viewMode;
      if (viewRenderers[viewForReduce] != null) {
        viewMode = "UI";
      } else {
        viewMode = "field";
      }
      acc.viewModeLookup[viewForReduce] = viewMode;
      if (viewMode === "UI") {
        acc.hasUIView = true;
      }
      return acc;
    }, {
      hasUIView: false,
      viewModeLookup: {}
    }), [viewRenderers, views]);
    const timeViewsCount = reactExports.useMemo(() => views.reduce((acc, viewForReduce) => {
      if (viewRenderers[viewForReduce] != null && isTimeView(viewForReduce)) {
        return acc + 1;
      }
      return acc;
    }, 0), [viewRenderers, views]);
    const currentViewMode = viewModeLookup[view];
    const shouldRestoreFocus = useEventCallback(() => currentViewMode === "UI");
    const [popperView, setPopperView] = reactExports.useState(currentViewMode === "UI" ? view : null);
    if (popperView !== view && viewModeLookup[view] === "UI") {
      setPopperView(view);
    }
    useEnhancedEffect(() => {
      if (currentViewMode === "field" && open) {
        onClose();
        setTimeout(() => {
          var _a, _b;
          (_a = fieldRef == null ? void 0 : fieldRef.current) == null ? void 0 : _a.setSelectedSections(view);
          (_b = fieldRef == null ? void 0 : fieldRef.current) == null ? void 0 : _b.focusField(view);
        });
      }
    }, [view]);
    useEnhancedEffect(() => {
      if (!open) {
        return;
      }
      let newView = view;
      if (currentViewMode === "field" && popperView != null) {
        newView = popperView;
      }
      if (newView !== defaultView && viewModeLookup[newView] === "UI" && viewModeLookup[defaultView] === "UI") {
        newView = defaultView;
      }
      if (newView !== view) {
        setView(newView);
      }
      setFocusedView(newView, true);
    }, [open]);
    const layoutProps = {
      views,
      view: popperView,
      onViewChange: setView
    };
    return {
      hasUIView,
      shouldRestoreFocus,
      layoutProps,
      renderCurrentView: () => {
        if (popperView == null) {
          return null;
        }
        const renderer = viewRenderers[popperView];
        if (renderer == null) {
          return null;
        }
        const rendererProps = _extends$1({}, propsToForwardToView, additionalViewProps, propsFromPickerValue, {
          views,
          timezone,
          onChange: setValueAndGoToNextView,
          view: popperView,
          onViewChange: setView,
          focusedView,
          onFocusedViewChange: setFocusedView,
          showViewSwitcher: timeViewsCount > 1,
          timeViewsCount
        });
        if (rendererInterceptor2) {
          return rendererInterceptor2(viewRenderers, popperView, rendererProps);
        }
        return renderer(rendererProps);
      }
    };
  };
  function getOrientation() {
    if (typeof window === "undefined") {
      return "portrait";
    }
    if (window.screen && window.screen.orientation && window.screen.orientation.angle) {
      return Math.abs(window.screen.orientation.angle) === 90 ? "landscape" : "portrait";
    }
    if (window.orientation) {
      return Math.abs(Number(window.orientation)) === 90 ? "landscape" : "portrait";
    }
    return "portrait";
  }
  const useIsLandscape = (views, customOrientation) => {
    const [orientation, setOrientation] = reactExports.useState(getOrientation);
    useEnhancedEffect(() => {
      const eventHandler = () => {
        setOrientation(getOrientation());
      };
      window.addEventListener("orientationchange", eventHandler);
      return () => {
        window.removeEventListener("orientationchange", eventHandler);
      };
    }, []);
    if (arrayIncludes(views, ["hours", "minutes", "seconds"])) {
      return false;
    }
    const orientationToUse = customOrientation || orientation;
    return orientationToUse === "landscape";
  };
  const usePickerLayoutProps = ({
    props,
    propsFromPickerValue,
    propsFromPickerViews,
    wrapperVariant
  }) => {
    const {
      orientation
    } = props;
    const isLandscape = useIsLandscape(propsFromPickerViews.views, orientation);
    const isRtl = useRtl();
    const layoutProps = _extends$1({}, propsFromPickerViews, propsFromPickerValue, {
      isLandscape,
      isRtl,
      wrapperVariant,
      disabled: props.disabled,
      readOnly: props.readOnly
    });
    return {
      layoutProps
    };
  };
  const usePicker = ({
    props,
    valueManager,
    valueType,
    wrapperVariant,
    additionalViewProps,
    validator: validator2,
    autoFocusView,
    rendererInterceptor: rendererInterceptor2,
    fieldRef
  }) => {
    const pickerValueResponse = usePickerValue({
      props,
      valueManager,
      valueType,
      wrapperVariant,
      validator: validator2
    });
    const pickerViewsResponse = usePickerViews({
      props,
      additionalViewProps,
      autoFocusView,
      fieldRef,
      propsFromPickerValue: pickerValueResponse.viewProps,
      rendererInterceptor: rendererInterceptor2
    });
    const pickerLayoutResponse = usePickerLayoutProps({
      props,
      wrapperVariant,
      propsFromPickerValue: pickerValueResponse.layoutProps,
      propsFromPickerViews: pickerViewsResponse.layoutProps
    });
    return {
      // Picker value
      open: pickerValueResponse.open,
      actions: pickerValueResponse.actions,
      fieldProps: pickerValueResponse.fieldProps,
      // Picker views
      renderCurrentView: pickerViewsResponse.renderCurrentView,
      hasUIView: pickerViewsResponse.hasUIView,
      shouldRestoreFocus: pickerViewsResponse.shouldRestoreFocus,
      // Picker layout
      layoutProps: pickerLayoutResponse.layoutProps
    };
  };
  function getPickersLayoutUtilityClass(slot) {
    return generateUtilityClass("MuiPickersLayout", slot);
  }
  const pickersLayoutClasses = generateUtilityClasses("MuiPickersLayout", ["root", "landscape", "contentWrapper", "toolbar", "actionBar", "tabs", "shortcuts"]);
  function getDialogActionsUtilityClass(slot) {
    return generateUtilityClass("MuiDialogActions", slot);
  }
  generateUtilityClasses("MuiDialogActions", ["root", "spacing"]);
  const _excluded$m = ["className", "disableSpacing"];
  const useUtilityClasses$g = (ownerState) => {
    const {
      classes,
      disableSpacing
    } = ownerState;
    const slots = {
      root: ["root", !disableSpacing && "spacing"]
    };
    return composeClasses(slots, getDialogActionsUtilityClass, classes);
  };
  const DialogActionsRoot = styled("div", {
    name: "MuiDialogActions",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
    }
  })(({
    ownerState
  }) => _extends$1({
    display: "flex",
    alignItems: "center",
    padding: 8,
    justifyContent: "flex-end",
    flex: "0 0 auto"
  }, !ownerState.disableSpacing && {
    "& > :not(style) ~ :not(style)": {
      marginLeft: 8
    }
  }));
  const DialogActions = /* @__PURE__ */ reactExports.forwardRef(function DialogActions2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiDialogActions"
    });
    const {
      className,
      disableSpacing = false
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$m);
    const ownerState = _extends$1({}, props, {
      disableSpacing
    });
    const classes = useUtilityClasses$g(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActionsRoot, _extends$1({
      className: clsx(classes.root, className),
      ownerState,
      ref
    }, other));
  });
  const _excluded$l = ["onAccept", "onClear", "onCancel", "onSetToday", "actions"];
  function PickersActionBar(props) {
    const {
      onAccept,
      onClear,
      onCancel,
      onSetToday,
      actions
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$l);
    const translations = usePickersTranslations();
    if (actions == null || actions.length === 0) {
      return null;
    }
    const buttons = actions == null ? void 0 : actions.map((actionType) => {
      switch (actionType) {
        case "clear":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
            onClick: onClear,
            children: translations.clearButtonLabel
          }, actionType);
        case "cancel":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
            onClick: onCancel,
            children: translations.cancelButtonLabel
          }, actionType);
        case "accept":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
            onClick: onAccept,
            children: translations.okButtonLabel
          }, actionType);
        case "today":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
            onClick: onSetToday,
            children: translations.todayButtonLabel
          }, actionType);
        default:
          return null;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, _extends$1({}, other, {
      children: buttons
    }));
  }
  function getListItemUtilityClass(slot) {
    return generateUtilityClass("MuiListItem", slot);
  }
  const listItemClasses = generateUtilityClasses("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]);
  const listItemButtonClasses = generateUtilityClasses("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
  function getListItemSecondaryActionClassesUtilityClass(slot) {
    return generateUtilityClass("MuiListItemSecondaryAction", slot);
  }
  generateUtilityClasses("MuiListItemSecondaryAction", ["root", "disableGutters"]);
  const _excluded$k = ["className"];
  const useUtilityClasses$f = (ownerState) => {
    const {
      disableGutters,
      classes
    } = ownerState;
    const slots = {
      root: ["root", disableGutters && "disableGutters"]
    };
    return composeClasses(slots, getListItemSecondaryActionClassesUtilityClass, classes);
  };
  const ListItemSecondaryActionRoot = styled("div", {
    name: "MuiListItemSecondaryAction",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.disableGutters && styles2.disableGutters];
    }
  })(({
    ownerState
  }) => _extends$1({
    position: "absolute",
    right: 16,
    top: "50%",
    transform: "translateY(-50%)"
  }, ownerState.disableGutters && {
    right: 0
  }));
  const ListItemSecondaryAction = /* @__PURE__ */ reactExports.forwardRef(function ListItemSecondaryAction2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiListItemSecondaryAction"
    });
    const {
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$k);
    const context = reactExports.useContext(ListContext);
    const ownerState = _extends$1({}, props, {
      disableGutters: context.disableGutters
    });
    const classes = useUtilityClasses$f(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryActionRoot, _extends$1({
      className: clsx(classes.root, className),
      ownerState,
      ref
    }, other));
  });
  ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
  const _excluded$j = ["className"], _excluded2$2 = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"];
  const overridesResolver$1 = (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters, !ownerState.disablePadding && styles2.padding, ownerState.button && styles2.button, ownerState.hasSecondaryAction && styles2.secondaryAction];
  };
  const useUtilityClasses$e = (ownerState) => {
    const {
      alignItems,
      button,
      classes,
      dense,
      disabled,
      disableGutters,
      disablePadding,
      divider,
      hasSecondaryAction,
      selected
    } = ownerState;
    const slots = {
      root: ["root", dense && "dense", !disableGutters && "gutters", !disablePadding && "padding", divider && "divider", disabled && "disabled", button && "button", alignItems === "flex-start" && "alignItemsFlexStart", hasSecondaryAction && "secondaryAction", selected && "selected"],
      container: ["container"]
    };
    return composeClasses(slots, getListItemUtilityClass, classes);
  };
  const ListItemRoot = styled("div", {
    name: "MuiListItem",
    slot: "Root",
    overridesResolver: overridesResolver$1
  })(({
    theme,
    ownerState
  }) => _extends$1({
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "left"
  }, !ownerState.disablePadding && _extends$1({
    paddingTop: 8,
    paddingBottom: 8
  }, ownerState.dense && {
    paddingTop: 4,
    paddingBottom: 4
  }, !ownerState.disableGutters && {
    paddingLeft: 16,
    paddingRight: 16
  }, !!ownerState.secondaryAction && {
    // Add some space to avoid collision as `ListItemSecondaryAction`
    // is absolutely positioned.
    paddingRight: 48
  }), !!ownerState.secondaryAction && {
    [`& > .${listItemButtonClasses.root}`]: {
      paddingRight: 48
    }
  }, {
    [`&.${listItemClasses.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette.action.focus
    },
    [`&.${listItemClasses.selected}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity),
      [`&.${listItemClasses.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      }
    },
    [`&.${listItemClasses.disabled}`]: {
      opacity: (theme.vars || theme).palette.action.disabledOpacity
    }
  }, ownerState.alignItems === "flex-start" && {
    alignItems: "flex-start"
  }, ownerState.divider && {
    borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
    backgroundClip: "padding-box"
  }, ownerState.button && {
    transition: theme.transitions.create("background-color", {
      duration: theme.transitions.duration.shortest
    }),
    "&:hover": {
      textDecoration: "none",
      backgroundColor: (theme.vars || theme).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${listItemClasses.selected}:hover`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity)
      }
    }
  }, ownerState.hasSecondaryAction && {
    // Add some space to avoid collision as `ListItemSecondaryAction`
    // is absolutely positioned.
    paddingRight: 48
  }));
  const ListItemContainer = styled("li", {
    name: "MuiListItem",
    slot: "Container",
    overridesResolver: (props, styles2) => styles2.container
  })({
    position: "relative"
  });
  const ListItem = /* @__PURE__ */ reactExports.forwardRef(function ListItem2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiListItem"
    });
    const {
      alignItems = "center",
      autoFocus = false,
      button = false,
      children: childrenProp,
      className,
      component: componentProp,
      components = {},
      componentsProps = {},
      ContainerComponent = "li",
      ContainerProps: {
        className: ContainerClassName
      } = {},
      dense = false,
      disabled = false,
      disableGutters = false,
      disablePadding = false,
      divider = false,
      focusVisibleClassName,
      secondaryAction,
      selected = false,
      slotProps = {},
      slots = {}
    } = props, ContainerProps = _objectWithoutPropertiesLoose(props.ContainerProps, _excluded$j), other = _objectWithoutPropertiesLoose(props, _excluded2$2);
    const context = reactExports.useContext(ListContext);
    const childContext = reactExports.useMemo(() => ({
      dense: dense || context.dense || false,
      alignItems,
      disableGutters
    }), [alignItems, context.dense, dense, disableGutters]);
    const listItemRef = reactExports.useRef(null);
    useEnhancedEffect(() => {
      if (autoFocus) {
        if (listItemRef.current) {
          listItemRef.current.focus();
        }
      }
    }, [autoFocus]);
    const children = reactExports.Children.toArray(childrenProp);
    const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
    const ownerState = _extends$1({}, props, {
      alignItems,
      autoFocus,
      button,
      dense: childContext.dense,
      disabled,
      disableGutters,
      disablePadding,
      divider,
      hasSecondaryAction,
      selected
    });
    const classes = useUtilityClasses$e(ownerState);
    const handleRef = useForkRef(listItemRef, ref);
    const Root2 = slots.root || components.Root || ListItemRoot;
    const rootProps = slotProps.root || componentsProps.root || {};
    const componentProps = _extends$1({
      className: clsx(classes.root, rootProps.className, className),
      disabled
    }, other);
    let Component = componentProp || "li";
    if (button) {
      componentProps.component = componentProp || "div";
      componentProps.focusVisibleClassName = clsx(listItemClasses.focusVisible, focusVisibleClassName);
      Component = ButtonBase;
    }
    if (hasSecondaryAction) {
      Component = !componentProps.component && !componentProp ? "div" : Component;
      if (ContainerComponent === "li") {
        if (Component === "li") {
          Component = "div";
        } else if (componentProps.component === "li") {
          componentProps.component = "div";
        }
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemContainer, _extends$1({
          as: ContainerComponent,
          className: clsx(classes.container, ContainerClassName),
          ref: handleRef,
          ownerState
        }, ContainerProps, {
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Root2, _extends$1({}, rootProps, !isHostComponent(Root2) && {
            as: Component,
            ownerState: _extends$1({}, ownerState, rootProps.ownerState)
          }, componentProps, {
            children
          })), children.pop()]
        }))
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
      value: childContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2, _extends$1({}, rootProps, {
        as: Component,
        ref: handleRef
      }, !isHostComponent(Root2) && {
        ownerState: _extends$1({}, ownerState, rootProps.ownerState)
      }, componentProps, {
        children: [children, secondaryAction && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryAction, {
          children: secondaryAction
        })]
      }))
    });
  });
  const CancelIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
  }), "Cancel");
  function getChipUtilityClass(slot) {
    return generateUtilityClass("MuiChip", slot);
  }
  const chipClasses = generateUtilityClasses("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
  const _excluded$i = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"];
  const useUtilityClasses$d = (ownerState) => {
    const {
      classes,
      disabled,
      size,
      color: color2,
      iconColor,
      onDelete,
      clickable,
      variant
    } = ownerState;
    const slots = {
      root: ["root", variant, disabled && "disabled", `size${capitalize$1(size)}`, `color${capitalize$1(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize$1(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize$1(color2)}`, `${variant}${capitalize$1(color2)}`],
      label: ["label", `label${capitalize$1(size)}`],
      avatar: ["avatar", `avatar${capitalize$1(size)}`, `avatarColor${capitalize$1(color2)}`],
      icon: ["icon", `icon${capitalize$1(size)}`, `iconColor${capitalize$1(iconColor)}`],
      deleteIcon: ["deleteIcon", `deleteIcon${capitalize$1(size)}`, `deleteIconColor${capitalize$1(color2)}`, `deleteIcon${capitalize$1(variant)}Color${capitalize$1(color2)}`]
    };
    return composeClasses(slots, getChipUtilityClass, classes);
  };
  const ChipRoot = styled("div", {
    name: "MuiChip",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      const {
        color: color2,
        iconColor,
        clickable,
        onDelete,
        size,
        variant
      } = ownerState;
      return [{
        [`& .${chipClasses.avatar}`]: styles2.avatar
      }, {
        [`& .${chipClasses.avatar}`]: styles2[`avatar${capitalize$1(size)}`]
      }, {
        [`& .${chipClasses.avatar}`]: styles2[`avatarColor${capitalize$1(color2)}`]
      }, {
        [`& .${chipClasses.icon}`]: styles2.icon
      }, {
        [`& .${chipClasses.icon}`]: styles2[`icon${capitalize$1(size)}`]
      }, {
        [`& .${chipClasses.icon}`]: styles2[`iconColor${capitalize$1(iconColor)}`]
      }, {
        [`& .${chipClasses.deleteIcon}`]: styles2.deleteIcon
      }, {
        [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize$1(size)}`]
      }, {
        [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIconColor${capitalize$1(color2)}`]
      }, {
        [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize$1(variant)}Color${capitalize$1(color2)}`]
      }, styles2.root, styles2[`size${capitalize$1(size)}`], styles2[`color${capitalize$1(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize$1(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize$1(color2)}`], styles2[variant], styles2[`${variant}${capitalize$1(color2)}`]];
    }
  })(({
    theme,
    ownerState
  }) => {
    const textColor = theme.palette.mode === "light" ? theme.palette.grey[700] : theme.palette.grey[300];
    return _extends$1({
      maxWidth: "100%",
      fontFamily: theme.typography.fontFamily,
      fontSize: theme.typography.pxToRem(13),
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      height: 32,
      color: (theme.vars || theme).palette.text.primary,
      backgroundColor: (theme.vars || theme).palette.action.selected,
      borderRadius: 32 / 2,
      whiteSpace: "nowrap",
      transition: theme.transitions.create(["background-color", "box-shadow"]),
      // reset cursor explicitly in case ButtonBase is used
      cursor: "unset",
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0,
      textDecoration: "none",
      border: 0,
      // Remove `button` border
      padding: 0,
      // Remove `button` padding
      verticalAlign: "middle",
      boxSizing: "border-box",
      [`&.${chipClasses.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity,
        pointerEvents: "none"
      },
      [`& .${chipClasses.avatar}`]: {
        marginLeft: 5,
        marginRight: -6,
        width: 24,
        height: 24,
        color: theme.vars ? theme.vars.palette.Chip.defaultAvatarColor : textColor,
        fontSize: theme.typography.pxToRem(12)
      },
      [`& .${chipClasses.avatarColorPrimary}`]: {
        color: (theme.vars || theme).palette.primary.contrastText,
        backgroundColor: (theme.vars || theme).palette.primary.dark
      },
      [`& .${chipClasses.avatarColorSecondary}`]: {
        color: (theme.vars || theme).palette.secondary.contrastText,
        backgroundColor: (theme.vars || theme).palette.secondary.dark
      },
      [`& .${chipClasses.avatarSmall}`]: {
        marginLeft: 4,
        marginRight: -4,
        width: 18,
        height: 18,
        fontSize: theme.typography.pxToRem(10)
      },
      [`& .${chipClasses.icon}`]: _extends$1({
        marginLeft: 5,
        marginRight: -6
      }, ownerState.size === "small" && {
        fontSize: 18,
        marginLeft: 4,
        marginRight: -4
      }, ownerState.iconColor === ownerState.color && _extends$1({
        color: theme.vars ? theme.vars.palette.Chip.defaultIconColor : textColor
      }, ownerState.color !== "default" && {
        color: "inherit"
      })),
      [`& .${chipClasses.deleteIcon}`]: _extends$1({
        WebkitTapHighlightColor: "transparent",
        color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.26)` : alpha_1(theme.palette.text.primary, 0.26),
        fontSize: 22,
        cursor: "pointer",
        margin: "0 5px 0 -6px",
        "&:hover": {
          color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.4)` : alpha_1(theme.palette.text.primary, 0.4)
        }
      }, ownerState.size === "small" && {
        fontSize: 16,
        marginRight: 4,
        marginLeft: -4
      }, ownerState.color !== "default" && {
        color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha_1(theme.palette[ownerState.color].contrastText, 0.7),
        "&:hover, &:active": {
          color: (theme.vars || theme).palette[ownerState.color].contrastText
        }
      })
    }, ownerState.size === "small" && {
      height: 24
    }, ownerState.color !== "default" && {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
      color: (theme.vars || theme).palette[ownerState.color].contrastText
    }, ownerState.onDelete && {
      [`&.${chipClasses.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      }
    }, ownerState.onDelete && ownerState.color !== "default" && {
      [`&.${chipClasses.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
      }
    });
  }, ({
    theme,
    ownerState
  }) => _extends$1({}, ownerState.clickable && {
    userSelect: "none",
    WebkitTapHighlightColor: "transparent",
    cursor: "pointer",
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha_1(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
    },
    [`&.${chipClasses.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    },
    "&:active": {
      boxShadow: (theme.vars || theme).shadows[1]
    }
  }, ownerState.clickable && ownerState.color !== "default" && {
    [`&:hover, &.${chipClasses.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
    }
  }), ({
    theme,
    ownerState
  }) => _extends$1({}, ownerState.variant === "outlined" && {
    backgroundColor: "transparent",
    border: theme.vars ? `1px solid ${theme.vars.palette.Chip.defaultBorder}` : `1px solid ${theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[700]}`,
    [`&.${chipClasses.clickable}:hover`]: {
      backgroundColor: (theme.vars || theme).palette.action.hover
    },
    [`&.${chipClasses.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette.action.focus
    },
    [`& .${chipClasses.avatar}`]: {
      marginLeft: 4
    },
    [`& .${chipClasses.avatarSmall}`]: {
      marginLeft: 2
    },
    [`& .${chipClasses.icon}`]: {
      marginLeft: 4
    },
    [`& .${chipClasses.iconSmall}`]: {
      marginLeft: 2
    },
    [`& .${chipClasses.deleteIcon}`]: {
      marginRight: 5
    },
    [`& .${chipClasses.deleteIconSmall}`]: {
      marginRight: 3
    }
  }, ownerState.variant === "outlined" && ownerState.color !== "default" && {
    color: (theme.vars || theme).palette[ownerState.color].main,
    border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha_1(theme.palette[ownerState.color].main, 0.7)}`,
    [`&.${chipClasses.clickable}:hover`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha_1(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity)
    },
    [`&.${chipClasses.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha_1(theme.palette[ownerState.color].main, theme.palette.action.focusOpacity)
    },
    [`& .${chipClasses.deleteIcon}`]: {
      color: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha_1(theme.palette[ownerState.color].main, 0.7),
      "&:hover, &:active": {
        color: (theme.vars || theme).palette[ownerState.color].main
      }
    }
  }));
  const ChipLabel = styled("span", {
    name: "MuiChip",
    slot: "Label",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      const {
        size
      } = ownerState;
      return [styles2.label, styles2[`label${capitalize$1(size)}`]];
    }
  })(({
    ownerState
  }) => _extends$1({
    overflow: "hidden",
    textOverflow: "ellipsis",
    paddingLeft: 12,
    paddingRight: 12,
    whiteSpace: "nowrap"
  }, ownerState.variant === "outlined" && {
    paddingLeft: 11,
    paddingRight: 11
  }, ownerState.size === "small" && {
    paddingLeft: 8,
    paddingRight: 8
  }, ownerState.size === "small" && ownerState.variant === "outlined" && {
    paddingLeft: 7,
    paddingRight: 7
  }));
  function isDeleteKeyboardEvent(keyboardEvent) {
    return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
  }
  const Chip = /* @__PURE__ */ reactExports.forwardRef(function Chip2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiChip"
    });
    const {
      avatar: avatarProp,
      className,
      clickable: clickableProp,
      color: color2 = "default",
      component: ComponentProp,
      deleteIcon: deleteIconProp,
      disabled = false,
      icon: iconProp,
      label,
      onClick,
      onDelete,
      onKeyDown,
      onKeyUp,
      size = "medium",
      variant = "filled",
      tabIndex,
      skipFocusWhenDisabled = false
      // TODO v6: Rename to `focusableWhenDisabled`.
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$i);
    const chipRef = reactExports.useRef(null);
    const handleRef = useForkRef(chipRef, ref);
    const handleDeleteIconClick = (event) => {
      event.stopPropagation();
      if (onDelete) {
        onDelete(event);
      }
    };
    const handleKeyDown2 = (event) => {
      if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
        event.preventDefault();
      }
      if (onKeyDown) {
        onKeyDown(event);
      }
    };
    const handleKeyUp = (event) => {
      if (event.currentTarget === event.target) {
        if (onDelete && isDeleteKeyboardEvent(event)) {
          onDelete(event);
        } else if (event.key === "Escape" && chipRef.current) {
          chipRef.current.blur();
        }
      }
      if (onKeyUp) {
        onKeyUp(event);
      }
    };
    const clickable = clickableProp !== false && onClick ? true : clickableProp;
    const component = clickable || onDelete ? ButtonBase : ComponentProp || "div";
    const ownerState = _extends$1({}, props, {
      component,
      disabled,
      size,
      color: color2,
      iconColor: /* @__PURE__ */ reactExports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
      onDelete: !!onDelete,
      clickable,
      variant
    });
    const classes = useUtilityClasses$d(ownerState);
    const moreProps = component === ButtonBase ? _extends$1({
      component: ComponentProp || "div",
      focusVisibleClassName: classes.focusVisible
    }, onDelete && {
      disableRipple: true
    }) : {};
    let deleteIcon = null;
    if (onDelete) {
      deleteIcon = deleteIconProp && /* @__PURE__ */ reactExports.isValidElement(deleteIconProp) ? /* @__PURE__ */ reactExports.cloneElement(deleteIconProp, {
        className: clsx(deleteIconProp.props.className, classes.deleteIcon),
        onClick: handleDeleteIconClick
      }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
        className: clsx(classes.deleteIcon),
        onClick: handleDeleteIconClick
      });
    }
    let avatar = null;
    if (avatarProp && /* @__PURE__ */ reactExports.isValidElement(avatarProp)) {
      avatar = /* @__PURE__ */ reactExports.cloneElement(avatarProp, {
        className: clsx(classes.avatar, avatarProp.props.className)
      });
    }
    let icon = null;
    if (iconProp && /* @__PURE__ */ reactExports.isValidElement(iconProp)) {
      icon = /* @__PURE__ */ reactExports.cloneElement(iconProp, {
        className: clsx(classes.icon, iconProp.props.className)
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChipRoot, _extends$1({
      as: component,
      className: clsx(classes.root, className),
      disabled: clickable && disabled ? true : void 0,
      onClick,
      onKeyDown: handleKeyDown2,
      onKeyUp: handleKeyUp,
      ref: handleRef,
      tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
      ownerState
    }, moreProps, other, {
      children: [avatar || icon, /* @__PURE__ */ jsxRuntimeExports.jsx(ChipLabel, {
        className: clsx(classes.label),
        ownerState,
        children: label
      }), deleteIcon]
    }));
  });
  const _excluded$h = ["items", "changeImportance", "isLandscape", "onChange", "isValid"], _excluded2$1 = ["getValue"];
  function PickersShortcuts(props) {
    const {
      items,
      changeImportance = "accept",
      onChange,
      isValid
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$h);
    if (items == null || items.length === 0) {
      return null;
    }
    const resolvedItems = items.map((_ref) => {
      let {
        getValue: getValue2
      } = _ref, item = _objectWithoutPropertiesLoose(_ref, _excluded2$1);
      const newValue = getValue2({
        isValid
      });
      return _extends$1({}, item, {
        label: item.label,
        onClick: () => {
          onChange(newValue, changeImportance, item);
        },
        disabled: !isValid(newValue)
      });
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(List, _extends$1({
      dense: true,
      sx: [{
        maxHeight: VIEW_HEIGHT,
        maxWidth: 200,
        overflow: "auto"
      }, ...Array.isArray(other.sx) ? other.sx : [other.sx]]
    }, other, {
      children: resolvedItems.map((item) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, _extends$1({}, item))
        }, item.id ?? item.label);
      })
    }));
  }
  function toolbarHasView(toolbarProps) {
    return toolbarProps.view !== null;
  }
  const useUtilityClasses$c = (ownerState) => {
    const {
      classes,
      isLandscape
    } = ownerState;
    const slots = {
      root: ["root", isLandscape && "landscape"],
      contentWrapper: ["contentWrapper"],
      toolbar: ["toolbar"],
      actionBar: ["actionBar"],
      tabs: ["tabs"],
      landscape: ["landscape"],
      shortcuts: ["shortcuts"]
    };
    return composeClasses(slots, getPickersLayoutUtilityClass, classes);
  };
  const usePickerLayout = (props) => {
    const {
      wrapperVariant,
      onAccept,
      onClear,
      onCancel,
      onSetToday,
      view,
      views,
      onViewChange,
      value,
      onChange,
      onSelectShortcut,
      isValid,
      isLandscape,
      disabled,
      readOnly,
      children,
      slots,
      slotProps
      // TODO: Remove this "as" hack. It get introduced to mark `value` prop in PickersLayoutProps as not required.
      // The true type should be
      // - For pickers value: TDate | null
      // - For range pickers value: [TDate | null, TDate | null]
    } = props;
    const classes = useUtilityClasses$c(props);
    const ActionBar = (slots == null ? void 0 : slots.actionBar) ?? PickersActionBar;
    const actionBarProps = useSlotProps({
      elementType: ActionBar,
      externalSlotProps: slotProps == null ? void 0 : slotProps.actionBar,
      additionalProps: {
        onAccept,
        onClear,
        onCancel,
        onSetToday,
        actions: wrapperVariant === "desktop" ? [] : ["cancel", "accept"]
      },
      className: classes.actionBar,
      ownerState: _extends$1({}, props, {
        wrapperVariant
      })
    });
    const actionBar = /* @__PURE__ */ jsxRuntimeExports.jsx(ActionBar, _extends$1({}, actionBarProps));
    const Toolbar = slots == null ? void 0 : slots.toolbar;
    const toolbarProps = useSlotProps({
      elementType: Toolbar,
      externalSlotProps: slotProps == null ? void 0 : slotProps.toolbar,
      additionalProps: {
        isLandscape,
        onChange,
        value,
        view,
        onViewChange,
        views,
        disabled,
        readOnly
      },
      className: classes.toolbar,
      ownerState: _extends$1({}, props, {
        wrapperVariant
      })
    });
    const toolbar = toolbarHasView(toolbarProps) && !!Toolbar ? /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar, _extends$1({}, toolbarProps)) : null;
    const content = children;
    const Tabs2 = slots == null ? void 0 : slots.tabs;
    const tabs = view && Tabs2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs2, _extends$1({
      view,
      onViewChange,
      className: classes.tabs
    }, slotProps == null ? void 0 : slotProps.tabs)) : null;
    const Shortcuts = (slots == null ? void 0 : slots.shortcuts) ?? PickersShortcuts;
    const shortcutsProps = useSlotProps({
      elementType: Shortcuts,
      externalSlotProps: slotProps == null ? void 0 : slotProps.shortcuts,
      additionalProps: {
        isValid,
        isLandscape,
        onChange: onSelectShortcut
      },
      className: classes.shortcuts,
      ownerState: {
        isValid,
        isLandscape,
        onChange: onSelectShortcut,
        wrapperVariant
      }
    });
    const shortcuts = view && !!Shortcuts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Shortcuts, _extends$1({}, shortcutsProps)) : null;
    return {
      toolbar,
      content,
      tabs,
      actionBar,
      shortcuts
    };
  };
  const useUtilityClasses$b = (ownerState) => {
    const {
      isLandscape,
      classes
    } = ownerState;
    const slots = {
      root: ["root", isLandscape && "landscape"],
      contentWrapper: ["contentWrapper"]
    };
    return composeClasses(slots, getPickersLayoutUtilityClass, classes);
  };
  const PickersLayoutRoot = styled("div", {
    name: "MuiPickersLayout",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "grid",
    gridAutoColumns: "max-content auto max-content",
    gridAutoRows: "max-content auto max-content",
    [`& .${pickersLayoutClasses.actionBar}`]: {
      gridColumn: "1 / 4",
      gridRow: 3
    },
    variants: [{
      props: {
        isLandscape: true
      },
      style: {
        [`& .${pickersLayoutClasses.toolbar}`]: {
          gridColumn: 1,
          gridRow: "2 / 3"
        },
        [`.${pickersLayoutClasses.shortcuts}`]: {
          gridColumn: "2 / 4",
          gridRow: 1
        }
      }
    }, {
      props: {
        isLandscape: true,
        isRtl: true
      },
      style: {
        [`& .${pickersLayoutClasses.toolbar}`]: {
          gridColumn: 3
        }
      }
    }, {
      props: {
        isLandscape: false
      },
      style: {
        [`& .${pickersLayoutClasses.toolbar}`]: {
          gridColumn: "2 / 4",
          gridRow: 1
        },
        [`& .${pickersLayoutClasses.shortcuts}`]: {
          gridColumn: 1,
          gridRow: "2 / 3"
        }
      }
    }, {
      props: {
        isLandscape: false,
        isRtl: true
      },
      style: {
        [`& .${pickersLayoutClasses.shortcuts}`]: {
          gridColumn: 3
        }
      }
    }]
  });
  const PickersLayoutContentWrapper = styled("div", {
    name: "MuiPickersLayout",
    slot: "ContentWrapper",
    overridesResolver: (props, styles2) => styles2.contentWrapper
  })({
    gridColumn: 2,
    gridRow: 2,
    display: "flex",
    flexDirection: "column"
  });
  const PickersLayout = /* @__PURE__ */ reactExports.forwardRef(function PickersLayout2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPickersLayout"
    });
    const {
      toolbar,
      content,
      tabs,
      actionBar,
      shortcuts
    } = usePickerLayout(props);
    const {
      sx,
      className,
      isLandscape,
      wrapperVariant
    } = props;
    const classes = useUtilityClasses$b(props);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersLayoutRoot, {
      ref,
      sx,
      className: clsx(className, classes.root),
      ownerState: props,
      children: [isLandscape ? shortcuts : toolbar, isLandscape ? toolbar : shortcuts, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersLayoutContentWrapper, {
        className: classes.contentWrapper,
        children: wrapperVariant === "desktop" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [content, tabs]
        }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [tabs, content]
        })
      }), actionBar]
    });
  });
  const _excluded$g = ["props", "getOpenDialogAriaText"], _excluded2 = ["ownerState"], _excluded3 = ["ownerState"];
  const useDesktopPicker = (_ref) => {
    var _a;
    let {
      props,
      getOpenDialogAriaText
    } = _ref, pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded$g);
    const {
      slots,
      slotProps: innerSlotProps,
      className,
      sx,
      format,
      formatDensity,
      enableAccessibleFieldDOMStructure,
      selectedSections,
      onSelectedSectionsChange,
      timezone,
      name,
      label,
      inputRef,
      readOnly,
      disabled,
      autoFocus,
      localeText,
      reduceAnimations
    } = props;
    const utils2 = useUtils();
    const containerRef = reactExports.useRef(null);
    const fieldRef = reactExports.useRef(null);
    const labelId = useId();
    const isToolbarHidden = ((_a = innerSlotProps == null ? void 0 : innerSlotProps.toolbar) == null ? void 0 : _a.hidden) ?? false;
    const {
      open,
      actions,
      hasUIView,
      layoutProps,
      renderCurrentView,
      shouldRestoreFocus,
      fieldProps: pickerFieldProps
    } = usePicker(_extends$1({}, pickerParams, {
      props,
      fieldRef,
      autoFocusView: true,
      additionalViewProps: {},
      wrapperVariant: "desktop"
    }));
    const InputAdornment$1 = slots.inputAdornment ?? InputAdornment;
    const _useSlotProps = useSlotProps({
      elementType: InputAdornment$1,
      externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.inputAdornment,
      additionalProps: {
        position: "end"
      },
      ownerState: props
    }), inputAdornmentProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2);
    const OpenPickerButton = slots.openPickerButton ?? IconButton;
    const _useSlotProps2 = useSlotProps({
      elementType: OpenPickerButton,
      externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.openPickerButton,
      additionalProps: {
        disabled: disabled || readOnly,
        onClick: open ? actions.onClose : actions.onOpen,
        "aria-label": getOpenDialogAriaText(pickerFieldProps.value, utils2),
        edge: inputAdornmentProps.position
      },
      ownerState: props
    }), openPickerButtonProps = _objectWithoutPropertiesLoose(_useSlotProps2, _excluded3);
    const OpenPickerIcon = slots.openPickerIcon;
    const Field = slots.field;
    const fieldProps = useSlotProps({
      elementType: Field,
      externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.field,
      additionalProps: _extends$1({}, pickerFieldProps, isToolbarHidden && {
        id: labelId
      }, {
        readOnly,
        disabled,
        className,
        sx,
        format,
        formatDensity,
        enableAccessibleFieldDOMStructure,
        selectedSections,
        onSelectedSectionsChange,
        timezone,
        label,
        name,
        autoFocus: autoFocus && !props.open,
        focused: open ? true : void 0
      }, inputRef ? {
        inputRef
      } : {}),
      ownerState: props
    });
    if (hasUIView) {
      fieldProps.InputProps = _extends$1({}, fieldProps.InputProps, {
        ref: containerRef
      }, !props.disableOpenPicker && {
        [`${inputAdornmentProps.position}Adornment`]: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment$1, _extends$1({}, inputAdornmentProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenPickerButton, _extends$1({}, openPickerButtonProps, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenPickerIcon, _extends$1({}, innerSlotProps == null ? void 0 : innerSlotProps.openPickerIcon))
          }))
        }))
      });
    }
    const slotsForField = _extends$1({
      textField: slots.textField,
      clearIcon: slots.clearIcon,
      clearButton: slots.clearButton
    }, fieldProps.slots);
    const Layout = slots.layout ?? PickersLayout;
    let labelledById = labelId;
    if (isToolbarHidden) {
      if (label) {
        labelledById = `${labelId}-label`;
      } else {
        labelledById = void 0;
      }
    }
    const slotProps = _extends$1({}, innerSlotProps, {
      toolbar: _extends$1({}, innerSlotProps == null ? void 0 : innerSlotProps.toolbar, {
        titleId: labelId
      }),
      popper: _extends$1({
        "aria-labelledby": labelledById
      }, innerSlotProps == null ? void 0 : innerSlotProps.popper)
    });
    const handleFieldRef = useForkRef(fieldRef, fieldProps.unstableFieldRef);
    const renderPicker = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(LocalizationProvider, {
      localeText,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Field, _extends$1({}, fieldProps, {
        slots: slotsForField,
        slotProps,
        unstableFieldRef: handleFieldRef
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersPopper, _extends$1({
        role: "dialog",
        placement: "bottom-start",
        anchorEl: containerRef.current
      }, actions, {
        open,
        slots,
        slotProps,
        shouldRestoreFocus,
        reduceAnimations,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, _extends$1({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
          slots,
          slotProps,
          children: renderCurrentView()
        }))
      }))]
    });
    return {
      renderPicker
    };
  };
  const _excluded$f = ["views", "format"];
  const resolveDateTimeFormat = (utils2, _ref, ignoreDateResolving) => {
    let {
      views,
      format
    } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$f);
    if (format) {
      return format;
    }
    const dateViews2 = [];
    const timeViews2 = [];
    views.forEach((view) => {
      if (isTimeView(view)) {
        timeViews2.push(view);
      } else if (isDatePickerView(view)) {
        dateViews2.push(view);
      }
    });
    if (timeViews2.length === 0) {
      return resolveDateFormat(utils2, _extends$1({
        views: dateViews2
      }, other));
    }
    if (dateViews2.length === 0) {
      return resolveTimeFormat(utils2, _extends$1({
        views: timeViews2
      }, other));
    }
    const timeFormat = resolveTimeFormat(utils2, _extends$1({
      views: timeViews2
    }, other));
    const dateFormat = resolveDateFormat(utils2, _extends$1({
      views: dateViews2
    }, other));
    return `${dateFormat} ${timeFormat}`;
  };
  const resolveViews = (ampm, views, shouldUseSingleColumn) => {
    if (shouldUseSingleColumn) {
      return views.filter((view) => !isInternalTimeView(view) || view === "hours");
    }
    return ampm ? [...views, "meridiem"] : views;
  };
  const resolveShouldRenderTimeInASingleColumn = (timeSteps, threshold) => 24 * 60 / ((timeSteps.hours ?? 1) * (timeSteps.minutes ?? 5)) <= threshold;
  function resolveTimeViewsResponse({
    thresholdToRenderTimeInASingleColumn: inThreshold,
    ampm,
    timeSteps: inTimeSteps,
    views
  }) {
    const thresholdToRenderTimeInASingleColumn = inThreshold ?? 24;
    const timeSteps = _extends$1({
      hours: 1,
      minutes: 5,
      seconds: 5
    }, inTimeSteps);
    const shouldRenderTimeInASingleColumn = resolveShouldRenderTimeInASingleColumn(timeSteps, thresholdToRenderTimeInASingleColumn);
    return {
      thresholdToRenderTimeInASingleColumn,
      timeSteps,
      shouldRenderTimeInASingleColumn,
      views: resolveViews(ampm, views, shouldRenderTimeInASingleColumn)
    };
  }
  function getTimeClockUtilityClass(slot) {
    return generateUtilityClass("MuiTimeClock", slot);
  }
  generateUtilityClasses("MuiTimeClock", ["root", "arrowSwitcher"]);
  const CLOCK_WIDTH = 220;
  const CLOCK_HOUR_WIDTH = 36;
  const clockCenter = {
    x: CLOCK_WIDTH / 2,
    y: CLOCK_WIDTH / 2
  };
  const baseClockPoint = {
    x: clockCenter.x,
    y: 0
  };
  const cx = baseClockPoint.x - clockCenter.x;
  const cy = baseClockPoint.y - clockCenter.y;
  const rad2deg = (rad) => rad * (180 / Math.PI);
  const getAngleValue = (step, offsetX, offsetY) => {
    const x2 = offsetX - clockCenter.x;
    const y2 = offsetY - clockCenter.y;
    const atan = Math.atan2(cx, cy) - Math.atan2(x2, y2);
    let deg = rad2deg(atan);
    deg = Math.round(deg / step) * step;
    deg %= 360;
    const value = Math.floor(deg / step) || 0;
    const delta = x2 ** 2 + y2 ** 2;
    const distance = Math.sqrt(delta);
    return {
      value,
      distance
    };
  };
  const getMinutes = (offsetX, offsetY, step = 1) => {
    const angleStep = step * 6;
    let {
      value
    } = getAngleValue(angleStep, offsetX, offsetY);
    value = value * step % 60;
    return value;
  };
  const getHours = (offsetX, offsetY, ampm) => {
    const {
      value,
      distance
    } = getAngleValue(30, offsetX, offsetY);
    let hour = value || 12;
    if (!ampm) {
      if (distance < CLOCK_WIDTH / 2 - CLOCK_HOUR_WIDTH) {
        hour += 12;
        hour %= 24;
      }
    } else {
      hour %= 12;
    }
    return hour;
  };
  function getClockPointerUtilityClass(slot) {
    return generateUtilityClass("MuiClockPointer", slot);
  }
  generateUtilityClasses("MuiClockPointer", ["root", "thumb"]);
  const _excluded$e = ["className", "hasSelected", "isInner", "type", "viewValue"];
  const useUtilityClasses$a = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      thumb: ["thumb"]
    };
    return composeClasses(slots, getClockPointerUtilityClass, classes);
  };
  const ClockPointerRoot = styled("div", {
    name: "MuiClockPointer",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })(({
    theme
  }) => ({
    width: 2,
    backgroundColor: (theme.vars || theme).palette.primary.main,
    position: "absolute",
    left: "calc(50% - 1px)",
    bottom: "50%",
    transformOrigin: "center bottom 0px",
    variants: [{
      props: {
        shouldAnimate: true
      },
      style: {
        transition: theme.transitions.create(["transform", "height"])
      }
    }]
  }));
  const ClockPointerThumb = styled("div", {
    name: "MuiClockPointer",
    slot: "Thumb",
    overridesResolver: (_2, styles2) => styles2.thumb
  })(({
    theme
  }) => ({
    width: 4,
    height: 4,
    backgroundColor: (theme.vars || theme).palette.primary.contrastText,
    borderRadius: "50%",
    position: "absolute",
    top: -21,
    left: `calc(50% - ${CLOCK_HOUR_WIDTH / 2}px)`,
    border: `${(CLOCK_HOUR_WIDTH - 4) / 2}px solid ${(theme.vars || theme).palette.primary.main}`,
    boxSizing: "content-box",
    variants: [{
      props: {
        hasSelected: true
      },
      style: {
        backgroundColor: (theme.vars || theme).palette.primary.main
      }
    }]
  }));
  function ClockPointer(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiClockPointer"
    });
    const {
      className,
      isInner,
      type,
      viewValue
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$e);
    const previousType = reactExports.useRef(type);
    reactExports.useEffect(() => {
      previousType.current = type;
    }, [type]);
    const ownerState = _extends$1({}, props, {
      shouldAnimate: previousType.current !== type
    });
    const classes = useUtilityClasses$a(ownerState);
    const getAngleStyle = () => {
      const max2 = type === "hours" ? 12 : 60;
      let angle = 360 / max2 * viewValue;
      if (type === "hours" && viewValue > 12) {
        angle -= 360;
      }
      return {
        height: Math.round((isInner ? 0.26 : 0.4) * CLOCK_WIDTH),
        transform: `rotateZ(${angle}deg)`
      };
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPointerRoot, _extends$1({
      style: getAngleStyle(),
      className: clsx(className, classes.root),
      ownerState
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPointerThumb, {
        ownerState,
        className: classes.thumb
      })
    }));
  }
  function getClockUtilityClass(slot) {
    return generateUtilityClass("MuiClock", slot);
  }
  generateUtilityClasses("MuiClock", ["root", "clock", "wrapper", "squareMask", "pin", "amButton", "pmButton", "meridiemText", "selected"]);
  const useUtilityClasses$9 = (ownerState) => {
    const {
      classes,
      meridiemMode
    } = ownerState;
    const slots = {
      root: ["root"],
      clock: ["clock"],
      wrapper: ["wrapper"],
      squareMask: ["squareMask"],
      pin: ["pin"],
      amButton: ["amButton", meridiemMode === "am" && "selected"],
      pmButton: ["pmButton", meridiemMode === "pm" && "selected"],
      meridiemText: ["meridiemText"]
    };
    return composeClasses(slots, getClockUtilityClass, classes);
  };
  const ClockRoot = styled("div", {
    name: "MuiClock",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })(({
    theme
  }) => ({
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    margin: theme.spacing(2)
  }));
  const ClockClock = styled("div", {
    name: "MuiClock",
    slot: "Clock",
    overridesResolver: (_2, styles2) => styles2.clock
  })({
    backgroundColor: "rgba(0,0,0,.07)",
    borderRadius: "50%",
    height: 220,
    width: 220,
    flexShrink: 0,
    position: "relative",
    pointerEvents: "none"
  });
  const ClockWrapper = styled("div", {
    name: "MuiClock",
    slot: "Wrapper",
    overridesResolver: (_2, styles2) => styles2.wrapper
  })({
    "&:focus": {
      outline: "none"
    }
  });
  const ClockSquareMask = styled("div", {
    name: "MuiClock",
    slot: "SquareMask",
    overridesResolver: (_2, styles2) => styles2.squareMask
  })({
    width: "100%",
    height: "100%",
    position: "absolute",
    pointerEvents: "auto",
    outline: 0,
    // Disable scroll capabilities.
    touchAction: "none",
    userSelect: "none",
    variants: [{
      props: {
        disabled: false
      },
      style: {
        "@media (pointer: fine)": {
          cursor: "pointer",
          borderRadius: "50%"
        },
        "&:active": {
          cursor: "move"
        }
      }
    }]
  });
  const ClockPin = styled("div", {
    name: "MuiClock",
    slot: "Pin",
    overridesResolver: (_2, styles2) => styles2.pin
  })(({
    theme
  }) => ({
    width: 6,
    height: 6,
    borderRadius: "50%",
    backgroundColor: (theme.vars || theme).palette.primary.main,
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  }));
  const meridiemButtonCommonStyles = (theme, meridiemMode) => ({
    zIndex: 1,
    bottom: 8,
    paddingLeft: 4,
    paddingRight: 4,
    width: CLOCK_HOUR_WIDTH,
    variants: [{
      props: {
        meridiemMode
      },
      style: {
        backgroundColor: (theme.vars || theme).palette.primary.main,
        color: (theme.vars || theme).palette.primary.contrastText,
        "&:hover": {
          backgroundColor: (theme.vars || theme).palette.primary.light
        }
      }
    }]
  });
  const ClockAmButton = styled(IconButton, {
    name: "MuiClock",
    slot: "AmButton",
    overridesResolver: (_2, styles2) => styles2.amButton
  })(({
    theme
  }) => _extends$1({}, meridiemButtonCommonStyles(theme, "am"), {
    // keeping it here to make TS happy
    position: "absolute",
    left: 8
  }));
  const ClockPmButton = styled(IconButton, {
    name: "MuiClock",
    slot: "PmButton",
    overridesResolver: (_2, styles2) => styles2.pmButton
  })(({
    theme
  }) => _extends$1({}, meridiemButtonCommonStyles(theme, "pm"), {
    // keeping it here to make TS happy
    position: "absolute",
    right: 8
  }));
  const ClockMeridiemText = styled(Typography, {
    name: "MuiClock",
    slot: "meridiemText",
    overridesResolver: (_2, styles2) => styles2.meridiemText
  })({
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis"
  });
  function Clock(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiClock"
    });
    const {
      ampm,
      ampmInClock,
      autoFocus,
      children,
      value,
      handleMeridiemChange,
      isTimeDisabled,
      meridiemMode,
      minutesStep = 1,
      onChange,
      selectedId,
      type,
      viewValue,
      disabled = false,
      readOnly,
      className
    } = props;
    const ownerState = props;
    const utils2 = useUtils();
    const translations = usePickersTranslations();
    const isMoving = reactExports.useRef(false);
    const classes = useUtilityClasses$9(ownerState);
    const isSelectedTimeDisabled = isTimeDisabled(viewValue, type);
    const isPointerInner = !ampm && type === "hours" && (viewValue < 1 || viewValue > 12);
    const handleValueChange = (newValue, isFinish) => {
      if (disabled || readOnly) {
        return;
      }
      if (isTimeDisabled(newValue, type)) {
        return;
      }
      onChange(newValue, isFinish);
    };
    const setTime = (event, isFinish) => {
      let {
        offsetX,
        offsetY
      } = event;
      if (offsetX === void 0) {
        const rect = event.target.getBoundingClientRect();
        offsetX = event.changedTouches[0].clientX - rect.left;
        offsetY = event.changedTouches[0].clientY - rect.top;
      }
      const newSelectedValue = type === "seconds" || type === "minutes" ? getMinutes(offsetX, offsetY, minutesStep) : getHours(offsetX, offsetY, Boolean(ampm));
      handleValueChange(newSelectedValue, isFinish);
    };
    const handleTouchSelection = (event) => {
      isMoving.current = true;
      setTime(event, "shallow");
    };
    const handleTouchEnd = (event) => {
      if (isMoving.current) {
        setTime(event, "finish");
        isMoving.current = false;
      }
    };
    const handleMouseMove = (event) => {
      if (event.buttons > 0) {
        setTime(event.nativeEvent, "shallow");
      }
    };
    const handleMouseUp = (event) => {
      if (isMoving.current) {
        isMoving.current = false;
      }
      setTime(event.nativeEvent, "finish");
    };
    const hasSelected = reactExports.useMemo(() => {
      if (type === "hours") {
        return true;
      }
      return viewValue % 5 === 0;
    }, [type, viewValue]);
    const keyboardControlStep = type === "minutes" ? minutesStep : 1;
    const listboxRef = reactExports.useRef(null);
    useEnhancedEffect(() => {
      if (autoFocus) {
        listboxRef.current.focus();
      }
    }, [autoFocus]);
    const handleKeyDown2 = (event) => {
      if (isMoving.current) {
        return;
      }
      switch (event.key) {
        case "Home":
          handleValueChange(0, "partial");
          event.preventDefault();
          break;
        case "End":
          handleValueChange(type === "minutes" ? 59 : 23, "partial");
          event.preventDefault();
          break;
        case "ArrowUp":
          handleValueChange(viewValue + keyboardControlStep, "partial");
          event.preventDefault();
          break;
        case "ArrowDown":
          handleValueChange(viewValue - keyboardControlStep, "partial");
          event.preventDefault();
          break;
        case "Enter":
        case " ":
          handleValueChange(viewValue, "finish");
          event.preventDefault();
          break;
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ClockRoot, {
      className: clsx(className, classes.root),
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(ClockClock, {
        className: classes.clock,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ClockSquareMask, {
          onTouchMove: handleTouchSelection,
          onTouchStart: handleTouchSelection,
          onTouchEnd: handleTouchEnd,
          onMouseUp: handleMouseUp,
          onMouseMove: handleMouseMove,
          ownerState: {
            disabled
          },
          className: classes.squareMask
        }), !isSelectedTimeDisabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ClockPin, {
            className: classes.pin
          }), value != null && /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPointer, {
            type,
            viewValue,
            isInner: isPointerInner,
            hasSelected
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(ClockWrapper, {
          "aria-activedescendant": selectedId,
          "aria-label": translations.clockLabelText(type, value, utils2),
          ref: listboxRef,
          role: "listbox",
          onKeyDown: handleKeyDown2,
          tabIndex: 0,
          className: classes.wrapper,
          children
        })]
      }), ampm && ampmInClock && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ClockAmButton, {
          onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
          disabled: disabled || meridiemMode === null,
          ownerState,
          className: classes.amButton,
          title: formatMeridiem(utils2, "am"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClockMeridiemText, {
            variant: "caption",
            className: classes.meridiemText,
            children: formatMeridiem(utils2, "am")
          })
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPmButton, {
          disabled: disabled || meridiemMode === null,
          onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
          ownerState,
          className: classes.pmButton,
          title: formatMeridiem(utils2, "pm"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClockMeridiemText, {
            variant: "caption",
            className: classes.meridiemText,
            children: formatMeridiem(utils2, "pm")
          })
        })]
      })]
    });
  }
  function getClockNumberUtilityClass(slot) {
    return generateUtilityClass("MuiClockNumber", slot);
  }
  const clockNumberClasses = generateUtilityClasses("MuiClockNumber", ["root", "selected", "disabled"]);
  const _excluded$d = ["className", "disabled", "index", "inner", "label", "selected"];
  const useUtilityClasses$8 = (ownerState) => {
    const {
      classes,
      selected,
      disabled
    } = ownerState;
    const slots = {
      root: ["root", selected && "selected", disabled && "disabled"]
    };
    return composeClasses(slots, getClockNumberUtilityClass, classes);
  };
  const ClockNumberRoot = styled("span", {
    name: "MuiClockNumber",
    slot: "Root",
    overridesResolver: (_2, styles2) => [styles2.root, {
      [`&.${clockNumberClasses.disabled}`]: styles2.disabled
    }, {
      [`&.${clockNumberClasses.selected}`]: styles2.selected
    }]
  })(({
    theme
  }) => ({
    height: CLOCK_HOUR_WIDTH,
    width: CLOCK_HOUR_WIDTH,
    position: "absolute",
    left: `calc((100% - ${CLOCK_HOUR_WIDTH}px) / 2)`,
    display: "inline-flex",
    justifyContent: "center",
    alignItems: "center",
    borderRadius: "50%",
    color: (theme.vars || theme).palette.text.primary,
    fontFamily: theme.typography.fontFamily,
    "&:focused": {
      backgroundColor: (theme.vars || theme).palette.background.paper
    },
    [`&.${clockNumberClasses.selected}`]: {
      color: (theme.vars || theme).palette.primary.contrastText
    },
    [`&.${clockNumberClasses.disabled}`]: {
      pointerEvents: "none",
      color: (theme.vars || theme).palette.text.disabled
    },
    variants: [{
      props: {
        inner: true
      },
      style: _extends$1({}, theme.typography.body2, {
        color: (theme.vars || theme).palette.text.secondary
      })
    }]
  }));
  function ClockNumber(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiClockNumber"
    });
    const {
      className,
      disabled,
      index,
      inner,
      label,
      selected
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$d);
    const ownerState = props;
    const classes = useUtilityClasses$8(ownerState);
    const angle = index % 12 / 12 * Math.PI * 2 - Math.PI / 2;
    const length2 = (CLOCK_WIDTH - CLOCK_HOUR_WIDTH - 2) / 2 * (inner ? 0.65 : 1);
    const x2 = Math.round(Math.cos(angle) * length2);
    const y2 = Math.round(Math.sin(angle) * length2);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockNumberRoot, _extends$1({
      className: clsx(className, classes.root),
      "aria-disabled": disabled ? true : void 0,
      "aria-selected": selected ? true : void 0,
      role: "option",
      style: {
        transform: `translate(${x2}px, ${y2 + (CLOCK_WIDTH - CLOCK_HOUR_WIDTH) / 2}px`
      },
      ownerState
    }, other, {
      children: label
    }));
  }
  const getHourNumbers = ({
    ampm,
    value,
    getClockNumberText,
    isDisabled,
    selectedId,
    utils: utils2
  }) => {
    const currentHours = value ? utils2.getHours(value) : null;
    const hourNumbers = [];
    const startHour = ampm ? 1 : 0;
    const endHour = ampm ? 12 : 23;
    const isSelected = (hour) => {
      if (currentHours === null) {
        return false;
      }
      if (ampm) {
        if (hour === 12) {
          return currentHours === 12 || currentHours === 0;
        }
        return currentHours === hour || currentHours - 12 === hour;
      }
      return currentHours === hour;
    };
    for (let hour = startHour; hour <= endHour; hour += 1) {
      let label = hour.toString();
      if (hour === 0) {
        label = "00";
      }
      const inner = !ampm && (hour === 0 || hour > 12);
      label = utils2.formatNumber(label);
      const selected = isSelected(hour);
      hourNumbers.push(/* @__PURE__ */ jsxRuntimeExports.jsx(ClockNumber, {
        id: selected ? selectedId : void 0,
        index: hour,
        inner,
        selected,
        disabled: isDisabled(hour),
        label,
        "aria-label": getClockNumberText(label)
      }, hour));
    }
    return hourNumbers;
  };
  const getMinutesNumbers = ({
    utils: utils2,
    value,
    isDisabled,
    getClockNumberText,
    selectedId
  }) => {
    const f2 = utils2.formatNumber;
    return [[5, f2("05")], [10, f2("10")], [15, f2("15")], [20, f2("20")], [25, f2("25")], [30, f2("30")], [35, f2("35")], [40, f2("40")], [45, f2("45")], [50, f2("50")], [55, f2("55")], [0, f2("00")]].map(([numberValue, label], index) => {
      const selected = numberValue === value;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockNumber, {
        label,
        id: selected ? selectedId : void 0,
        index: index + 1,
        inner: false,
        disabled: isDisabled(numberValue),
        selected,
        "aria-label": getClockNumberText(label)
      }, numberValue);
    });
  };
  const useClockReferenceDate = ({
    value,
    referenceDate: referenceDateProp,
    utils: utils2,
    props,
    timezone
  }) => {
    const referenceDate = reactExports.useMemo(
      () => singleItemValueManager.getInitialReferenceValue({
        value,
        utils: utils2,
        props,
        referenceDate: referenceDateProp,
        granularity: SECTION_TYPE_GRANULARITY.day,
        timezone,
        getTodayDate: () => getTodayDate(utils2, timezone, "date")
      }),
      // We only want to compute the reference date on mount.
      []
      // eslint-disable-line react-hooks/exhaustive-deps
    );
    return value ?? referenceDate;
  };
  const _excluded$c = ["ampm", "ampmInClock", "autoFocus", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableTime", "showViewSwitcher", "onChange", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "timezone"];
  const useUtilityClasses$7 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      arrowSwitcher: ["arrowSwitcher"]
    };
    return composeClasses(slots, getTimeClockUtilityClass, classes);
  };
  const TimeClockRoot = styled(PickerViewRoot, {
    name: "MuiTimeClock",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "flex",
    flexDirection: "column",
    position: "relative"
  });
  const TimeClockArrowSwitcher = styled(PickersArrowSwitcher, {
    name: "MuiTimeClock",
    slot: "ArrowSwitcher",
    overridesResolver: (props, styles2) => styles2.arrowSwitcher
  })({
    position: "absolute",
    right: 12,
    top: 15
  });
  const TIME_CLOCK_DEFAULT_VIEWS = ["hours", "minutes"];
  const TimeClock = /* @__PURE__ */ reactExports.forwardRef(function TimeClock2(inProps, ref) {
    const utils2 = useUtils();
    const props = useThemeProps({
      props: inProps,
      name: "MuiTimeClock"
    });
    const {
      ampm = utils2.is12HourCycleInCurrentLocale(),
      ampmInClock = false,
      autoFocus,
      slots,
      slotProps,
      value: valueProp,
      defaultValue,
      referenceDate: referenceDateProp,
      disableIgnoringDatePartForTimeValidation = false,
      maxTime,
      minTime,
      disableFuture,
      disablePast,
      minutesStep = 1,
      shouldDisableTime,
      showViewSwitcher,
      onChange,
      view: inView,
      views = TIME_CLOCK_DEFAULT_VIEWS,
      openTo,
      onViewChange,
      focusedView,
      onFocusedViewChange,
      className,
      disabled,
      readOnly,
      timezone: timezoneProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$c);
    const {
      value,
      handleValueChange,
      timezone
    } = useControlledValueWithTimezone({
      name: "TimeClock",
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange,
      valueManager: singleItemValueManager
    });
    const valueOrReferenceDate = useClockReferenceDate({
      value,
      referenceDate: referenceDateProp,
      utils: utils2,
      props,
      timezone
    });
    const translations = usePickersTranslations();
    const now = useNow(timezone);
    const {
      view,
      setView,
      previousView,
      nextView,
      setValueAndGoToNextView
    } = useViews({
      view: inView,
      views,
      openTo,
      onViewChange,
      onChange: handleValueChange,
      focusedView,
      onFocusedViewChange
    });
    const {
      meridiemMode,
      handleMeridiemChange
    } = useMeridiemMode(valueOrReferenceDate, ampm, setValueAndGoToNextView);
    const isTimeDisabled = reactExports.useCallback((rawValue, viewType) => {
      const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils2);
      const shouldCheckPastEnd = viewType === "hours" || viewType === "minutes" && views.includes("seconds");
      const containsValidTime = ({
        start: start2,
        end: end2
      }) => {
        if (minTime && isAfter(minTime, end2)) {
          return false;
        }
        if (maxTime && isAfter(start2, maxTime)) {
          return false;
        }
        if (disableFuture && isAfter(start2, now)) {
          return false;
        }
        if (disablePast && isAfter(now, shouldCheckPastEnd ? end2 : start2)) {
          return false;
        }
        return true;
      };
      const isValidValue = (timeValue, step = 1) => {
        if (timeValue % step !== 0) {
          return false;
        }
        if (shouldDisableTime) {
          switch (viewType) {
            case "hours":
              return !shouldDisableTime(utils2.setHours(valueOrReferenceDate, timeValue), "hours");
            case "minutes":
              return !shouldDisableTime(utils2.setMinutes(valueOrReferenceDate, timeValue), "minutes");
            case "seconds":
              return !shouldDisableTime(utils2.setSeconds(valueOrReferenceDate, timeValue), "seconds");
            default:
              return false;
          }
        }
        return true;
      };
      switch (viewType) {
        case "hours": {
          const valueWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
          const dateWithNewHours = utils2.setHours(valueOrReferenceDate, valueWithMeridiem);
          const start2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 0), 0);
          const end2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 59), 59);
          return !containsValidTime({
            start: start2,
            end: end2
          }) || !isValidValue(valueWithMeridiem);
        }
        case "minutes": {
          const dateWithNewMinutes = utils2.setMinutes(valueOrReferenceDate, rawValue);
          const start2 = utils2.setSeconds(dateWithNewMinutes, 0);
          const end2 = utils2.setSeconds(dateWithNewMinutes, 59);
          return !containsValidTime({
            start: start2,
            end: end2
          }) || !isValidValue(rawValue, minutesStep);
        }
        case "seconds": {
          const dateWithNewSeconds = utils2.setSeconds(valueOrReferenceDate, rawValue);
          const start2 = dateWithNewSeconds;
          const end2 = dateWithNewSeconds;
          return !containsValidTime({
            start: start2,
            end: end2
          }) || !isValidValue(rawValue);
        }
        default:
          throw new Error("not supported");
      }
    }, [ampm, valueOrReferenceDate, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableTime, utils2, disableFuture, disablePast, now, views]);
    const selectedId = useId();
    const viewProps = reactExports.useMemo(() => {
      switch (view) {
        case "hours": {
          const handleHoursChange = (hourValue, isFinish) => {
            const valueWithMeridiem = convertValueToMeridiem(hourValue, meridiemMode, ampm);
            setValueAndGoToNextView(utils2.setHours(valueOrReferenceDate, valueWithMeridiem), isFinish, "hours");
          };
          return {
            onChange: handleHoursChange,
            viewValue: utils2.getHours(valueOrReferenceDate),
            children: getHourNumbers({
              value,
              utils: utils2,
              ampm,
              onChange: handleHoursChange,
              getClockNumberText: translations.hoursClockNumberText,
              isDisabled: (hourValue) => disabled || isTimeDisabled(hourValue, "hours"),
              selectedId
            })
          };
        }
        case "minutes": {
          const minutesValue = utils2.getMinutes(valueOrReferenceDate);
          const handleMinutesChange = (minuteValue, isFinish) => {
            setValueAndGoToNextView(utils2.setMinutes(valueOrReferenceDate, minuteValue), isFinish, "minutes");
          };
          return {
            viewValue: minutesValue,
            onChange: handleMinutesChange,
            children: getMinutesNumbers({
              utils: utils2,
              value: minutesValue,
              onChange: handleMinutesChange,
              getClockNumberText: translations.minutesClockNumberText,
              isDisabled: (minuteValue) => disabled || isTimeDisabled(minuteValue, "minutes"),
              selectedId
            })
          };
        }
        case "seconds": {
          const secondsValue = utils2.getSeconds(valueOrReferenceDate);
          const handleSecondsChange = (secondValue, isFinish) => {
            setValueAndGoToNextView(utils2.setSeconds(valueOrReferenceDate, secondValue), isFinish, "seconds");
          };
          return {
            viewValue: secondsValue,
            onChange: handleSecondsChange,
            children: getMinutesNumbers({
              utils: utils2,
              value: secondsValue,
              onChange: handleSecondsChange,
              getClockNumberText: translations.secondsClockNumberText,
              isDisabled: (secondValue) => disabled || isTimeDisabled(secondValue, "seconds"),
              selectedId
            })
          };
        }
        default:
          throw new Error("You must provide the type for ClockView");
      }
    }, [view, utils2, value, ampm, translations.hoursClockNumberText, translations.minutesClockNumberText, translations.secondsClockNumberText, meridiemMode, setValueAndGoToNextView, valueOrReferenceDate, isTimeDisabled, selectedId, disabled]);
    const ownerState = props;
    const classes = useUtilityClasses$7(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TimeClockRoot, _extends$1({
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Clock, _extends$1({
        autoFocus: autoFocus ?? !!focusedView,
        ampmInClock: ampmInClock && views.includes("hours"),
        value,
        type: view,
        ampm,
        minutesStep,
        isTimeDisabled,
        meridiemMode,
        handleMeridiemChange,
        selectedId,
        disabled,
        readOnly
      }, viewProps)), showViewSwitcher && /* @__PURE__ */ jsxRuntimeExports.jsx(TimeClockArrowSwitcher, {
        className: classes.arrowSwitcher,
        slots,
        slotProps,
        onGoToPrevious: () => setView(previousView),
        isPreviousDisabled: !previousView,
        previousLabel: translations.openPreviousView,
        onGoToNext: () => setView(nextView),
        isNextDisabled: !nextView,
        nextLabel: translations.openNextView,
        ownerState
      })]
    }));
  });
  const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
  const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
  function getMenuItemUtilityClass(slot) {
    return generateUtilityClass("MuiMenuItem", slot);
  }
  const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
  const _excluded$b = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
  const overridesResolver = (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
  };
  const useUtilityClasses$6 = (ownerState) => {
    const {
      disabled,
      dense,
      divider,
      disableGutters,
      selected,
      classes
    } = ownerState;
    const slots = {
      root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
    };
    const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
    return _extends$1({}, classes, composedClasses);
  };
  const MenuItemRoot = styled(ButtonBase, {
    shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver
  })(({
    theme,
    ownerState
  }) => _extends$1({}, theme.typography.body1, {
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    minHeight: 48,
    paddingTop: 6,
    paddingBottom: 6,
    boxSizing: "border-box",
    whiteSpace: "nowrap"
  }, !ownerState.disableGutters && {
    paddingLeft: 16,
    paddingRight: 16
  }, ownerState.divider && {
    borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
    backgroundClip: "padding-box"
  }, {
    "&:hover": {
      textDecoration: "none",
      backgroundColor: (theme.vars || theme).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${menuItemClasses.selected}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity),
      [`&.${menuItemClasses.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      }
    },
    [`&.${menuItemClasses.selected}:hover`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity)
      }
    },
    [`&.${menuItemClasses.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette.action.focus
    },
    [`&.${menuItemClasses.disabled}`]: {
      opacity: (theme.vars || theme).palette.action.disabledOpacity
    },
    [`& + .${dividerClasses.root}`]: {
      marginTop: theme.spacing(1),
      marginBottom: theme.spacing(1)
    },
    [`& + .${dividerClasses.inset}`]: {
      marginLeft: 52
    },
    [`& .${listItemTextClasses.root}`]: {
      marginTop: 0,
      marginBottom: 0
    },
    [`& .${listItemTextClasses.inset}`]: {
      paddingLeft: 36
    },
    [`& .${listItemIconClasses.root}`]: {
      minWidth: 36
    }
  }, !ownerState.dense && {
    [theme.breakpoints.up("sm")]: {
      minHeight: "auto"
    }
  }, ownerState.dense && _extends$1({
    minHeight: 32,
    // https://m2.material.io/components/menus#specs > Dense
    paddingTop: 4,
    paddingBottom: 4
  }, theme.typography.body2, {
    [`& .${listItemIconClasses.root} svg`]: {
      fontSize: "1.25rem"
    }
  })));
  const MenuItem = /* @__PURE__ */ reactExports.forwardRef(function MenuItem2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiMenuItem"
    });
    const {
      autoFocus = false,
      component = "li",
      dense = false,
      divider = false,
      disableGutters = false,
      focusVisibleClassName,
      role = "menuitem",
      tabIndex: tabIndexProp,
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$b);
    const context = reactExports.useContext(ListContext);
    const childContext = reactExports.useMemo(() => ({
      dense: dense || context.dense || false,
      disableGutters
    }), [context.dense, dense, disableGutters]);
    const menuItemRef = reactExports.useRef(null);
    useEnhancedEffect(() => {
      if (autoFocus) {
        if (menuItemRef.current) {
          menuItemRef.current.focus();
        }
      }
    }, [autoFocus]);
    const ownerState = _extends$1({}, props, {
      dense: childContext.dense,
      divider,
      disableGutters
    });
    const classes = useUtilityClasses$6(props);
    const handleRef = useForkRef(menuItemRef, ref);
    let tabIndex;
    if (!props.disabled) {
      tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
      value: childContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, _extends$1({
        ref: handleRef,
        role,
        tabIndex,
        component,
        focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
        className: clsx(classes.root, className)
      }, other, {
        ownerState,
        classes
      }))
    });
  });
  function getDigitalClockUtilityClass(slot) {
    return generateUtilityClass("MuiDigitalClock", slot);
  }
  const digitalClockClasses = generateUtilityClasses("MuiDigitalClock", ["root", "list", "item"]);
  const _excluded$a = ["ampm", "timeStep", "autoFocus", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableTime", "onChange", "view", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "views", "skipDisabled", "timezone"];
  const useUtilityClasses$5 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      list: ["list"],
      item: ["item"]
    };
    return composeClasses(slots, getDigitalClockUtilityClass, classes);
  };
  const DigitalClockRoot = styled(PickerViewRoot, {
    name: "MuiDigitalClock",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    overflowY: "auto",
    width: "100%",
    "@media (prefers-reduced-motion: no-preference)": {
      scrollBehavior: "auto"
    },
    maxHeight: DIGITAL_CLOCK_VIEW_HEIGHT,
    variants: [{
      props: {
        alreadyRendered: true
      },
      style: {
        "@media (prefers-reduced-motion: no-preference)": {
          scrollBehavior: "smooth"
        }
      }
    }]
  });
  const DigitalClockList = styled(MenuList, {
    name: "MuiDigitalClock",
    slot: "List",
    overridesResolver: (props, styles2) => styles2.list
  })({
    padding: 0
  });
  const DigitalClockItem = styled(MenuItem, {
    name: "MuiDigitalClock",
    slot: "Item",
    overridesResolver: (props, styles2) => styles2.item
  })(({
    theme
  }) => ({
    padding: "8px 16px",
    margin: "2px 4px",
    "&:first-of-type": {
      marginTop: 4
    },
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
    },
    "&.Mui-selected": {
      backgroundColor: (theme.vars || theme).palette.primary.main,
      color: (theme.vars || theme).palette.primary.contrastText,
      "&:focus-visible, &:hover": {
        backgroundColor: (theme.vars || theme).palette.primary.dark
      }
    },
    "&.Mui-focusVisible": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity)
    }
  }));
  const DigitalClock = /* @__PURE__ */ reactExports.forwardRef(function DigitalClock2(inProps, ref) {
    const utils2 = useUtils();
    const containerRef = reactExports.useRef(null);
    const handleRef = useForkRef(ref, containerRef);
    const props = useThemeProps({
      props: inProps,
      name: "MuiDigitalClock"
    });
    const {
      ampm = utils2.is12HourCycleInCurrentLocale(),
      timeStep = 30,
      autoFocus,
      slots,
      slotProps,
      value: valueProp,
      defaultValue,
      referenceDate: referenceDateProp,
      disableIgnoringDatePartForTimeValidation = false,
      maxTime,
      minTime,
      disableFuture,
      disablePast,
      minutesStep = 1,
      shouldDisableTime,
      onChange,
      view: inView,
      openTo,
      onViewChange,
      focusedView,
      onFocusedViewChange,
      className,
      disabled,
      readOnly,
      views = ["hours"],
      skipDisabled = false,
      timezone: timezoneProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$a);
    const {
      value,
      handleValueChange: handleRawValueChange,
      timezone
    } = useControlledValueWithTimezone({
      name: "DigitalClock",
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange,
      valueManager: singleItemValueManager
    });
    const translations = usePickersTranslations();
    const now = useNow(timezone);
    const ownerState = reactExports.useMemo(() => _extends$1({}, props, {
      alreadyRendered: !!containerRef.current
    }), [props]);
    const classes = useUtilityClasses$5(ownerState);
    const ClockItem = (slots == null ? void 0 : slots.digitalClockItem) ?? DigitalClockItem;
    const clockItemProps = useSlotProps({
      elementType: ClockItem,
      externalSlotProps: slotProps == null ? void 0 : slotProps.digitalClockItem,
      ownerState: {},
      className: classes.item
    });
    const valueOrReferenceDate = useClockReferenceDate({
      value,
      referenceDate: referenceDateProp,
      utils: utils2,
      props,
      timezone
    });
    const handleValueChange = useEventCallback((newValue) => handleRawValueChange(newValue, "finish", "hours"));
    const {
      setValueAndGoToNextView
    } = useViews({
      view: inView,
      views,
      openTo,
      onViewChange,
      onChange: handleValueChange,
      focusedView,
      onFocusedViewChange
    });
    const handleItemSelect = useEventCallback((newValue) => {
      setValueAndGoToNextView(newValue, "finish");
    });
    reactExports.useEffect(() => {
      if (containerRef.current === null) {
        return;
      }
      const activeItem = containerRef.current.querySelector('[role="listbox"] [role="option"][tabindex="0"], [role="listbox"] [role="option"][aria-selected="true"]');
      if (!activeItem) {
        return;
      }
      const offsetTop = activeItem.offsetTop;
      if (autoFocus || !!focusedView) {
        activeItem.focus();
      }
      containerRef.current.scrollTop = offsetTop - 4;
    });
    const isTimeDisabled = reactExports.useCallback((valueToCheck) => {
      const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils2);
      const containsValidTime = () => {
        if (minTime && isAfter(minTime, valueToCheck)) {
          return false;
        }
        if (maxTime && isAfter(valueToCheck, maxTime)) {
          return false;
        }
        if (disableFuture && isAfter(valueToCheck, now)) {
          return false;
        }
        if (disablePast && isAfter(now, valueToCheck)) {
          return false;
        }
        return true;
      };
      const isValidValue = () => {
        if (utils2.getMinutes(valueToCheck) % minutesStep !== 0) {
          return false;
        }
        if (shouldDisableTime) {
          return !shouldDisableTime(valueToCheck, "hours");
        }
        return true;
      };
      return !containsValidTime() || !isValidValue();
    }, [disableIgnoringDatePartForTimeValidation, utils2, minTime, maxTime, disableFuture, now, disablePast, minutesStep, shouldDisableTime]);
    const timeOptions = reactExports.useMemo(() => {
      const startOfDay = utils2.startOfDay(valueOrReferenceDate);
      return [startOfDay, ...Array.from({
        length: Math.ceil(24 * 60 / timeStep) - 1
      }, (_2, index) => utils2.addMinutes(startOfDay, timeStep * (index + 1)))];
    }, [valueOrReferenceDate, timeStep, utils2]);
    const focusedOptionIndex = timeOptions.findIndex((option) => utils2.isEqual(option, valueOrReferenceDate));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClockRoot, _extends$1({
      ref: handleRef,
      className: clsx(classes.root, className),
      ownerState
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClockList, {
        role: "listbox",
        "aria-label": translations.timePickerToolbarTitle,
        className: classes.list,
        children: timeOptions.map((option, index) => {
          if (skipDisabled && isTimeDisabled(option)) {
            return null;
          }
          const isSelected = utils2.isEqual(option, value);
          const formattedValue = utils2.format(option, ampm ? "fullTime12h" : "fullTime24h");
          const tabIndex = focusedOptionIndex === index || focusedOptionIndex === -1 && index === 0 ? 0 : -1;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockItem, _extends$1({
            onClick: () => !readOnly && handleItemSelect(option),
            selected: isSelected,
            disabled: disabled || isTimeDisabled(option),
            disableRipple: readOnly,
            role: "option",
            "aria-disabled": readOnly,
            "aria-selected": isSelected,
            tabIndex
          }, clockItemProps, {
            children: formattedValue
          }), formattedValue);
        })
      })
    }));
  });
  function getMultiSectionDigitalClockUtilityClass(slot) {
    return generateUtilityClass("MuiMultiSectionDigitalClock", slot);
  }
  const multiSectionDigitalClockClasses = generateUtilityClasses("MuiMultiSectionDigitalClock", ["root"]);
  function getMultiSectionDigitalClockSectionUtilityClass(slot) {
    return generateUtilityClass("MuiMultiSectionDigitalClockSection", slot);
  }
  const multiSectionDigitalClockSectionClasses = generateUtilityClasses("MuiMultiSectionDigitalClockSection", ["root", "item"]);
  const _excluded$9 = ["autoFocus", "onChange", "className", "disabled", "readOnly", "items", "active", "slots", "slotProps", "skipDisabled"];
  const useUtilityClasses$4 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      item: ["item"]
    };
    return composeClasses(slots, getMultiSectionDigitalClockSectionUtilityClass, classes);
  };
  const MultiSectionDigitalClockSectionRoot = styled(MenuList, {
    name: "MuiMultiSectionDigitalClockSection",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })(({
    theme
  }) => ({
    maxHeight: DIGITAL_CLOCK_VIEW_HEIGHT,
    width: 56,
    padding: 0,
    overflow: "hidden",
    "@media (prefers-reduced-motion: no-preference)": {
      scrollBehavior: "auto"
    },
    "@media (pointer: fine)": {
      "&:hover": {
        overflowY: "auto"
      }
    },
    "@media (pointer: none), (pointer: coarse)": {
      overflowY: "auto"
    },
    "&:not(:first-of-type)": {
      borderLeft: `1px solid ${(theme.vars || theme).palette.divider}`
    },
    "&::after": {
      display: "block",
      content: '""',
      // subtracting the height of one item, extra margin and borders to make sure the max height is correct
      height: "calc(100% - 40px - 6px)"
    },
    variants: [{
      props: {
        alreadyRendered: true
      },
      style: {
        "@media (prefers-reduced-motion: no-preference)": {
          scrollBehavior: "smooth"
        }
      }
    }]
  }));
  const MultiSectionDigitalClockSectionItem = styled(MenuItem, {
    name: "MuiMultiSectionDigitalClockSection",
    slot: "Item",
    overridesResolver: (_2, styles2) => styles2.item
  })(({
    theme
  }) => ({
    padding: 8,
    margin: "2px 4px",
    width: MULTI_SECTION_CLOCK_SECTION_WIDTH,
    justifyContent: "center",
    "&:first-of-type": {
      marginTop: 4
    },
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
    },
    "&.Mui-selected": {
      backgroundColor: (theme.vars || theme).palette.primary.main,
      color: (theme.vars || theme).palette.primary.contrastText,
      "&:focus-visible, &:hover": {
        backgroundColor: (theme.vars || theme).palette.primary.dark
      }
    },
    "&.Mui-focusVisible": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity)
    }
  }));
  const MultiSectionDigitalClockSection = /* @__PURE__ */ reactExports.forwardRef(function MultiSectionDigitalClockSection2(inProps, ref) {
    const containerRef = reactExports.useRef(null);
    const handleRef = useForkRef(ref, containerRef);
    const previousActive = reactExports.useRef(null);
    const props = useThemeProps({
      props: inProps,
      name: "MuiMultiSectionDigitalClockSection"
    });
    const {
      autoFocus,
      onChange,
      className,
      disabled,
      readOnly,
      items,
      active,
      slots,
      slotProps,
      skipDisabled
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$9);
    const ownerState = reactExports.useMemo(() => _extends$1({}, props, {
      alreadyRendered: !!containerRef.current
    }), [props]);
    const classes = useUtilityClasses$4(ownerState);
    const DigitalClockSectionItem = (slots == null ? void 0 : slots.digitalClockSectionItem) ?? MultiSectionDigitalClockSectionItem;
    reactExports.useEffect(() => {
      if (containerRef.current === null) {
        return;
      }
      const activeItem = containerRef.current.querySelector('[role="option"][tabindex="0"], [role="option"][aria-selected="true"]');
      if (active && autoFocus && activeItem) {
        activeItem.focus();
      }
      if (!activeItem || previousActive.current === activeItem) {
        return;
      }
      previousActive.current = activeItem;
      const offsetTop = activeItem.offsetTop;
      containerRef.current.scrollTop = offsetTop - 4;
    });
    const focusedOptionIndex = items.findIndex((item) => item.isFocused(item.value));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClockSectionRoot, _extends$1({
      ref: handleRef,
      className: clsx(classes.root, className),
      ownerState,
      autoFocusItem: autoFocus && active,
      role: "listbox"
    }, other, {
      children: items.map((option, index) => {
        var _a;
        const isItemDisabled = (_a = option.isDisabled) == null ? void 0 : _a.call(option, option.value);
        const isDisabled = disabled || isItemDisabled;
        if (skipDisabled && isDisabled) {
          return null;
        }
        const isSelected = option.isSelected(option.value);
        const tabIndex = focusedOptionIndex === index || focusedOptionIndex === -1 && index === 0 ? 0 : -1;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClockSectionItem, _extends$1({
          onClick: () => !readOnly && onChange(option.value),
          selected: isSelected,
          disabled: isDisabled,
          disableRipple: readOnly,
          role: "option",
          "aria-disabled": readOnly || isDisabled || void 0,
          "aria-label": option.ariaLabel,
          "aria-selected": isSelected,
          tabIndex,
          className: classes.item
        }, slotProps == null ? void 0 : slotProps.digitalClockSectionItem, {
          children: option.label
        }), option.label);
      })
    }));
  });
  const getHourSectionOptions = ({
    now,
    value,
    utils: utils2,
    ampm,
    isDisabled,
    resolveAriaLabel,
    timeStep,
    valueOrReferenceDate
  }) => {
    const currentHours = value ? utils2.getHours(value) : null;
    const result = [];
    const isSelected = (hour, overriddenCurrentHours) => {
      const resolvedCurrentHours = overriddenCurrentHours ?? currentHours;
      if (resolvedCurrentHours === null) {
        return false;
      }
      if (ampm) {
        if (hour === 12) {
          return resolvedCurrentHours === 12 || resolvedCurrentHours === 0;
        }
        return resolvedCurrentHours === hour || resolvedCurrentHours - 12 === hour;
      }
      return resolvedCurrentHours === hour;
    };
    const isFocused = (hour) => {
      return isSelected(hour, utils2.getHours(valueOrReferenceDate));
    };
    const endHour = ampm ? 11 : 23;
    for (let hour = 0; hour <= endHour; hour += timeStep) {
      let label = utils2.format(utils2.setHours(now, hour), ampm ? "hours12h" : "hours24h");
      const ariaLabel = resolveAriaLabel(parseInt(label, 10).toString());
      label = utils2.formatNumber(label);
      result.push({
        value: hour,
        label,
        isSelected,
        isDisabled,
        isFocused,
        ariaLabel
      });
    }
    return result;
  };
  const getTimeSectionOptions = ({
    value,
    utils: utils2,
    isDisabled,
    timeStep,
    resolveLabel,
    resolveAriaLabel,
    hasValue: hasValue2 = true
  }) => {
    const isSelected = (timeValue) => {
      if (value === null) {
        return false;
      }
      return hasValue2 && value === timeValue;
    };
    const isFocused = (timeValue) => {
      return value === timeValue;
    };
    return [...Array.from({
      length: Math.ceil(60 / timeStep)
    }, (_2, index) => {
      const timeValue = timeStep * index;
      return {
        value: timeValue,
        label: utils2.formatNumber(resolveLabel(timeValue)),
        isDisabled,
        isSelected,
        isFocused,
        ariaLabel: resolveAriaLabel(timeValue.toString())
      };
    })];
  };
  const _excluded$8 = ["ampm", "timeSteps", "autoFocus", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableTime", "onChange", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "skipDisabled", "timezone"];
  const useUtilityClasses$3 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getMultiSectionDigitalClockUtilityClass, classes);
  };
  const MultiSectionDigitalClockRoot = styled(PickerViewRoot, {
    name: "MuiMultiSectionDigitalClock",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })(({
    theme
  }) => ({
    display: "flex",
    flexDirection: "row",
    width: "100%",
    borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
  }));
  const MultiSectionDigitalClock = /* @__PURE__ */ reactExports.forwardRef(function MultiSectionDigitalClock2(inProps, ref) {
    const utils2 = useUtils();
    const isRtl = useRtl();
    const props = useThemeProps({
      props: inProps,
      name: "MuiMultiSectionDigitalClock"
    });
    const {
      ampm = utils2.is12HourCycleInCurrentLocale(),
      timeSteps: inTimeSteps,
      autoFocus,
      slots,
      slotProps,
      value: valueProp,
      defaultValue,
      referenceDate: referenceDateProp,
      disableIgnoringDatePartForTimeValidation = false,
      maxTime,
      minTime,
      disableFuture,
      disablePast,
      minutesStep = 1,
      shouldDisableTime,
      onChange,
      view: inView,
      views: inViews = ["hours", "minutes"],
      openTo,
      onViewChange,
      focusedView: inFocusedView,
      onFocusedViewChange,
      className,
      disabled,
      readOnly,
      skipDisabled = false,
      timezone: timezoneProp
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$8);
    const {
      value,
      handleValueChange: handleRawValueChange,
      timezone
    } = useControlledValueWithTimezone({
      name: "MultiSectionDigitalClock",
      timezone: timezoneProp,
      value: valueProp,
      defaultValue,
      onChange,
      valueManager: singleItemValueManager
    });
    const translations = usePickersTranslations();
    const now = useNow(timezone);
    const timeSteps = reactExports.useMemo(() => _extends$1({
      hours: 1,
      minutes: 5,
      seconds: 5
    }, inTimeSteps), [inTimeSteps]);
    const valueOrReferenceDate = useClockReferenceDate({
      value,
      referenceDate: referenceDateProp,
      utils: utils2,
      props,
      timezone
    });
    const handleValueChange = useEventCallback((newValue, selectionState, selectedView) => handleRawValueChange(newValue, selectionState, selectedView));
    const views = reactExports.useMemo(() => {
      if (!ampm || !inViews.includes("hours")) {
        return inViews;
      }
      return inViews.includes("meridiem") ? inViews : [...inViews, "meridiem"];
    }, [ampm, inViews]);
    const {
      view,
      setValueAndGoToNextView,
      focusedView
    } = useViews({
      view: inView,
      views,
      openTo,
      onViewChange,
      onChange: handleValueChange,
      focusedView: inFocusedView,
      onFocusedViewChange
    });
    const handleMeridiemValueChange = useEventCallback((newValue) => {
      setValueAndGoToNextView(newValue, "finish", "meridiem");
    });
    const {
      meridiemMode,
      handleMeridiemChange
    } = useMeridiemMode(valueOrReferenceDate, ampm, handleMeridiemValueChange, "finish");
    const isTimeDisabled = reactExports.useCallback((rawValue, viewType) => {
      const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils2);
      const shouldCheckPastEnd = viewType === "hours" || viewType === "minutes" && views.includes("seconds");
      const containsValidTime = ({
        start: start2,
        end: end2
      }) => {
        if (minTime && isAfter(minTime, end2)) {
          return false;
        }
        if (maxTime && isAfter(start2, maxTime)) {
          return false;
        }
        if (disableFuture && isAfter(start2, now)) {
          return false;
        }
        if (disablePast && isAfter(now, shouldCheckPastEnd ? end2 : start2)) {
          return false;
        }
        return true;
      };
      const isValidValue = (timeValue, step = 1) => {
        if (timeValue % step !== 0) {
          return false;
        }
        if (shouldDisableTime) {
          switch (viewType) {
            case "hours":
              return !shouldDisableTime(utils2.setHours(valueOrReferenceDate, timeValue), "hours");
            case "minutes":
              return !shouldDisableTime(utils2.setMinutes(valueOrReferenceDate, timeValue), "minutes");
            case "seconds":
              return !shouldDisableTime(utils2.setSeconds(valueOrReferenceDate, timeValue), "seconds");
            default:
              return false;
          }
        }
        return true;
      };
      switch (viewType) {
        case "hours": {
          const valueWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
          const dateWithNewHours = utils2.setHours(valueOrReferenceDate, valueWithMeridiem);
          const start2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 0), 0);
          const end2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 59), 59);
          return !containsValidTime({
            start: start2,
            end: end2
          }) || !isValidValue(valueWithMeridiem);
        }
        case "minutes": {
          const dateWithNewMinutes = utils2.setMinutes(valueOrReferenceDate, rawValue);
          const start2 = utils2.setSeconds(dateWithNewMinutes, 0);
          const end2 = utils2.setSeconds(dateWithNewMinutes, 59);
          return !containsValidTime({
            start: start2,
            end: end2
          }) || !isValidValue(rawValue, minutesStep);
        }
        case "seconds": {
          const dateWithNewSeconds = utils2.setSeconds(valueOrReferenceDate, rawValue);
          const start2 = dateWithNewSeconds;
          const end2 = dateWithNewSeconds;
          return !containsValidTime({
            start: start2,
            end: end2
          }) || !isValidValue(rawValue);
        }
        default:
          throw new Error("not supported");
      }
    }, [ampm, valueOrReferenceDate, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableTime, utils2, disableFuture, disablePast, now, views]);
    const buildViewProps = reactExports.useCallback((viewToBuild) => {
      switch (viewToBuild) {
        case "hours": {
          return {
            onChange: (hours) => {
              const valueWithMeridiem = convertValueToMeridiem(hours, meridiemMode, ampm);
              setValueAndGoToNextView(utils2.setHours(valueOrReferenceDate, valueWithMeridiem), "finish", "hours");
            },
            items: getHourSectionOptions({
              now,
              value,
              ampm,
              utils: utils2,
              isDisabled: (hours) => isTimeDisabled(hours, "hours"),
              timeStep: timeSteps.hours,
              resolveAriaLabel: translations.hoursClockNumberText,
              valueOrReferenceDate
            })
          };
        }
        case "minutes": {
          return {
            onChange: (minutes) => {
              setValueAndGoToNextView(utils2.setMinutes(valueOrReferenceDate, minutes), "finish", "minutes");
            },
            items: getTimeSectionOptions({
              value: utils2.getMinutes(valueOrReferenceDate),
              utils: utils2,
              isDisabled: (minutes) => isTimeDisabled(minutes, "minutes"),
              resolveLabel: (minutes) => utils2.format(utils2.setMinutes(now, minutes), "minutes"),
              timeStep: timeSteps.minutes,
              hasValue: !!value,
              resolveAriaLabel: translations.minutesClockNumberText
            })
          };
        }
        case "seconds": {
          return {
            onChange: (seconds) => {
              setValueAndGoToNextView(utils2.setSeconds(valueOrReferenceDate, seconds), "finish", "seconds");
            },
            items: getTimeSectionOptions({
              value: utils2.getSeconds(valueOrReferenceDate),
              utils: utils2,
              isDisabled: (seconds) => isTimeDisabled(seconds, "seconds"),
              resolveLabel: (seconds) => utils2.format(utils2.setSeconds(now, seconds), "seconds"),
              timeStep: timeSteps.seconds,
              hasValue: !!value,
              resolveAriaLabel: translations.secondsClockNumberText
            })
          };
        }
        case "meridiem": {
          const amLabel = formatMeridiem(utils2, "am");
          const pmLabel = formatMeridiem(utils2, "pm");
          return {
            onChange: handleMeridiemChange,
            items: [{
              value: "am",
              label: amLabel,
              isSelected: () => !!value && meridiemMode === "am",
              isFocused: () => !!valueOrReferenceDate && meridiemMode === "am",
              ariaLabel: amLabel
            }, {
              value: "pm",
              label: pmLabel,
              isSelected: () => !!value && meridiemMode === "pm",
              isFocused: () => !!valueOrReferenceDate && meridiemMode === "pm",
              ariaLabel: pmLabel
            }]
          };
        }
        default:
          throw new Error(`Unknown view: ${viewToBuild} found.`);
      }
    }, [now, value, ampm, utils2, timeSteps.hours, timeSteps.minutes, timeSteps.seconds, translations.hoursClockNumberText, translations.minutesClockNumberText, translations.secondsClockNumberText, meridiemMode, setValueAndGoToNextView, valueOrReferenceDate, isTimeDisabled, handleMeridiemChange]);
    const viewsToRender = reactExports.useMemo(() => {
      if (!isRtl) {
        return views;
      }
      const digitViews = views.filter((v2) => v2 !== "meridiem");
      const result = digitViews.toReversed();
      if (views.includes("meridiem")) {
        result.push("meridiem");
      }
      return result;
    }, [isRtl, views]);
    const viewTimeOptions = reactExports.useMemo(() => {
      return views.reduce((result, currentView) => {
        return _extends$1({}, result, {
          [currentView]: buildViewProps(currentView)
        });
      }, {});
    }, [views, buildViewProps]);
    const ownerState = props;
    const classes = useUtilityClasses$3(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClockRoot, _extends$1({
      ref,
      className: clsx(classes.root, className),
      ownerState,
      role: "group"
    }, other, {
      children: viewsToRender.map((timeView) => /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClockSection, {
        items: viewTimeOptions[timeView].items,
        onChange: viewTimeOptions[timeView].onChange,
        active: view === timeView,
        autoFocus: autoFocus ?? focusedView === timeView,
        disabled,
        readOnly,
        slots,
        slotProps,
        skipDisabled,
        "aria-label": translations.selectViewText(timeView)
      }, timeView))
    }));
  });
  const renderTimeViewClock = ({
    view,
    onViewChange,
    focusedView,
    onFocusedViewChange,
    views,
    value,
    defaultValue,
    referenceDate,
    onChange,
    className,
    classes,
    disableFuture,
    disablePast,
    minTime,
    maxTime,
    shouldDisableTime,
    minutesStep,
    ampm,
    ampmInClock,
    slots,
    slotProps,
    readOnly,
    disabled,
    sx,
    autoFocus,
    showViewSwitcher,
    disableIgnoringDatePartForTimeValidation,
    timezone
  }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TimeClock, {
    view,
    onViewChange,
    focusedView: focusedView && isTimeView(focusedView) ? focusedView : null,
    onFocusedViewChange,
    views: views.filter(isTimeView),
    value,
    defaultValue,
    referenceDate,
    onChange,
    className,
    classes,
    disableFuture,
    disablePast,
    minTime,
    maxTime,
    shouldDisableTime,
    minutesStep,
    ampm,
    ampmInClock,
    slots,
    slotProps,
    readOnly,
    disabled,
    sx,
    autoFocus,
    showViewSwitcher,
    disableIgnoringDatePartForTimeValidation,
    timezone
  });
  const renderDigitalClockTimeView = ({
    view,
    onViewChange,
    focusedView,
    onFocusedViewChange,
    views,
    value,
    defaultValue,
    referenceDate,
    onChange,
    className,
    classes,
    disableFuture,
    disablePast,
    minTime,
    maxTime,
    shouldDisableTime,
    minutesStep,
    ampm,
    slots,
    slotProps,
    readOnly,
    disabled,
    sx,
    autoFocus,
    disableIgnoringDatePartForTimeValidation,
    timeSteps,
    skipDisabled,
    timezone
  }) => /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClock, {
    view,
    onViewChange,
    focusedView,
    onFocusedViewChange,
    views: views.filter(isTimeView),
    value,
    defaultValue,
    referenceDate,
    onChange,
    className,
    classes,
    disableFuture,
    disablePast,
    minTime,
    maxTime,
    shouldDisableTime,
    minutesStep,
    ampm,
    slots,
    slotProps,
    readOnly,
    disabled,
    sx,
    autoFocus,
    disableIgnoringDatePartForTimeValidation,
    timeStep: timeSteps == null ? void 0 : timeSteps.minutes,
    skipDisabled,
    timezone
  });
  const renderMultiSectionDigitalClockTimeView = ({
    view,
    onViewChange,
    focusedView,
    onFocusedViewChange,
    views,
    value,
    defaultValue,
    referenceDate,
    onChange,
    className,
    classes,
    disableFuture,
    disablePast,
    minTime,
    maxTime,
    shouldDisableTime,
    minutesStep,
    ampm,
    slots,
    slotProps,
    readOnly,
    disabled,
    sx,
    autoFocus,
    disableIgnoringDatePartForTimeValidation,
    timeSteps,
    skipDisabled,
    timezone
  }) => /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClock, {
    view,
    onViewChange,
    focusedView,
    onFocusedViewChange,
    views: views.filter(isTimeView),
    value,
    defaultValue,
    referenceDate,
    onChange,
    className,
    classes,
    disableFuture,
    disablePast,
    minTime,
    maxTime,
    shouldDisableTime,
    minutesStep,
    ampm,
    slots,
    slotProps,
    readOnly,
    disabled,
    sx,
    autoFocus,
    disableIgnoringDatePartForTimeValidation,
    timeSteps,
    skipDisabled,
    timezone
  });
  const DesktopDateTimePickerLayout = /* @__PURE__ */ reactExports.forwardRef(function DesktopDateTimePickerLayout2(props, ref) {
    var _a;
    const isRtl = useRtl();
    const {
      toolbar,
      tabs,
      content,
      actionBar,
      shortcuts
    } = usePickerLayout(props);
    const {
      sx,
      className,
      isLandscape,
      classes
    } = props;
    const isActionBarVisible = actionBar && (((_a = actionBar.props.actions) == null ? void 0 : _a.length) ?? 0) > 0;
    const ownerState = _extends$1({}, props, {
      isRtl
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersLayoutRoot, {
      ref,
      className: clsx(className, pickersLayoutClasses.root, classes == null ? void 0 : classes.root),
      sx: [{
        [`& .${pickersLayoutClasses.tabs}`]: {
          gridRow: 4,
          gridColumn: "1 / 4"
        },
        [`& .${pickersLayoutClasses.actionBar}`]: {
          gridRow: 5
        }
      }, ...Array.isArray(sx) ? sx : [sx]],
      ownerState,
      children: [isLandscape ? shortcuts : toolbar, isLandscape ? toolbar : shortcuts, /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersLayoutContentWrapper, {
        className: clsx(pickersLayoutClasses.contentWrapper, classes == null ? void 0 : classes.contentWrapper),
        sx: {
          display: "grid"
        },
        children: [content, tabs, isActionBarVisible && /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {
          sx: {
            gridRow: 3,
            gridColumn: "1 / 4"
          }
        })]
      }), actionBar]
    });
  });
  const _excluded$7 = ["openTo", "focusedView", "timeViewsCount"];
  const rendererInterceptor = function rendererInterceptor2(inViewRenderers, popperView, rendererProps) {
    var _a, _b;
    const {
      openTo,
      focusedView,
      timeViewsCount
    } = rendererProps, otherProps = _objectWithoutPropertiesLoose(rendererProps, _excluded$7);
    const finalProps = _extends$1({}, otherProps, {
      focusedView: null,
      sx: [{
        [`&.${multiSectionDigitalClockClasses.root}`]: {
          borderBottom: 0
        },
        [`&.${multiSectionDigitalClockClasses.root}, .${multiSectionDigitalClockSectionClasses.root}, &.${digitalClockClasses.root}`]: {
          maxHeight: VIEW_HEIGHT
        }
      }]
    });
    const isTimeViewActive = isInternalTimeView(popperView);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [(_a = inViewRenderers[!isTimeViewActive ? popperView : "day"]) == null ? void 0 : _a.call(inViewRenderers, _extends$1({}, rendererProps, {
        view: !isTimeViewActive ? popperView : "day",
        focusedView: focusedView && isDatePickerView(focusedView) ? focusedView : null,
        views: rendererProps.views.filter(isDatePickerView),
        sx: [{
          gridColumn: 1
        }, ...finalProps.sx]
      })), timeViewsCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {
          orientation: "vertical",
          sx: {
            gridColumn: 2
          }
        }), (_b = inViewRenderers[isTimeViewActive ? popperView : "hours"]) == null ? void 0 : _b.call(inViewRenderers, _extends$1({}, finalProps, {
          view: isTimeViewActive ? popperView : "hours",
          focusedView: focusedView && isInternalTimeView(focusedView) ? focusedView : null,
          openTo: isInternalTimeView(openTo) ? openTo : "hours",
          views: rendererProps.views.filter(isInternalTimeView),
          sx: [{
            gridColumn: 3
          }, ...finalProps.sx]
        }))]
      })]
    });
  };
  const DesktopDateTimePicker = /* @__PURE__ */ reactExports.forwardRef(function DesktopDateTimePicker2(inProps, ref) {
    var _a, _b, _c, _d;
    const translations = usePickersTranslations();
    const utils2 = useUtils();
    const defaultizedProps = useDateTimePickerDefaultizedProps(inProps, "MuiDesktopDateTimePicker");
    const {
      shouldRenderTimeInASingleColumn,
      thresholdToRenderTimeInASingleColumn,
      views: resolvedViews,
      timeSteps
    } = resolveTimeViewsResponse(defaultizedProps);
    const renderTimeView = shouldRenderTimeInASingleColumn ? renderDigitalClockTimeView : renderMultiSectionDigitalClockTimeView;
    const viewRenderers = _extends$1({
      day: renderDateViewCalendar,
      month: renderDateViewCalendar,
      year: renderDateViewCalendar,
      hours: renderTimeView,
      minutes: renderTimeView,
      seconds: renderTimeView,
      meridiem: renderTimeView
    }, defaultizedProps.viewRenderers);
    const ampmInClock = defaultizedProps.ampmInClock ?? true;
    const shouldHoursRendererContainMeridiemView = ((_a = viewRenderers.hours) == null ? void 0 : _a.name) === renderMultiSectionDigitalClockTimeView.name;
    const views = !shouldHoursRendererContainMeridiemView ? resolvedViews.filter((view) => view !== "meridiem") : resolvedViews;
    const actionBarActions = shouldRenderTimeInASingleColumn ? [] : ["accept"];
    const props = _extends$1({}, defaultizedProps, {
      viewRenderers,
      format: resolveDateTimeFormat(utils2, defaultizedProps),
      views,
      yearsPerRow: defaultizedProps.yearsPerRow ?? 4,
      ampmInClock,
      timeSteps,
      thresholdToRenderTimeInASingleColumn,
      shouldRenderTimeInASingleColumn,
      slots: _extends$1({
        field: DateTimeField,
        layout: DesktopDateTimePickerLayout,
        openPickerIcon: CalendarIcon
      }, defaultizedProps.slots),
      slotProps: _extends$1({}, defaultizedProps.slotProps, {
        field: (ownerState) => {
          var _a2;
          return _extends$1({}, resolveComponentProps((_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.field, ownerState), extractValidationProps(defaultizedProps), {
            ref
          });
        },
        toolbar: _extends$1({
          hidden: true,
          ampmInClock,
          toolbarVariant: "desktop"
        }, (_b = defaultizedProps.slotProps) == null ? void 0 : _b.toolbar),
        tabs: _extends$1({
          hidden: true
        }, (_c = defaultizedProps.slotProps) == null ? void 0 : _c.tabs),
        actionBar: (ownerState) => {
          var _a2;
          return _extends$1({
            actions: actionBarActions
          }, resolveComponentProps((_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.actionBar, ownerState));
        }
      })
    });
    const {
      renderPicker
    } = useDesktopPicker({
      props,
      valueManager: singleItemValueManager,
      valueType: "date-time",
      getOpenDialogAriaText: ((_d = props.localeText) == null ? void 0 : _d.openDatePickerDialogue) ?? translations.openDatePickerDialogue,
      validator: validateDateTime,
      rendererInterceptor
    });
    return renderPicker();
  });
  DesktopDateTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default utils.is12HourCycleInCurrentLocale()
     */
    ampm: PropTypes.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default true on desktop, false on mobile
     */
    ampmInClock: PropTypes.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: PropTypes.bool,
    className: PropTypes.string,
    /**
     * If `true`, the popover or modal will close after submitting the full date.
     * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: PropTypes.bool,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {TDate} date The date of the day of week provided by the adapter.
     * @returns {string} The name to display.
     * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: PropTypes.func,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: PropTypes.object,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: PropTypes.bool,
    /**
     * If `true`, disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: PropTypes.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: PropTypes.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: PropTypes.bool,
    /**
     * If `true`, the open picker button will not be rendered (renders only the field).
     * @default false
     */
    disableOpenPicker: PropTypes.bool,
    /**
     * If `true`, disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: PropTypes.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: PropTypes.bool,
    /**
     * @default false
     */
    enableAccessibleFieldDOMStructure: PropTypes.any,
    /**
     * The day view will show as many weeks as needed after the end of the current month to match this value.
     * Put it to 6 to have a fixed number of weeks in Gregorian calendars
     */
    fixedWeekNumber: PropTypes.number,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: PropTypes.string,
    /**
     * Density of the format when rendered in the input.
     * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
     * @default "dense"
     */
    formatDensity: PropTypes.oneOf(["dense", "spacious"]),
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: refType,
    /**
     * The label content.
     */
    label: PropTypes.node,
    /**
     * If `true`, calls `renderLoading` instead of rendering the day calendar.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: PropTypes.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: PropTypes.object,
    /**
     * Maximal selectable date.
     * @default 2099-12-31
     */
    maxDate: PropTypes.object,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: PropTypes.object,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: PropTypes.object,
    /**
     * Minimal selectable date.
     * @default 1900-01-01
     */
    minDate: PropTypes.object,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: PropTypes.object,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: PropTypes.object,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: PropTypes.number,
    /**
     * Months rendered per row.
     * @default 3
     */
    monthsPerRow: PropTypes.oneOf([3, 4]),
    /**
     * Name attribute used by the `input` element in the Field.
     */
    name: PropTypes.string,
    /**
     * Callback fired when the value is accepted.
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TValue} value The value that was just accepted.
     * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
     */
    onAccept: PropTypes.func,
    /**
     * Callback fired when the value changes.
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
     */
    onChange: PropTypes.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see `open`).
     */
    onClose: PropTypes.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: PropTypes.func,
    /**
     * Callback fired on month change.
     * @template TDate
     * @param {TDate} month The new month.
     */
    onMonthChange: PropTypes.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see `open`).
     */
    onOpen: PropTypes.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: PropTypes.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: PropTypes.func,
    /**
     * Callback fired on year change.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: PropTypes.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: PropTypes.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: PropTypes.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
    /**
     * Force rendering in particular orientation.
     */
    orientation: PropTypes.oneOf(["landscape", "portrait"]),
    readOnly: PropTypes.bool,
    /**
     * If `true`, disable heavy animations.
     * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
     */
    reduceAnimations: PropTypes.bool,
    /**
     * The date used to generate the new value when both `value` and `defaultValue` are empty.
     * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
     */
    referenceDate: PropTypes.object,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: PropTypes.func,
    /**
     * The currently selected sections.
     * This prop accepts four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
     * 3. If `"all"` is provided, all the sections will be selected.
     * 4. If `null` is provided, no section will be selected.
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number]),
    /**
     * Disable specific date.
     *
     * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
     *
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: PropTypes.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true`, the month will be disabled.
     */
    shouldDisableMonth: PropTypes.func,
    /**
     * Disable specific time.
     * @template TDate
     * @param {TDate} value The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: PropTypes.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true`, the year will be disabled.
     */
    shouldDisableYear: PropTypes.func,
    /**
     * If `true`, days outside the current month are rendered:
     *
     * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
     *
     * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
     *
     * - ignored if `calendars` equals more than `1` on range pickers.
     * @default false
     */
    showDaysOutsideCurrentMonth: PropTypes.bool,
    /**
     * If `true`, disabled digital clock items will not be rendered.
     * @default false
     */
    skipDisabled: PropTypes.bool,
    /**
     * The props used for each component slot.
     * @default {}
     */
    slotProps: PropTypes.object,
    /**
     * Overridable component slots.
     * @default {}
     */
    slots: PropTypes.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
    /**
     * Amount of time options below or at which the single column time renderer is used.
     * @default 24
     */
    thresholdToRenderTimeInASingleColumn: PropTypes.number,
    /**
     * The time steps between two time unit options.
     * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
     * When single column time renderer is used, only `timeStep.minutes` will be used.
     * @default{ hours: 1, minutes: 5, seconds: 5 }
     */
    timeSteps: PropTypes.shape({
      hours: PropTypes.number,
      minutes: PropTypes.number,
      seconds: PropTypes.number
    }),
    /**
     * Choose which timezone to use for the value.
     * Example: "default", "system", "UTC", "America/New_York".
     * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
     * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
     * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
     */
    timezone: PropTypes.string,
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: PropTypes.object,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: PropTypes.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be used.
     */
    viewRenderers: PropTypes.shape({
      day: PropTypes.func,
      hours: PropTypes.func,
      meridiem: PropTypes.func,
      minutes: PropTypes.func,
      month: PropTypes.func,
      seconds: PropTypes.func,
      year: PropTypes.func
    }),
    /**
     * Available views.
     */
    views: PropTypes.arrayOf(PropTypes.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
    /**
     * Years rendered per row.
     * @default 4
     */
    yearsPerRow: PropTypes.oneOf([3, 4])
  };
  function getDialogContentUtilityClass(slot) {
    return generateUtilityClass("MuiDialogContent", slot);
  }
  generateUtilityClasses("MuiDialogContent", ["root", "dividers"]);
  const dialogTitleClasses = generateUtilityClasses("MuiDialogTitle", ["root"]);
  const _excluded$6 = ["className", "dividers"];
  const useUtilityClasses$2 = (ownerState) => {
    const {
      classes,
      dividers
    } = ownerState;
    const slots = {
      root: ["root", dividers && "dividers"]
    };
    return composeClasses(slots, getDialogContentUtilityClass, classes);
  };
  const DialogContentRoot = styled("div", {
    name: "MuiDialogContent",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.dividers && styles2.dividers];
    }
  })(({
    theme,
    ownerState
  }) => _extends$1({
    flex: "1 1 auto",
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: "touch",
    overflowY: "auto",
    padding: "20px 24px"
  }, ownerState.dividers ? {
    padding: "16px 24px",
    borderTop: `1px solid ${(theme.vars || theme).palette.divider}`,
    borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
  } : {
    [`.${dialogTitleClasses.root} + &`]: {
      paddingTop: 0
    }
  }));
  const DialogContent = /* @__PURE__ */ reactExports.forwardRef(function DialogContent2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiDialogContent"
    });
    const {
      className,
      dividers = false
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$6);
    const ownerState = _extends$1({}, props, {
      dividers
    });
    const classes = useUtilityClasses$2(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentRoot, _extends$1({
      className: clsx(classes.root, className),
      ownerState,
      ref
    }, other));
  });
  function getDialogUtilityClass(slot) {
    return generateUtilityClass("MuiDialog", slot);
  }
  const dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
  const DialogContext = /* @__PURE__ */ reactExports.createContext({});
  const _excluded$5 = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"];
  const DialogBackdrop = styled(Backdrop, {
    name: "MuiDialog",
    slot: "Backdrop",
    overrides: (props, styles2) => styles2.backdrop
  })({
    // Improve scrollable dialog support.
    zIndex: -1
  });
  const useUtilityClasses$1 = (ownerState) => {
    const {
      classes,
      scroll,
      maxWidth: maxWidth2,
      fullWidth,
      fullScreen
    } = ownerState;
    const slots = {
      root: ["root"],
      container: ["container", `scroll${capitalize$1(scroll)}`],
      paper: ["paper", `paperScroll${capitalize$1(scroll)}`, `paperWidth${capitalize$1(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
    };
    return composeClasses(slots, getDialogUtilityClass, classes);
  };
  const DialogRoot = styled(Modal, {
    name: "MuiDialog",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    "@media print": {
      // Use !important to override the Modal inline-style.
      position: "absolute !important"
    }
  });
  const DialogContainer = styled("div", {
    name: "MuiDialog",
    slot: "Container",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.container, styles2[`scroll${capitalize$1(ownerState.scroll)}`]];
    }
  })(({
    ownerState
  }) => _extends$1({
    height: "100%",
    "@media print": {
      height: "auto"
    },
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  }, ownerState.scroll === "paper" && {
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  }, ownerState.scroll === "body" && {
    overflowY: "auto",
    overflowX: "hidden",
    textAlign: "center",
    "&::after": {
      content: '""',
      display: "inline-block",
      verticalAlign: "middle",
      height: "100%",
      width: "0"
    }
  }));
  const DialogPaper = styled(Paper, {
    name: "MuiDialog",
    slot: "Paper",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.paper, styles2[`scrollPaper${capitalize$1(ownerState.scroll)}`], styles2[`paperWidth${capitalize$1(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
    }
  })(({
    theme,
    ownerState
  }) => _extends$1({
    margin: 32,
    position: "relative",
    overflowY: "auto",
    // Fix IE11 issue, to remove at some point.
    "@media print": {
      overflowY: "visible",
      boxShadow: "none"
    }
  }, ownerState.scroll === "paper" && {
    display: "flex",
    flexDirection: "column",
    maxHeight: "calc(100% - 64px)"
  }, ownerState.scroll === "body" && {
    display: "inline-block",
    verticalAlign: "middle",
    textAlign: "left"
    // 'initial' doesn't work on IE11
  }, !ownerState.maxWidth && {
    maxWidth: "calc(100% - 64px)"
  }, ownerState.maxWidth === "xs" && {
    maxWidth: theme.breakpoints.unit === "px" ? Math.max(theme.breakpoints.values.xs, 444) : `max(${theme.breakpoints.values.xs}${theme.breakpoints.unit}, 444px)`,
    [`&.${dialogClasses.paperScrollBody}`]: {
      [theme.breakpoints.down(Math.max(theme.breakpoints.values.xs, 444) + 32 * 2)]: {
        maxWidth: "calc(100% - 64px)"
      }
    }
  }, ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
    maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`,
    [`&.${dialogClasses.paperScrollBody}`]: {
      [theme.breakpoints.down(theme.breakpoints.values[ownerState.maxWidth] + 32 * 2)]: {
        maxWidth: "calc(100% - 64px)"
      }
    }
  }, ownerState.fullWidth && {
    width: "calc(100% - 64px)"
  }, ownerState.fullScreen && {
    margin: 0,
    width: "100%",
    maxWidth: "100%",
    height: "100%",
    maxHeight: "none",
    borderRadius: 0,
    [`&.${dialogClasses.paperScrollBody}`]: {
      margin: 0,
      maxWidth: "100%"
    }
  }));
  const Dialog = /* @__PURE__ */ reactExports.forwardRef(function Dialog2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiDialog"
    });
    const theme = useTheme$1();
    const defaultTransitionDuration = {
      enter: theme.transitions.duration.enteringScreen,
      exit: theme.transitions.duration.leavingScreen
    };
    const {
      "aria-describedby": ariaDescribedby,
      "aria-labelledby": ariaLabelledbyProp,
      BackdropComponent,
      BackdropProps,
      children,
      className,
      disableEscapeKeyDown = false,
      fullScreen = false,
      fullWidth = false,
      maxWidth: maxWidth2 = "sm",
      onBackdropClick,
      onClick,
      onClose,
      open,
      PaperComponent = Paper,
      PaperProps = {},
      scroll = "paper",
      TransitionComponent = Fade,
      transitionDuration = defaultTransitionDuration,
      TransitionProps
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$5);
    const ownerState = _extends$1({}, props, {
      disableEscapeKeyDown,
      fullScreen,
      fullWidth,
      maxWidth: maxWidth2,
      scroll
    });
    const classes = useUtilityClasses$1(ownerState);
    const backdropClick = reactExports.useRef();
    const handleMouseDown = (event) => {
      backdropClick.current = event.target === event.currentTarget;
    };
    const handleBackdropClick = (event) => {
      if (onClick) {
        onClick(event);
      }
      if (!backdropClick.current) {
        return;
      }
      backdropClick.current = null;
      if (onBackdropClick) {
        onBackdropClick(event);
      }
      if (onClose) {
        onClose(event, "backdropClick");
      }
    };
    const ariaLabelledby = useId(ariaLabelledbyProp);
    const dialogContextValue = reactExports.useMemo(() => {
      return {
        titleId: ariaLabelledby
      };
    }, [ariaLabelledby]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogRoot, _extends$1({
      className: clsx(classes.root, className),
      closeAfterTransition: true,
      components: {
        Backdrop: DialogBackdrop
      },
      componentsProps: {
        backdrop: _extends$1({
          transitionDuration,
          as: BackdropComponent
        }, BackdropProps)
      },
      disableEscapeKeyDown,
      onClose,
      open,
      ref,
      onClick: handleBackdropClick,
      ownerState
    }, other, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        appear: true,
        in: open,
        timeout: transitionDuration,
        role: "presentation"
      }, TransitionProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContainer, {
          className: clsx(classes.container),
          onMouseDown: handleMouseDown,
          ownerState,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPaper, _extends$1({
            as: PaperComponent,
            elevation: 24,
            role: "dialog",
            "aria-describedby": ariaDescribedby,
            "aria-labelledby": ariaLabelledby
          }, PaperProps, {
            className: clsx(classes.paper, PaperProps.className),
            ownerState,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContext.Provider, {
              value: dialogContextValue,
              children
            })
          }))
        })
      }))
    }));
  });
  const PickersModalDialogRoot = styled(Dialog)({
    [`& .${dialogClasses.container}`]: {
      outline: 0
    },
    [`& .${dialogClasses.paper}`]: {
      outline: 0,
      minWidth: DIALOG_WIDTH
    }
  });
  const PickersModalDialogContent = styled(DialogContent)({
    "&:first-of-type": {
      padding: 0
    }
  });
  function PickersModalDialog(props) {
    const {
      children,
      onDismiss,
      open,
      slots,
      slotProps
    } = props;
    const Dialog2 = (slots == null ? void 0 : slots.dialog) ?? PickersModalDialogRoot;
    const Transition2 = (slots == null ? void 0 : slots.mobileTransition) ?? Fade;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog2, _extends$1({
      open,
      onClose: onDismiss
    }, slotProps == null ? void 0 : slotProps.dialog, {
      TransitionComponent: Transition2,
      TransitionProps: slotProps == null ? void 0 : slotProps.mobileTransition,
      PaperComponent: slots == null ? void 0 : slots.mobilePaper,
      PaperProps: slotProps == null ? void 0 : slotProps.mobilePaper,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersModalDialogContent, {
        children
      })
    }));
  }
  const _excluded$4 = ["props", "getOpenDialogAriaText"];
  const useMobilePicker = (_ref) => {
    var _a;
    let {
      props,
      getOpenDialogAriaText
    } = _ref, pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded$4);
    const {
      slots,
      slotProps: innerSlotProps,
      className,
      sx,
      format,
      formatDensity,
      enableAccessibleFieldDOMStructure,
      selectedSections,
      onSelectedSectionsChange,
      timezone,
      name,
      label,
      inputRef,
      readOnly,
      disabled,
      localeText
    } = props;
    const utils2 = useUtils();
    const fieldRef = reactExports.useRef(null);
    const labelId = useId();
    const isToolbarHidden = ((_a = innerSlotProps == null ? void 0 : innerSlotProps.toolbar) == null ? void 0 : _a.hidden) ?? false;
    const {
      open,
      actions,
      layoutProps,
      renderCurrentView,
      fieldProps: pickerFieldProps
    } = usePicker(_extends$1({}, pickerParams, {
      props,
      fieldRef,
      autoFocusView: true,
      additionalViewProps: {},
      wrapperVariant: "mobile"
    }));
    const Field = slots.field;
    const fieldProps = useSlotProps({
      elementType: Field,
      externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.field,
      additionalProps: _extends$1({}, pickerFieldProps, isToolbarHidden && {
        id: labelId
      }, !(disabled || readOnly) && {
        onClick: actions.onOpen,
        onKeyDown: onSpaceOrEnter(actions.onOpen)
      }, {
        readOnly: readOnly ?? true,
        disabled,
        className,
        sx,
        format,
        formatDensity,
        enableAccessibleFieldDOMStructure,
        selectedSections,
        onSelectedSectionsChange,
        timezone,
        label,
        name
      }, inputRef ? {
        inputRef
      } : {}),
      ownerState: props
    });
    fieldProps.inputProps = _extends$1({}, fieldProps.inputProps, {
      "aria-label": getOpenDialogAriaText(pickerFieldProps.value, utils2)
    });
    const slotsForField = _extends$1({
      textField: slots.textField
    }, fieldProps.slots);
    const Layout = slots.layout ?? PickersLayout;
    let labelledById = labelId;
    if (isToolbarHidden) {
      if (label) {
        labelledById = `${labelId}-label`;
      } else {
        labelledById = void 0;
      }
    }
    const slotProps = _extends$1({}, innerSlotProps, {
      toolbar: _extends$1({}, innerSlotProps == null ? void 0 : innerSlotProps.toolbar, {
        titleId: labelId
      }),
      mobilePaper: _extends$1({
        "aria-labelledby": labelledById
      }, innerSlotProps == null ? void 0 : innerSlotProps.mobilePaper)
    });
    const handleFieldRef = useForkRef(fieldRef, fieldProps.unstableFieldRef);
    const renderPicker = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(LocalizationProvider, {
      localeText,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Field, _extends$1({}, fieldProps, {
        slots: slotsForField,
        slotProps,
        unstableFieldRef: handleFieldRef
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersModalDialog, _extends$1({}, actions, {
        open,
        slots,
        slotProps,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, _extends$1({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
          slots,
          slotProps,
          children: renderCurrentView()
        }))
      }))]
    });
    return {
      renderPicker
    };
  };
  const MobileDateTimePicker = /* @__PURE__ */ reactExports.forwardRef(function MobileDateTimePicker2(inProps, ref) {
    var _a, _b, _c;
    const translations = usePickersTranslations();
    const utils2 = useUtils();
    const defaultizedProps = useDateTimePickerDefaultizedProps(inProps, "MuiMobileDateTimePicker");
    const viewRenderers = _extends$1({
      day: renderDateViewCalendar,
      month: renderDateViewCalendar,
      year: renderDateViewCalendar,
      hours: renderTimeViewClock,
      minutes: renderTimeViewClock,
      seconds: renderTimeViewClock
    }, defaultizedProps.viewRenderers);
    const ampmInClock = defaultizedProps.ampmInClock ?? false;
    const props = _extends$1({}, defaultizedProps, {
      viewRenderers,
      format: resolveDateTimeFormat(utils2, defaultizedProps),
      ampmInClock,
      slots: _extends$1({
        field: DateTimeField
      }, defaultizedProps.slots),
      slotProps: _extends$1({}, defaultizedProps.slotProps, {
        field: (ownerState) => {
          var _a2;
          return _extends$1({}, resolveComponentProps((_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.field, ownerState), extractValidationProps(defaultizedProps), {
            ref
          });
        },
        toolbar: _extends$1({
          hidden: false,
          ampmInClock
        }, (_a = defaultizedProps.slotProps) == null ? void 0 : _a.toolbar),
        tabs: _extends$1({
          hidden: false
        }, (_b = defaultizedProps.slotProps) == null ? void 0 : _b.tabs)
      })
    });
    const {
      renderPicker
    } = useMobilePicker({
      props,
      valueManager: singleItemValueManager,
      valueType: "date-time",
      getOpenDialogAriaText: ((_c = props.localeText) == null ? void 0 : _c.openDatePickerDialogue) ?? translations.openDatePickerDialogue,
      validator: validateDateTime
    });
    return renderPicker();
  });
  MobileDateTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default utils.is12HourCycleInCurrentLocale()
     */
    ampm: PropTypes.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default true on desktop, false on mobile
     */
    ampmInClock: PropTypes.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: PropTypes.bool,
    className: PropTypes.string,
    /**
     * If `true`, the popover or modal will close after submitting the full date.
     * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: PropTypes.bool,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {TDate} date The date of the day of week provided by the adapter.
     * @returns {string} The name to display.
     * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: PropTypes.func,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: PropTypes.object,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: PropTypes.bool,
    /**
     * If `true`, disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: PropTypes.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: PropTypes.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: PropTypes.bool,
    /**
     * If `true`, the open picker button will not be rendered (renders only the field).
     * @default false
     */
    disableOpenPicker: PropTypes.bool,
    /**
     * If `true`, disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: PropTypes.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: PropTypes.bool,
    /**
     * @default false
     */
    enableAccessibleFieldDOMStructure: PropTypes.any,
    /**
     * The day view will show as many weeks as needed after the end of the current month to match this value.
     * Put it to 6 to have a fixed number of weeks in Gregorian calendars
     */
    fixedWeekNumber: PropTypes.number,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: PropTypes.string,
    /**
     * Density of the format when rendered in the input.
     * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
     * @default "dense"
     */
    formatDensity: PropTypes.oneOf(["dense", "spacious"]),
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: refType,
    /**
     * The label content.
     */
    label: PropTypes.node,
    /**
     * If `true`, calls `renderLoading` instead of rendering the day calendar.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: PropTypes.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: PropTypes.object,
    /**
     * Maximal selectable date.
     * @default 2099-12-31
     */
    maxDate: PropTypes.object,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: PropTypes.object,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: PropTypes.object,
    /**
     * Minimal selectable date.
     * @default 1900-01-01
     */
    minDate: PropTypes.object,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: PropTypes.object,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: PropTypes.object,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: PropTypes.number,
    /**
     * Months rendered per row.
     * @default 3
     */
    monthsPerRow: PropTypes.oneOf([3, 4]),
    /**
     * Name attribute used by the `input` element in the Field.
     */
    name: PropTypes.string,
    /**
     * Callback fired when the value is accepted.
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TValue} value The value that was just accepted.
     * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
     */
    onAccept: PropTypes.func,
    /**
     * Callback fired when the value changes.
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
     */
    onChange: PropTypes.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see `open`).
     */
    onClose: PropTypes.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: PropTypes.func,
    /**
     * Callback fired on month change.
     * @template TDate
     * @param {TDate} month The new month.
     */
    onMonthChange: PropTypes.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see `open`).
     */
    onOpen: PropTypes.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: PropTypes.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: PropTypes.func,
    /**
     * Callback fired on year change.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: PropTypes.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: PropTypes.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: PropTypes.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
    /**
     * Force rendering in particular orientation.
     */
    orientation: PropTypes.oneOf(["landscape", "portrait"]),
    readOnly: PropTypes.bool,
    /**
     * If `true`, disable heavy animations.
     * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
     */
    reduceAnimations: PropTypes.bool,
    /**
     * The date used to generate the new value when both `value` and `defaultValue` are empty.
     * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
     */
    referenceDate: PropTypes.object,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: PropTypes.func,
    /**
     * The currently selected sections.
     * This prop accepts four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
     * 3. If `"all"` is provided, all the sections will be selected.
     * 4. If `null` is provided, no section will be selected.
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number]),
    /**
     * Disable specific date.
     *
     * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
     *
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: PropTypes.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true`, the month will be disabled.
     */
    shouldDisableMonth: PropTypes.func,
    /**
     * Disable specific time.
     * @template TDate
     * @param {TDate} value The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: PropTypes.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true`, the year will be disabled.
     */
    shouldDisableYear: PropTypes.func,
    /**
     * If `true`, days outside the current month are rendered:
     *
     * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
     *
     * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
     *
     * - ignored if `calendars` equals more than `1` on range pickers.
     * @default false
     */
    showDaysOutsideCurrentMonth: PropTypes.bool,
    /**
     * The props used for each component slot.
     * @default {}
     */
    slotProps: PropTypes.object,
    /**
     * Overridable component slots.
     * @default {}
     */
    slots: PropTypes.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
    /**
     * Choose which timezone to use for the value.
     * Example: "default", "system", "UTC", "America/New_York".
     * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
     * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
     * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
     */
    timezone: PropTypes.string,
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: PropTypes.object,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: PropTypes.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be used.
     */
    viewRenderers: PropTypes.shape({
      day: PropTypes.func,
      hours: PropTypes.func,
      minutes: PropTypes.func,
      month: PropTypes.func,
      seconds: PropTypes.func,
      year: PropTypes.func
    }),
    /**
     * Available views.
     */
    views: PropTypes.arrayOf(PropTypes.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
    /**
     * Years rendered per row.
     * @default 3
     */
    yearsPerRow: PropTypes.oneOf([3, 4])
  };
  const _excluded$3 = ["desktopModeMediaQuery"];
  const DateTimePicker = /* @__PURE__ */ reactExports.forwardRef(function DateTimePicker2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiDateTimePicker"
    });
    const {
      desktopModeMediaQuery = DEFAULT_DESKTOP_MODE_MEDIA_QUERY
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$3);
    const isDesktop = useMediaQuery(desktopModeMediaQuery, {
      defaultMatches: true
    });
    if (isDesktop) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DesktopDateTimePicker, _extends$1({
        ref
      }, other));
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MobileDateTimePicker, _extends$1({
      ref
    }, other));
  });
  function MacroDialogContent() {
    const {
      isMacroEnabled,
      setMacroEnabled,
      macroTime,
      setMacroTime,
      isGodMode,
      setGodMode
    } = getAppContext();
    return /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement("div", null, /* @__PURE__ */ React$1.createElement("span", null, "Enable macro:"), /* @__PURE__ */ React$1.createElement(
      Switch,
      {
        checked: isMacroEnabled,
        onChange: (e2) => setMacroEnabled(e2.target.checked)
      }
    )), /* @__PURE__ */ React$1.createElement("div", { style: { fontSize: "20px !improtant" } }, /* @__PURE__ */ React$1.createElement(
      DateTimePicker,
      {
        slotProps: {
          popper: { disablePortal: true },
          dialog: { disablePortal: true }
        },
        value: macroTime,
        onChange: setMacroTime
      }
    )), /* @__PURE__ */ React$1.createElement("div", null, /* @__PURE__ */ React$1.createElement("span", null, "Enable God Mode:"), /* @__PURE__ */ React$1.createElement(
      Switch,
      {
        checked: isGodMode,
        onChange: (e2) => setGodMode(e2.target.checked)
      }
    )));
  }
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
    const str = toString.call(thing);
    return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString = typeOfTest("string");
  const isFunction = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject(val) && isFunction(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l2;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l2 = obj.length; i < l2; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined")
      return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l2 = arguments.length; i < l2; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  const extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
    forEach(b2, (val, key) => {
      if (thisArg && isFunction(val)) {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null)
      return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position2) => {
    str = String(str);
    if (position2 === void 0 || position2 > str.length) {
      position2 = str.length;
    }
    position2 -= searchString.length;
    const lastIndex = str.indexOf(searchString, position2);
    return lastIndex !== -1 && lastIndex === position2;
  };
  const toArray = (thing) => {
    if (!thing)
      return null;
    if (isArray(thing))
      return thing;
    let i = thing.length;
    if (!isNumber(i))
      return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while ((result = iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction(value))
        return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter2) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
    return obj;
  };
  const noop = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  const ALPHA = "abcdefghijklmnopqrstuvwxyz";
  const DIGIT = "0123456789";
  const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str = "";
    const { length: length2 } = alphabet;
    while (size--) {
      str += alphabet[Math.random() * length2 | 0];
    }
    return str;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i) => {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit(value, i + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token2, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token2) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb2) => {
        callbacks.push(cb2);
        _global.postMessage(token2, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb2) => setTimeout(cb2);
  })(
    typeof setImmediate === "function",
    isFunction(_global.postMessage)
  );
  const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  const utils$1 = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap
  };
  function AxiosError(message, code, config2, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config2 && (this.config = config2);
    request && (this.request = request);
    response && (this.response = response);
  }
  utils$1.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  const prototype$1 = AxiosError.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error, code, config2, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$1.toFlatObject(error, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config2, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets(key) {
    return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path)
      return key;
    return path.concat(key).map(function each(token2, i) {
      token2 = removeBrackets(token2);
      return !dots && i ? "[" + token2 + "]" : token2;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options2) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options2 = utils$1.toFlatObject(options2, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options2.metaTokens;
    const visitor = options2.visitor || defaultVisitor;
    const dots = options2.dots;
    const indexes = options2.indexes;
    const _Blob = options2.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils$1.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$1.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el2, index) {
            !(utils$1.isUndefined(el2) || el2 === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
              convertValue(el2)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils$1.isUndefined(value))
        return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils$1.forEach(value, function each(el2, key) {
        const result = !(utils$1.isUndefined(el2) || el2 === null) && visitor.call(
          formData,
          el2,
          utils$1.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el2, path ? path.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
      return charMap[match2];
    });
  }
  function AxiosURLSearchParams(params, options2) {
    this._pairs = [];
    params && toFormData(params, this, options2);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append2(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options2) {
    if (!params) {
      return url;
    }
    const _encode = options2 && options2.encode || encode;
    const serializeFn = options2 && options2.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options2);
    } else {
      serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options2).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options2) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options2 ? options2.synchronous : false,
        runWhen: options2 ? options2.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id2) {
      if (this.handlers[id2]) {
        this.handlers[id2] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    }
  }
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  const platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const hasStandardBrowserEnv = ((product) => {
    return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
  })(typeof navigator !== "undefined" && navigator.product);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    origin
  }, Symbol.toStringTag, { value: "Module" }));
  const platform = {
    ...utils,
    ...platform$1
  };
  function toURLEncodedForm(data, options2) {
    return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path, helpers) {
        if (platform.isNode && utils$1.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options2));
  }
  function parsePropPath(name) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
      return match2[0] === "[]" ? "" : match2[1] || match2[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      if (name === "__proto__")
        return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils$1.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$1.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils$1.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};
      utils$1.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e2) {
        if (e2.name !== "SyntaxError") {
          throw e2;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$1.isObject(data);
      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$1.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e2) {
          if (strictJSONParsing) {
            if (e2.name === "SyntaxError") {
              throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e2;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  const ignoreDuplicateOf = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
      i = line2.indexOf(":");
      key = line2.substring(0, i).trim().toLowerCase();
      val = line2.substring(i + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match2;
    while (match2 = tokensRE.exec(str)) {
      tokens[match2[1]] = match2[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$1.isFunction(filter)) {
      return filter.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$1.isString(value))
      return;
    if (utils$1.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }
    if (utils$1.isRegExp(filter)) {
      return filter.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
      return char2.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$1.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils$1.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else if (utils$1.isHeaders(header)) {
        for (const [key, value] of header.entries()) {
          setHeader(value, key, rewrite);
        }
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils$1.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils$1.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length;
      let deleted = false;
      while (i--) {
        const key = keys[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils$1.forEach(this, (value, header) => {
        const key = utils$1.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$1.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$1.freezeMethods(AxiosHeaders);
  function transformData(fns, response) {
    const config2 = this || defaults;
    const context = response || config2;
    const headers = AxiosHeaders.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function transform(fn) {
      data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError(message, config2, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
    this.name = "CanceledError";
  }
  utils$1.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function parseProtocol(url) {
    const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match2 && match2[1] || "";
  }
  function speedometer(samplesCount, min2) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min2 = min2 !== void 0 ? min2 : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min2) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle(fn, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn.apply(null, args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle((e2) => {
      const loaded = e2.loaded;
      const total = e2.lengthComputable ? e2.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e2,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
  const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url) {
        let href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  const cookies = platform.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure) {
        const cookie = [name + "=" + encodeURIComponent(value)];
        utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils$1.isString(path) && cookie.push("path=" + path);
        utils$1.isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name) {
        const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match2 ? decodeURIComponent(match2[3]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config3 = {};
    function getMergedValue(target, source, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b2, caseless) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(a, b2, caseless);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a, caseless);
      }
    }
    function valueFromConfig2(a, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      }
    }
    function defaultToConfig2(a, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b2, prop) {
      if (prop in config2) {
        return getMergedValue(a, b2);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b2) => mergeDeepProperties(headersToObject(a), headersToObject(b2), true)
    };
    utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
    });
    return config3;
  }
  const resolveConfig = (config2) => {
    const newConfig = mergeConfig({}, config2);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config2.params, config2.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    let contentType;
    if (utils$1.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
        headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config2) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig(config2);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config2,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config2,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils$1.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout) => {
    let controller = new AbortController();
    let aborted;
    const onabort = function(cancel) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = cancel instanceof Error ? cancel : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = unsubscribe;
    return [signal, () => {
      timer && clearTimeout(timer);
      timer = null;
    }];
  };
  const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (!chunkSize || len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end2;
    while (pos < len) {
      end2 = pos + chunkSize;
      yield chunk.slice(pos, end2);
      pos = end2;
    }
  };
  const readBytes = async function* (iterable, chunkSize, encode2) {
    for await (const chunk of iterable) {
      yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode2(String(chunk)), chunkSize);
    }
  };
  const trackStream = (stream, chunkSize, onProgress, onFinish, encode2) => {
    const iterator = readBytes(stream, chunkSize, encode2);
    let bytes = 0;
    let done;
    let _onFinish = (e2) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e2);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
  const test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e2) {
      return false;
    }
  };
  const supportsRequestStream = isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config2) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config2);
      });
    });
  })(new Response());
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      return (await new Request(body).arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$1.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length2 = utils$1.toFiniteNumber(headers.getContentLength());
    return length2 == null ? getBodyLength(body) : length2;
  };
  const fetchAdapter = isFetchSupported && (async (config2) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config2);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals([signal, cancelToken], timeout) : [];
    let finished, request;
    const onFinish = () => {
      !finished && setTimeout(() => {
        composedSignal && composedSignal.unsubscribe();
      });
      finished = true;
    };
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush, encodeText);
        }
      }
      if (!utils$1.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      request = new Request(url, {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: withCredentials
      });
      let response = await fetch(request);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
        const options2 = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options2[prop] = response[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            isStreamResponse && onFinish();
          }, encodeText),
          options2
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
      !isStreamResponse && onFinish();
      stopTimeout && stopTimeout();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config: config2,
          request
        });
      });
    } catch (err) {
      onFinish();
      if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError.from(err, err && err.code, config2, request);
    }
  });
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
  };
  utils$1.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e2) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
  const adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length: length2 } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length2; i++) {
        nameOrAdapter = adapters2[i];
        let id2;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError(`Unknown adapter '${id2}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id2 || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config2) {
    if (config2.cancelToken) {
      config2.cancelToken.throwIfRequested();
    }
    if (config2.signal && config2.signal.aborted) {
      throw new CanceledError(null, config2);
    }
  }
  function dispatchRequest(config2) {
    throwIfCancellationRequested(config2);
    config2.headers = AxiosHeaders.from(config2.headers);
    config2.data = transformData.call(
      config2,
      config2.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
      config2.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config2.adapter || defaults.adapter);
    return adapter(config2).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config2);
      response.data = transformData.call(
        config2,
        config2.transformResponse,
        response
      );
      response.headers = AxiosHeaders.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config2);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config2,
            config2.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const VERSION = "1.7.3";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options2, schema, allowUnknown) {
    if (typeof options2 !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options2);
    let i = keys.length;
    while (i-- > 0) {
      const opt = keys[i];
      const validator2 = schema[opt];
      if (validator2) {
        const value = options2[opt];
        const result = value === void 0 || validator2(value, opt, options2);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  const validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config2) {
      try {
        return await this._request(configOrUrl, config2);
      } catch (err) {
        if (err instanceof Error) {
          let dummy;
          Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          } catch (e2) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig(this.defaults, config2);
      const { transitional, paramsSerializer, headers } = config2;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config2.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$1.merge(
        headers.common,
        headers[config2.method]
      );
      headers && utils$1.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config2.headers = AxiosHeaders.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config2);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config2;
      i = 0;
      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config2) {
      config2 = mergeConfig(this.defaults, config2);
      const fullPath = buildFullPath(config2.baseURL, config2.url);
      return buildURL(fullPath, config2.params, config2.paramsSerializer);
    }
  }
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        url,
        data: (config2 || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token2 = this;
      this.promise.then((cancel) => {
        if (!token2._listeners)
          return;
        let i = token2._listeners.length;
        while (i-- > 0) {
          token2._listeners[i](cancel);
        }
        token2._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token2.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token2.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config2, request) {
        if (token2.reason) {
          return;
        }
        token2.reason = new CanceledError(message, config2, request);
        resolvePromise(token2.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token2 = new CancelToken(function executor(c2) {
        cancel = c2;
      });
      return {
        token: token2,
        cancel
      };
    }
  }
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  function createInstance(defaultConfig) {
    const context = new Axios(defaultConfig);
    const instance = bind(Axios.prototype.request, context);
    utils$1.extend(instance, Axios.prototype, context, { allOwnKeys: true });
    utils$1.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults);
  axios.Axios = Axios;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders;
  axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode;
  axios.default = axios;
  function Macro() {
    const { isMacroEnabled, macroTime } = getAppContext();
    const [time, setTime] = reactExports.useState(-1);
    const book = reactExports.useCallback(async () => {
      var _a;
      const result = [...document.getElementsByClassName("selected")].map((el2) => el2.children[0].innerHTML).join("|");
      console.log(result);
      const params = (_a = document.getElementById("params")) == null ? void 0 : _a.value;
      console.log(
        `https://reboks.nus.edu.sg/nus_public_web/public/facilities/group_booking?table_exclusive_length=10&add_cart=Add+to+shopping+cart&result=${result}&params=${params}`
      );
      try {
        const data = await axios.get(
          `https://reboks.nus.edu.sg/nus_public_web/public/facilities/group_booking?table_exclusive_length=10&add_cart=Add+to+shopping+cart&result=${result}&params=${params}`
        );
        console.log(data);
      } catch (error) {
        console.error(error);
      }
    }, [document, axios]);
    const updateTime = reactExports.useCallback(async () => {
      var _a;
      const data = await axios.get(
        "https://reboks.nus.edu.sg/nus_public_web/public/facilities/group_booking"
      );
      var el2 = document.createElement("html");
      el2.innerHTML = data.data;
      setTime(
        parseInt(
          ((_a = el2.getElementsByClassName("system-clock-label")[0]) == null ? void 0 : _a.children[0].getAttribute("data-time")) ?? "-1"
        )
      );
    }, [axios]);
    reactExports.useEffect(() => {
      console.log("Timing delta: " + (time - Date.now() / 1e3));
      if (!isMacroEnabled)
        return;
      if (macroTime) {
        console.log(macroTime.unix() - time);
        const id2 = setTimeout(() => {
          setTimeout(book, 300);
          setTimeout(book, 500);
          setTimeout(book, 700);
          console.log("Pushed updates");
        }, (macroTime.unix() - time) * 1e3 - 500);
        return () => clearTimeout(id2);
      }
    }, [time]);
    reactExports.useEffect(() => {
      updateTime();
    }, [isMacroEnabled, macroTime]);
    return null;
  }
  var dayjs_min = { exports: {} };
  (function(module, exports) {
    !function(t2, e2) {
      module.exports = e2();
    }(commonjsGlobal, function() {
      var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s = "minute", u2 = "hour", a = "day", o = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
        var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
        return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
      } }, m2 = function(t3, e3, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
      }, v2 = { s: m2, z: function(t3) {
        var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
        return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i2, 2, "0");
      }, m: function t3(e3, n3) {
        if (e3.date() < n3.date())
          return -t3(n3, e3);
        var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r3, c2), s2 = n3 - i2 < 0, u3 = e3.clone().add(r3 + (s2 ? -1 : 1), c2);
        return +(-(r3 + (n3 - i2) / (s2 ? i2 - u3 : u3 - i2)) || 0);
      }, a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(t3) {
        return { M: c2, y: h2, w: o, d: a, D: d2, h: u2, m: s, s: i, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return void 0 === t3;
      } }, g2 = "en", D2 = {};
      D2[g2] = M2;
      var p2 = "$isDayjsObject", S2 = function(t3) {
        return t3 instanceof _2 || !(!t3 || !t3[p2]);
      }, w2 = function t3(e3, n3, r3) {
        var i2;
        if (!e3)
          return g2;
        if ("string" == typeof e3) {
          var s2 = e3.toLowerCase();
          D2[s2] && (i2 = s2), n3 && (D2[s2] = n3, i2 = s2);
          var u3 = e3.split("-");
          if (!i2 && u3.length > 1)
            return t3(u3[0]);
        } else {
          var a2 = e3.name;
          D2[a2] = e3, i2 = a2;
        }
        return !r3 && i2 && (g2 = i2), i2 || !r3 && g2;
      }, O2 = function(t3, e3) {
        if (S2(t3))
          return t3.clone();
        var n3 = "object" == typeof e3 ? e3 : {};
        return n3.date = t3, n3.args = arguments, new _2(n3);
      }, b2 = v2;
      b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
        return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
      };
      var _2 = function() {
        function M3(t3) {
          this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
        }
        var m3 = M3.prototype;
        return m3.parse = function(t3) {
          this.$d = function(t4) {
            var e3 = t4.date, n3 = t4.utc;
            if (null === e3)
              return /* @__PURE__ */ new Date(NaN);
            if (b2.u(e3))
              return /* @__PURE__ */ new Date();
            if (e3 instanceof Date)
              return new Date(e3);
            if ("string" == typeof e3 && !/Z$/i.test(e3)) {
              var r3 = e3.match($2);
              if (r3) {
                var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
              }
            }
            return new Date(e3);
          }(t3), this.init();
        }, m3.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m3.$utils = function() {
          return b2;
        }, m3.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m3.isSame = function(t3, e3) {
          var n3 = O2(t3);
          return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
        }, m3.isAfter = function(t3, e3) {
          return O2(t3) < this.startOf(e3);
        }, m3.isBefore = function(t3, e3) {
          return this.endOf(e3) < O2(t3);
        }, m3.$g = function(t3, e3, n3) {
          return b2.u(t3) ? this[e3] : this.set(n3, t3);
        }, m3.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m3.valueOf = function() {
          return this.$d.getTime();
        }, m3.startOf = function(t3, e3) {
          var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
            var i2 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
            return r3 ? i2 : i2.endOf(a);
          }, $3 = function(t4, e4) {
            return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
          }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
          switch (f3) {
            case h2:
              return r3 ? l3(1, 0) : l3(31, 11);
            case c2:
              return r3 ? l3(1, M4) : l3(0, M4 + 1);
            case o:
              var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
              return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
            case a:
            case d2:
              return $3(v3 + "Hours", 0);
            case u2:
              return $3(v3 + "Minutes", 1);
            case s:
              return $3(v3 + "Seconds", 2);
            case i:
              return $3(v3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m3.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m3.$set = function(t3, e3) {
          var n3, o2 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s] = f3 + "Minutes", n3[i] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o2], $3 = o2 === a ? this.$D + (e3 - this.$W) : e3;
          if (o2 === c2 || o2 === h2) {
            var y3 = this.clone().set(d2, 1);
            y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
          } else
            l3 && this.$d[l3]($3);
          return this.init(), this;
        }, m3.set = function(t3, e3) {
          return this.clone().$set(t3, e3);
        }, m3.get = function(t3) {
          return this[b2.p(t3)]();
        }, m3.add = function(r3, f3) {
          var d3, l3 = this;
          r3 = Number(r3);
          var $3 = b2.p(f3), y3 = function(t3) {
            var e3 = O2(l3);
            return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
          };
          if ($3 === c2)
            return this.set(c2, this.$M + r3);
          if ($3 === h2)
            return this.set(h2, this.$y + r3);
          if ($3 === a)
            return y3(1);
          if ($3 === o)
            return y3(7);
          var M4 = (d3 = {}, d3[s] = e2, d3[u2] = n2, d3[i] = t2, d3)[$3] || 1, m4 = this.$d.getTime() + r3 * M4;
          return b2.w(m4, this);
        }, m3.subtract = function(t3, e3) {
          return this.add(-1 * t3, e3);
        }, m3.format = function(t3) {
          var e3 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || l2;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b2.z(this), s2 = this.$H, u3 = this.$m, a2 = this.$M, o2 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i3, s3) {
            return t4 && (t4[n4] || t4(e3, r3)) || i3[n4].slice(0, s3);
          }, d3 = function(t4) {
            return b2.s(s2 % 12 || 12, t4, "0");
          }, $3 = f3 || function(t4, e4, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y2, function(t4, r4) {
            return r4 || function(t5) {
              switch (t5) {
                case "YY":
                  return String(e3.$y).slice(-2);
                case "YYYY":
                  return b2.s(e3.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b2.s(a2 + 1, 2, "0");
                case "MMM":
                  return h3(n3.monthsShort, a2, c3, 3);
                case "MMMM":
                  return h3(c3, a2);
                case "D":
                  return e3.$D;
                case "DD":
                  return b2.s(e3.$D, 2, "0");
                case "d":
                  return String(e3.$W);
                case "dd":
                  return h3(n3.weekdaysMin, e3.$W, o2, 2);
                case "ddd":
                  return h3(n3.weekdaysShort, e3.$W, o2, 3);
                case "dddd":
                  return o2[e3.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b2.s(s2, 2, "0");
                case "h":
                  return d3(1);
                case "hh":
                  return d3(2);
                case "a":
                  return $3(s2, u3, true);
                case "A":
                  return $3(s2, u3, false);
                case "m":
                  return String(u3);
                case "mm":
                  return b2.s(u3, 2, "0");
                case "s":
                  return String(e3.$s);
                case "ss":
                  return b2.s(e3.$s, 2, "0");
                case "SSS":
                  return b2.s(e3.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t4) || i2.replace(":", "");
          });
        }, m3.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m3.diff = function(r3, d3, l3) {
          var $3, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
            return b2.m(y3, m4);
          };
          switch (M4) {
            case h2:
              $3 = D3() / 12;
              break;
            case c2:
              $3 = D3();
              break;
            case f2:
              $3 = D3() / 3;
              break;
            case o:
              $3 = (g3 - v3) / 6048e5;
              break;
            case a:
              $3 = (g3 - v3) / 864e5;
              break;
            case u2:
              $3 = g3 / n2;
              break;
            case s:
              $3 = g3 / e2;
              break;
            case i:
              $3 = g3 / t2;
              break;
            default:
              $3 = g3;
          }
          return l3 ? $3 : b2.a($3);
        }, m3.daysInMonth = function() {
          return this.endOf(c2).$D;
        }, m3.$locale = function() {
          return D2[this.$L];
        }, m3.locale = function(t3, e3) {
          if (!t3)
            return this.$L;
          var n3 = this.clone(), r3 = w2(t3, e3, true);
          return r3 && (n3.$L = r3), n3;
        }, m3.clone = function() {
          return b2.w(this.$d, this);
        }, m3.toDate = function() {
          return new Date(this.valueOf());
        }, m3.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m3.toISOString = function() {
          return this.$d.toISOString();
        }, m3.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), k2 = _2.prototype;
      return O2.prototype = k2, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u2], ["$W", a], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
        k2[t3[1]] = function(e3) {
          return this.$g(e3, t3[0], t3[1]);
        };
      }), O2.extend = function(t3, e3) {
        return t3.$i || (t3(e3, _2, O2), t3.$i = true), O2;
      }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
        return O2(1e3 * t3);
      }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
    });
  })(dayjs_min);
  var dayjs_minExports = dayjs_min.exports;
  const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
  const useTimeField = (inProps) => {
    const props = useDefaultizedTimeField(inProps);
    const {
      forwardedProps,
      internalProps
    } = splitFieldInternalAndForwardedProps(props, "time");
    return useField({
      forwardedProps,
      internalProps,
      valueManager: singleItemValueManager,
      fieldValueManager: singleItemFieldValueManager,
      validator: validateTime,
      valueType: "time"
    });
  };
  const _excluded$2 = ["slots", "slotProps", "InputProps", "inputProps"];
  const TimeField = /* @__PURE__ */ reactExports.forwardRef(function TimeField2(inProps, inRef) {
    const themeProps = useThemeProps({
      props: inProps,
      name: "MuiTimeField"
    });
    const {
      slots,
      slotProps,
      InputProps,
      inputProps
    } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded$2);
    const ownerState = themeProps;
    const TextField$1 = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField);
    const textFieldProps = useSlotProps({
      elementType: TextField$1,
      externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
      externalForwardedProps: other,
      ownerState,
      additionalProps: {
        ref: inRef
      }
    });
    textFieldProps.inputProps = _extends$1({}, inputProps, textFieldProps.inputProps);
    textFieldProps.InputProps = _extends$1({}, InputProps, textFieldProps.InputProps);
    const fieldResponse = useTimeField(textFieldProps);
    const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
    const processedFieldProps = useClearableField(_extends$1({}, convertedFieldResponse, {
      slots,
      slotProps
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, _extends$1({}, processedFieldProps));
  });
  function getTimePickerToolbarUtilityClass(slot) {
    return generateUtilityClass("MuiTimePickerToolbar", slot);
  }
  const timePickerToolbarClasses = generateUtilityClasses("MuiTimePickerToolbar", ["root", "separator", "hourMinuteLabel", "hourMinuteLabelLandscape", "hourMinuteLabelReverse", "ampmSelection", "ampmLandscape", "ampmLabel"]);
  const _excluded$1 = ["ampm", "ampmInClock", "value", "isLandscape", "onChange", "view", "onViewChange", "views", "disabled", "readOnly", "className"];
  const useUtilityClasses = (ownerState) => {
    const {
      isLandscape,
      classes,
      isRtl
    } = ownerState;
    const slots = {
      root: ["root"],
      separator: ["separator"],
      hourMinuteLabel: ["hourMinuteLabel", isLandscape && "hourMinuteLabelLandscape", isRtl && "hourMinuteLabelReverse"],
      ampmSelection: ["ampmSelection", isLandscape && "ampmLandscape"],
      ampmLabel: ["ampmLabel"]
    };
    return composeClasses(slots, getTimePickerToolbarUtilityClass, classes);
  };
  const TimePickerToolbarRoot = styled(PickersToolbar, {
    name: "MuiTimePickerToolbar",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const TimePickerToolbarSeparator = styled(PickersToolbarText, {
    name: "MuiTimePickerToolbar",
    slot: "Separator",
    overridesResolver: (props, styles2) => styles2.separator
  })({
    outline: 0,
    margin: "0 4px 0 2px",
    cursor: "default"
  });
  const TimePickerToolbarHourMinuteLabel = styled("div", {
    name: "MuiTimePickerToolbar",
    slot: "HourMinuteLabel",
    overridesResolver: (props, styles2) => [{
      [`&.${timePickerToolbarClasses.hourMinuteLabelLandscape}`]: styles2.hourMinuteLabelLandscape,
      [`&.${timePickerToolbarClasses.hourMinuteLabelReverse}`]: styles2.hourMinuteLabelReverse
    }, styles2.hourMinuteLabel]
  })({
    display: "flex",
    justifyContent: "flex-end",
    alignItems: "flex-end",
    variants: [{
      props: {
        isRtl: true
      },
      style: {
        flexDirection: "row-reverse"
      }
    }, {
      props: {
        isLandscape: true
      },
      style: {
        marginTop: "auto"
      }
    }]
  });
  const TimePickerToolbarAmPmSelection = styled("div", {
    name: "MuiTimePickerToolbar",
    slot: "AmPmSelection",
    overridesResolver: (props, styles2) => [{
      [`.${timePickerToolbarClasses.ampmLabel}`]: styles2.ampmLabel
    }, {
      [`&.${timePickerToolbarClasses.ampmLandscape}`]: styles2.ampmLandscape
    }, styles2.ampmSelection]
  })({
    display: "flex",
    flexDirection: "column",
    marginRight: "auto",
    marginLeft: 12,
    [`& .${timePickerToolbarClasses.ampmLabel}`]: {
      fontSize: 17
    },
    variants: [{
      props: {
        isLandscape: true
      },
      style: {
        margin: "4px 0 auto",
        flexDirection: "row",
        justifyContent: "space-around",
        flexBasis: "100%"
      }
    }]
  });
  function TimePickerToolbar(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiTimePickerToolbar"
    });
    const {
      ampm,
      ampmInClock,
      value,
      isLandscape,
      onChange,
      view,
      onViewChange,
      views,
      disabled,
      readOnly,
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1);
    const utils2 = useUtils();
    const translations = usePickersTranslations();
    const isRtl = useRtl();
    const showAmPmControl = Boolean(ampm && !ampmInClock && views.includes("hours"));
    const {
      meridiemMode,
      handleMeridiemChange
    } = useMeridiemMode(value, ampm, onChange);
    const formatHours = (time) => ampm ? utils2.format(time, "hours12h") : utils2.format(time, "hours24h");
    const ownerState = _extends$1({}, props, {
      isRtl
    });
    const classes = useUtilityClasses(ownerState);
    const separator = /* @__PURE__ */ jsxRuntimeExports.jsx(TimePickerToolbarSeparator, {
      tabIndex: -1,
      value: ":",
      variant: "h3",
      selected: false,
      className: classes.separator
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarRoot, _extends$1({
      landscapeDirection: "row",
      toolbarTitle: translations.timePickerToolbarTitle,
      isLandscape,
      ownerState,
      className: clsx(classes.root, className)
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarHourMinuteLabel, {
        className: classes.hourMinuteLabel,
        ownerState,
        children: [arrayIncludes(views, "hours") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
          tabIndex: -1,
          variant: "h3",
          onClick: () => onViewChange("hours"),
          selected: view === "hours",
          value: value ? formatHours(value) : "--"
        }), arrayIncludes(views, ["hours", "minutes"]) && separator, arrayIncludes(views, "minutes") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
          tabIndex: -1,
          variant: "h3",
          onClick: () => onViewChange("minutes"),
          selected: view === "minutes",
          value: value ? utils2.format(value, "minutes") : "--"
        }), arrayIncludes(views, ["minutes", "seconds"]) && separator, arrayIncludes(views, "seconds") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
          variant: "h3",
          onClick: () => onViewChange("seconds"),
          selected: view === "seconds",
          value: value ? utils2.format(value, "seconds") : "--"
        })]
      }), showAmPmControl && /* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarAmPmSelection, {
        className: classes.ampmSelection,
        ownerState,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
          disableRipple: true,
          variant: "subtitle2",
          selected: meridiemMode === "am",
          typographyClassName: classes.ampmLabel,
          value: formatMeridiem(utils2, "am"),
          onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
          disabled
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
          disableRipple: true,
          variant: "subtitle2",
          selected: meridiemMode === "pm",
          typographyClassName: classes.ampmLabel,
          value: formatMeridiem(utils2, "pm"),
          onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
          disabled
        })]
      })]
    }));
  }
  function useTimePickerDefaultizedProps(props, name) {
    var _a;
    const utils2 = useUtils();
    const themeProps = useThemeProps({
      props,
      name
    });
    const ampm = themeProps.ampm ?? utils2.is12HourCycleInCurrentLocale();
    const localeText = reactExports.useMemo(() => {
      var _a2;
      if (((_a2 = themeProps.localeText) == null ? void 0 : _a2.toolbarTitle) == null) {
        return themeProps.localeText;
      }
      return _extends$1({}, themeProps.localeText, {
        timePickerToolbarTitle: themeProps.localeText.toolbarTitle
      });
    }, [themeProps.localeText]);
    return _extends$1({}, themeProps, {
      ampm,
      localeText
    }, applyDefaultViewProps({
      views: themeProps.views,
      openTo: themeProps.openTo,
      defaultViews: ["hours", "minutes"],
      defaultOpenTo: "hours"
    }), {
      disableFuture: themeProps.disableFuture ?? false,
      disablePast: themeProps.disablePast ?? false,
      slots: _extends$1({
        toolbar: TimePickerToolbar
      }, themeProps.slots),
      slotProps: _extends$1({}, themeProps.slotProps, {
        toolbar: _extends$1({
          ampm,
          ampmInClock: themeProps.ampmInClock
        }, (_a = themeProps.slotProps) == null ? void 0 : _a.toolbar)
      })
    });
  }
  const DesktopTimePicker = /* @__PURE__ */ reactExports.forwardRef(function DesktopTimePicker2(inProps, ref) {
    var _a, _b, _c, _d;
    const translations = usePickersTranslations();
    const utils2 = useUtils();
    const defaultizedProps = useTimePickerDefaultizedProps(inProps, "MuiDesktopTimePicker");
    const {
      shouldRenderTimeInASingleColumn,
      views: resolvedViews,
      timeSteps
    } = resolveTimeViewsResponse(defaultizedProps);
    const renderTimeView = shouldRenderTimeInASingleColumn ? renderDigitalClockTimeView : renderMultiSectionDigitalClockTimeView;
    const viewRenderers = _extends$1({
      hours: renderTimeView,
      minutes: renderTimeView,
      seconds: renderTimeView,
      meridiem: renderTimeView
    }, defaultizedProps.viewRenderers);
    const ampmInClock = defaultizedProps.ampmInClock ?? true;
    const actionBarActions = shouldRenderTimeInASingleColumn ? [] : ["accept"];
    const shouldHoursRendererContainMeridiemView = ((_a = viewRenderers.hours) == null ? void 0 : _a.name) === renderMultiSectionDigitalClockTimeView.name;
    const views = !shouldHoursRendererContainMeridiemView ? resolvedViews.filter((view) => view !== "meridiem") : resolvedViews;
    const props = _extends$1({}, defaultizedProps, {
      ampmInClock,
      timeSteps,
      viewRenderers,
      format: resolveTimeFormat(utils2, defaultizedProps),
      // Setting only `hours` time view in case of single column time picker
      // Allows for easy view lifecycle management
      views: shouldRenderTimeInASingleColumn ? ["hours"] : views,
      slots: _extends$1({
        field: TimeField,
        openPickerIcon: ClockIcon
      }, defaultizedProps.slots),
      slotProps: _extends$1({}, defaultizedProps.slotProps, {
        field: (ownerState) => {
          var _a2;
          return _extends$1({}, resolveComponentProps((_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.field, ownerState), extractValidationProps(defaultizedProps), {
            ref
          });
        },
        toolbar: _extends$1({
          hidden: true,
          ampmInClock
        }, (_b = defaultizedProps.slotProps) == null ? void 0 : _b.toolbar),
        actionBar: _extends$1({
          actions: actionBarActions
        }, (_c = defaultizedProps.slotProps) == null ? void 0 : _c.actionBar)
      })
    });
    const {
      renderPicker
    } = useDesktopPicker({
      props,
      valueManager: singleItemValueManager,
      valueType: "time",
      getOpenDialogAriaText: ((_d = props.localeText) == null ? void 0 : _d.openTimePickerDialogue) ?? translations.openTimePickerDialogue,
      validator: validateTime
    });
    return renderPicker();
  });
  DesktopTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default utils.is12HourCycleInCurrentLocale()
     */
    ampm: PropTypes.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default true on desktop, false on mobile
     */
    ampmInClock: PropTypes.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: PropTypes.bool,
    className: PropTypes.string,
    /**
     * If `true`, the popover or modal will close after submitting the full date.
     * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: PropTypes.bool,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: PropTypes.object,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: PropTypes.bool,
    /**
     * If `true`, disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: PropTypes.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: PropTypes.bool,
    /**
     * If `true`, the open picker button will not be rendered (renders only the field).
     * @default false
     */
    disableOpenPicker: PropTypes.bool,
    /**
     * If `true`, disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: PropTypes.bool,
    /**
     * @default false
     */
    enableAccessibleFieldDOMStructure: PropTypes.any,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: PropTypes.string,
    /**
     * Density of the format when rendered in the input.
     * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
     * @default "dense"
     */
    formatDensity: PropTypes.oneOf(["dense", "spacious"]),
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: refType,
    /**
     * The label content.
     */
    label: PropTypes.node,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: PropTypes.object,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: PropTypes.object,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: PropTypes.object,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: PropTypes.number,
    /**
     * Name attribute used by the `input` element in the Field.
     */
    name: PropTypes.string,
    /**
     * Callback fired when the value is accepted.
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TValue} value The value that was just accepted.
     * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
     */
    onAccept: PropTypes.func,
    /**
     * Callback fired when the value changes.
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
     */
    onChange: PropTypes.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see `open`).
     */
    onClose: PropTypes.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: PropTypes.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see `open`).
     */
    onOpen: PropTypes.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: PropTypes.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: PropTypes.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: PropTypes.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: PropTypes.oneOf(["hours", "meridiem", "minutes", "seconds"]),
    /**
     * Force rendering in particular orientation.
     */
    orientation: PropTypes.oneOf(["landscape", "portrait"]),
    readOnly: PropTypes.bool,
    /**
     * If `true`, disable heavy animations.
     * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
     */
    reduceAnimations: PropTypes.bool,
    /**
     * The date used to generate the new value when both `value` and `defaultValue` are empty.
     * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
     */
    referenceDate: PropTypes.object,
    /**
     * The currently selected sections.
     * This prop accepts four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
     * 3. If `"all"` is provided, all the sections will be selected.
     * 4. If `null` is provided, no section will be selected.
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number]),
    /**
     * Disable specific time.
     * @template TDate
     * @param {TDate} value The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: PropTypes.func,
    /**
     * If `true`, disabled digital clock items will not be rendered.
     * @default false
     */
    skipDisabled: PropTypes.bool,
    /**
     * The props used for each component slot.
     * @default {}
     */
    slotProps: PropTypes.object,
    /**
     * Overridable component slots.
     * @default {}
     */
    slots: PropTypes.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
    /**
     * Amount of time options below or at which the single column time renderer is used.
     * @default 24
     */
    thresholdToRenderTimeInASingleColumn: PropTypes.number,
    /**
     * The time steps between two time unit options.
     * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
     * When single column time renderer is used, only `timeStep.minutes` will be used.
     * @default{ hours: 1, minutes: 5, seconds: 5 }
     */
    timeSteps: PropTypes.shape({
      hours: PropTypes.number,
      minutes: PropTypes.number,
      seconds: PropTypes.number
    }),
    /**
     * Choose which timezone to use for the value.
     * Example: "default", "system", "UTC", "America/New_York".
     * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
     * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
     * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
     */
    timezone: PropTypes.string,
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: PropTypes.object,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: PropTypes.oneOf(["hours", "meridiem", "minutes", "seconds"]),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be used.
     */
    viewRenderers: PropTypes.shape({
      hours: PropTypes.func,
      meridiem: PropTypes.func,
      minutes: PropTypes.func,
      seconds: PropTypes.func
    }),
    /**
     * Available views.
     */
    views: PropTypes.arrayOf(PropTypes.oneOf(["hours", "minutes", "seconds"]).isRequired)
  };
  const MobileTimePicker = /* @__PURE__ */ reactExports.forwardRef(function MobileTimePicker2(inProps, ref) {
    var _a, _b;
    const translations = usePickersTranslations();
    const utils2 = useUtils();
    const defaultizedProps = useTimePickerDefaultizedProps(inProps, "MuiMobileTimePicker");
    const viewRenderers = _extends$1({
      hours: renderTimeViewClock,
      minutes: renderTimeViewClock,
      seconds: renderTimeViewClock
    }, defaultizedProps.viewRenderers);
    const ampmInClock = defaultizedProps.ampmInClock ?? false;
    const props = _extends$1({}, defaultizedProps, {
      ampmInClock,
      viewRenderers,
      format: resolveTimeFormat(utils2, defaultizedProps),
      slots: _extends$1({
        field: TimeField
      }, defaultizedProps.slots),
      slotProps: _extends$1({}, defaultizedProps.slotProps, {
        field: (ownerState) => {
          var _a2;
          return _extends$1({}, resolveComponentProps((_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.field, ownerState), extractValidationProps(defaultizedProps), {
            ref
          });
        },
        toolbar: _extends$1({
          hidden: false,
          ampmInClock
        }, (_a = defaultizedProps.slotProps) == null ? void 0 : _a.toolbar)
      })
    });
    const {
      renderPicker
    } = useMobilePicker({
      props,
      valueManager: singleItemValueManager,
      valueType: "time",
      getOpenDialogAriaText: ((_b = props.localeText) == null ? void 0 : _b.openTimePickerDialogue) ?? translations.openTimePickerDialogue,
      validator: validateTime
    });
    return renderPicker();
  });
  MobileTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default utils.is12HourCycleInCurrentLocale()
     */
    ampm: PropTypes.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default true on desktop, false on mobile
     */
    ampmInClock: PropTypes.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: PropTypes.bool,
    className: PropTypes.string,
    /**
     * If `true`, the popover or modal will close after submitting the full date.
     * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: PropTypes.bool,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: PropTypes.object,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: PropTypes.bool,
    /**
     * If `true`, disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: PropTypes.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: PropTypes.bool,
    /**
     * If `true`, the open picker button will not be rendered (renders only the field).
     * @default false
     */
    disableOpenPicker: PropTypes.bool,
    /**
     * If `true`, disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: PropTypes.bool,
    /**
     * @default false
     */
    enableAccessibleFieldDOMStructure: PropTypes.any,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: PropTypes.string,
    /**
     * Density of the format when rendered in the input.
     * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
     * @default "dense"
     */
    formatDensity: PropTypes.oneOf(["dense", "spacious"]),
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: refType,
    /**
     * The label content.
     */
    label: PropTypes.node,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: PropTypes.object,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: PropTypes.object,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: PropTypes.object,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: PropTypes.number,
    /**
     * Name attribute used by the `input` element in the Field.
     */
    name: PropTypes.string,
    /**
     * Callback fired when the value is accepted.
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TValue} value The value that was just accepted.
     * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
     */
    onAccept: PropTypes.func,
    /**
     * Callback fired when the value changes.
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
     */
    onChange: PropTypes.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see `open`).
     */
    onClose: PropTypes.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
     * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: PropTypes.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see `open`).
     */
    onOpen: PropTypes.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: PropTypes.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: PropTypes.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: PropTypes.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: PropTypes.oneOf(["hours", "minutes", "seconds"]),
    /**
     * Force rendering in particular orientation.
     */
    orientation: PropTypes.oneOf(["landscape", "portrait"]),
    readOnly: PropTypes.bool,
    /**
     * If `true`, disable heavy animations.
     * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
     */
    reduceAnimations: PropTypes.bool,
    /**
     * The date used to generate the new value when both `value` and `defaultValue` are empty.
     * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
     */
    referenceDate: PropTypes.object,
    /**
     * The currently selected sections.
     * This prop accepts four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
     * 3. If `"all"` is provided, all the sections will be selected.
     * 4. If `null` is provided, no section will be selected.
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number]),
    /**
     * Disable specific time.
     * @template TDate
     * @param {TDate} value The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: PropTypes.func,
    /**
     * The props used for each component slot.
     * @default {}
     */
    slotProps: PropTypes.object,
    /**
     * Overridable component slots.
     * @default {}
     */
    slots: PropTypes.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
    /**
     * Choose which timezone to use for the value.
     * Example: "default", "system", "UTC", "America/New_York".
     * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
     * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
     * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
     */
    timezone: PropTypes.string,
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: PropTypes.object,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: PropTypes.oneOf(["hours", "minutes", "seconds"]),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be used.
     */
    viewRenderers: PropTypes.shape({
      hours: PropTypes.func,
      minutes: PropTypes.func,
      seconds: PropTypes.func
    }),
    /**
     * Available views.
     */
    views: PropTypes.arrayOf(PropTypes.oneOf(["hours", "minutes", "seconds"]).isRequired)
  };
  const _excluded = ["desktopModeMediaQuery"];
  const TimePicker = /* @__PURE__ */ reactExports.forwardRef(function TimePicker2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiTimePicker"
    });
    const {
      desktopModeMediaQuery = DEFAULT_DESKTOP_MODE_MEDIA_QUERY
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
    const isDesktop = useMediaQuery(desktopModeMediaQuery, {
      defaultMatches: true
    });
    if (isDesktop) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DesktopTimePicker, _extends$1({
        ref
      }, other));
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MobileTimePicker, _extends$1({
      ref
    }, other));
  });
  var weekOfYear = { exports: {} };
  (function(module, exports) {
    !function(e2, t2) {
      module.exports = t2();
    }(commonjsGlobal, function() {
      var e2 = "week", t2 = "year";
      return function(i, n2, r2) {
        var f2 = n2.prototype;
        f2.week = function(i2) {
          if (void 0 === i2 && (i2 = null), null !== i2)
            return this.add(7 * (i2 - this.week()), "day");
          var n3 = this.$locale().yearStart || 1;
          if (11 === this.month() && this.date() > 25) {
            var f3 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e2);
            if (f3.isBefore(s))
              return 1;
          }
          var a = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o = this.diff(a, e2, true);
          return o < 0 ? r2(this).startOf("week").week() : Math.ceil(o);
        }, f2.weeks = function(e3) {
          return void 0 === e3 && (e3 = null), this.week(e3);
        };
      };
    });
  })(weekOfYear);
  var weekOfYearExports = weekOfYear.exports;
  const weekOfYearPlugin = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
  var customParseFormat = { exports: {} };
  (function(module, exports) {
    !function(e2, t2) {
      module.exports = t2();
    }(commonjsGlobal, function() {
      var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d/, r2 = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e3) {
        return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
      };
      var f2 = function(e3) {
        return function(t3) {
          this[e3] = +t3;
        };
      }, h2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
        (this.zone || (this.zone = {})).offset = function(e4) {
          if (!e4)
            return 0;
          if ("Z" === e4)
            return 0;
          var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
          return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
        }(e3);
      }], u2 = function(e3) {
        var t3 = s[e3];
        return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
      }, d2 = function(e3, t3) {
        var n3, r3 = s.meridiem;
        if (r3) {
          for (var i2 = 1; i2 <= 24; i2 += 1)
            if (e3.indexOf(r3(i2, 0, t3)) > -1) {
              n3 = i2 > 12;
              break;
            }
        } else
          n3 = e3 === (t3 ? "pm" : "PM");
        return n3;
      }, c2 = { A: [o, function(e3) {
        this.afternoon = d2(e3, false);
      }], a: [o, function(e3) {
        this.afternoon = d2(e3, true);
      }], Q: [n2, function(e3) {
        this.month = 3 * (e3 - 1) + 1;
      }], S: [n2, function(e3) {
        this.milliseconds = 100 * +e3;
      }], SS: [r2, function(e3) {
        this.milliseconds = 10 * +e3;
      }], SSS: [/\d{3}/, function(e3) {
        this.milliseconds = +e3;
      }], s: [i, f2("seconds")], ss: [i, f2("seconds")], m: [i, f2("minutes")], mm: [i, f2("minutes")], H: [i, f2("hours")], h: [i, f2("hours")], HH: [i, f2("hours")], hh: [i, f2("hours")], D: [i, f2("day")], DD: [r2, f2("day")], Do: [o, function(e3) {
        var t3 = s.ordinal, n3 = e3.match(/\d+/);
        if (this.day = n3[0], t3)
          for (var r3 = 1; r3 <= 31; r3 += 1)
            t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
      }], w: [i, f2("week")], ww: [r2, f2("week")], M: [i, f2("month")], MM: [r2, f2("month")], MMM: [o, function(e3) {
        var t3 = u2("months"), n3 = (u2("monthsShort") || t3.map(function(e4) {
          return e4.slice(0, 3);
        })).indexOf(e3) + 1;
        if (n3 < 1)
          throw new Error();
        this.month = n3 % 12 || n3;
      }], MMMM: [o, function(e3) {
        var t3 = u2("months").indexOf(e3) + 1;
        if (t3 < 1)
          throw new Error();
        this.month = t3 % 12 || t3;
      }], Y: [/[+-]?\d+/, f2("year")], YY: [r2, function(e3) {
        this.year = a(e3);
      }], YYYY: [/\d{4}/, f2("year")], Z: h2, ZZ: h2 };
      function l2(n3) {
        var r3, i2;
        r3 = n3, i2 = s && s.formats;
        for (var o2 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
          var o3 = r4 && r4.toUpperCase();
          return n4 || i2[r4] || e2[r4] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
            return t4 || n5.slice(1);
          });
        })).match(t2), a2 = o2.length, f3 = 0; f3 < a2; f3 += 1) {
          var h3 = o2[f3], u3 = c2[h3], d3 = u3 && u3[0], l3 = u3 && u3[1];
          o2[f3] = l3 ? { regex: d3, parser: l3 } : h3.replace(/^\[|\]$/g, "");
        }
        return function(e3) {
          for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
            var i3 = o2[n4];
            if ("string" == typeof i3)
              r4 += i3.length;
            else {
              var s2 = i3.regex, f4 = i3.parser, h4 = e3.slice(r4), u4 = s2.exec(h4)[0];
              f4.call(t3, u4), e3 = e3.replace(u4, "");
            }
          }
          return function(e4) {
            var t4 = e4.afternoon;
            if (void 0 !== t4) {
              var n5 = e4.hours;
              t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
            }
          }(t3), t3;
        };
      }
      return function(e3, t3, n3) {
        n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (a = e3.parseTwoDigitYear);
        var r3 = t3.prototype, i2 = r3.parse;
        r3.parse = function(e4) {
          var t4 = e4.date, r4 = e4.utc, o2 = e4.args;
          this.$u = r4;
          var a2 = o2[1];
          if ("string" == typeof a2) {
            var f3 = true === o2[2], h3 = true === o2[3], u3 = f3 || h3, d3 = o2[2];
            h3 && (d3 = o2[2]), s = this.$locale(), !f3 && d3 && (s = n3.Ls[d3]), this.$d = function(e5, t5, n4, r5) {
              try {
                if (["x", "X"].indexOf(t5) > -1)
                  return new Date(("X" === t5 ? 1e3 : 1) * e5);
                var i3 = l2(t5)(e5), o3 = i3.year, s2 = i3.month, a3 = i3.day, f4 = i3.hours, h4 = i3.minutes, u4 = i3.seconds, d4 = i3.milliseconds, c4 = i3.zone, m3 = i3.week, M3 = /* @__PURE__ */ new Date(), Y2 = a3 || (o3 || s2 ? 1 : M3.getDate()), p2 = o3 || M3.getFullYear(), v2 = 0;
                o3 && !s2 || (v2 = s2 > 0 ? s2 - 1 : M3.getMonth());
                var D2, w2 = f4 || 0, g2 = h4 || 0, y2 = u4 || 0, L2 = d4 || 0;
                return c4 ? new Date(Date.UTC(p2, v2, Y2, w2, g2, y2, L2 + 60 * c4.offset * 1e3)) : n4 ? new Date(Date.UTC(p2, v2, Y2, w2, g2, y2, L2)) : (D2 = new Date(p2, v2, Y2, w2, g2, y2, L2), m3 && (D2 = r5(D2).week(m3).toDate()), D2);
              } catch (e6) {
                return /* @__PURE__ */ new Date("");
              }
            }(t4, a2, r4, n3), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
          } else if (a2 instanceof Array)
            for (var c3 = a2.length, m2 = 1; m2 <= c3; m2 += 1) {
              o2[1] = a2[m2 - 1];
              var M2 = n3.apply(this, o2);
              if (M2.isValid()) {
                this.$d = M2.$d, this.$L = M2.$L, this.init();
                break;
              }
              m2 === c3 && (this.$d = /* @__PURE__ */ new Date(""));
            }
          else
            i2.call(this, e4);
        };
      };
    });
  })(customParseFormat);
  var customParseFormatExports = customParseFormat.exports;
  const customParseFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
  var localizedFormat = { exports: {} };
  (function(module, exports) {
    !function(e2, t2) {
      module.exports = t2();
    }(commonjsGlobal, function() {
      var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
      return function(t2, o, n2) {
        var r2 = o.prototype, i = r2.format;
        n2.en.formats = e2, r2.format = function(t3) {
          void 0 === t3 && (t3 = "YYYY-MM-DDTHH:mm:ssZ");
          var o2 = this.$locale().formats, n3 = function(t4, o3) {
            return t4.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t5, n4, r3) {
              var i2 = r3 && r3.toUpperCase();
              return n4 || o3[r3] || e2[r3] || o3[i2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t6, o4) {
                return t6 || o4.slice(1);
              });
            });
          }(t3, void 0 === o2 ? {} : o2);
          return i.call(this, n3);
        };
      };
    });
  })(localizedFormat);
  var localizedFormatExports = localizedFormat.exports;
  const localizedFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(localizedFormatExports);
  var isBetween = { exports: {} };
  (function(module, exports) {
    !function(e2, i) {
      module.exports = i();
    }(commonjsGlobal, function() {
      return function(e2, i, t2) {
        i.prototype.isBetween = function(e3, i2, s, f2) {
          var n2 = t2(e3), o = t2(i2), r2 = "(" === (f2 = f2 || "()")[0], u2 = ")" === f2[1];
          return (r2 ? this.isAfter(n2, s) : !this.isBefore(n2, s)) && (u2 ? this.isBefore(o, s) : !this.isAfter(o, s)) || (r2 ? this.isBefore(n2, s) : !this.isAfter(n2, s)) && (u2 ? this.isAfter(o, s) : !this.isBefore(o, s));
        };
      };
    });
  })(isBetween);
  var isBetweenExports = isBetween.exports;
  const isBetweenPlugin = /* @__PURE__ */ getDefaultExportFromCjs(isBetweenExports);
  var advancedFormat = { exports: {} };
  (function(module, exports) {
    !function(e2, t2) {
      module.exports = t2();
    }(commonjsGlobal, function() {
      return function(e2, t2) {
        var r2 = t2.prototype, n2 = r2.format;
        r2.format = function(e3) {
          var t3 = this, r3 = this.$locale();
          if (!this.isValid())
            return n2.bind(this)(e3);
          var s = this.$utils(), a = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
            switch (e4) {
              case "Q":
                return Math.ceil((t3.$M + 1) / 3);
              case "Do":
                return r3.ordinal(t3.$D);
              case "gggg":
                return t3.weekYear();
              case "GGGG":
                return t3.isoWeekYear();
              case "wo":
                return r3.ordinal(t3.week(), "W");
              case "w":
              case "ww":
                return s.s(t3.week(), "w" === e4 ? 1 : 2, "0");
              case "W":
              case "WW":
                return s.s(t3.isoWeek(), "W" === e4 ? 1 : 2, "0");
              case "k":
              case "kk":
                return s.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e4 ? 1 : 2, "0");
              case "X":
                return Math.floor(t3.$d.getTime() / 1e3);
              case "x":
                return t3.$d.getTime();
              case "z":
                return "[" + t3.offsetName() + "]";
              case "zzz":
                return "[" + t3.offsetName("long") + "]";
              default:
                return e4;
            }
          });
          return n2.bind(this)(a);
        };
      };
    });
  })(advancedFormat);
  var advancedFormatExports = advancedFormat.exports;
  const advancedFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(advancedFormatExports);
  dayjs.extend(localizedFormatPlugin);
  dayjs.extend(weekOfYearPlugin);
  dayjs.extend(isBetweenPlugin);
  dayjs.extend(advancedFormatPlugin);
  const formatTokenMap = {
    // Year
    YY: "year",
    YYYY: {
      sectionType: "year",
      contentType: "digit",
      maxLength: 4
    },
    // Month
    M: {
      sectionType: "month",
      contentType: "digit",
      maxLength: 2
    },
    MM: "month",
    MMM: {
      sectionType: "month",
      contentType: "letter"
    },
    MMMM: {
      sectionType: "month",
      contentType: "letter"
    },
    // Day of the month
    D: {
      sectionType: "day",
      contentType: "digit",
      maxLength: 2
    },
    DD: "day",
    Do: {
      sectionType: "day",
      contentType: "digit-with-letter"
    },
    // Day of the week
    d: {
      sectionType: "weekDay",
      contentType: "digit",
      maxLength: 2
    },
    dd: {
      sectionType: "weekDay",
      contentType: "letter"
    },
    ddd: {
      sectionType: "weekDay",
      contentType: "letter"
    },
    dddd: {
      sectionType: "weekDay",
      contentType: "letter"
    },
    // Meridiem
    A: "meridiem",
    a: "meridiem",
    // Hours
    H: {
      sectionType: "hours",
      contentType: "digit",
      maxLength: 2
    },
    HH: "hours",
    h: {
      sectionType: "hours",
      contentType: "digit",
      maxLength: 2
    },
    hh: "hours",
    // Minutes
    m: {
      sectionType: "minutes",
      contentType: "digit",
      maxLength: 2
    },
    mm: "minutes",
    // Seconds
    s: {
      sectionType: "seconds",
      contentType: "digit",
      maxLength: 2
    },
    ss: "seconds"
  };
  const defaultFormats = {
    year: "YYYY",
    month: "MMMM",
    monthShort: "MMM",
    dayOfMonth: "D",
    dayOfMonthFull: "Do",
    weekday: "dddd",
    weekdayShort: "dd",
    hours24h: "HH",
    hours12h: "hh",
    meridiem: "A",
    minutes: "mm",
    seconds: "ss",
    fullDate: "ll",
    keyboardDate: "L",
    shortDate: "MMM D",
    normalDate: "D MMMM",
    normalDateWithWeekday: "ddd, MMM D",
    fullTime: "LT",
    fullTime12h: "hh:mm A",
    fullTime24h: "HH:mm",
    keyboardDateTime: "L LT",
    keyboardDateTime12h: "L hh:mm A",
    keyboardDateTime24h: "L HH:mm"
  };
  const MISSING_UTC_PLUGIN = ["Missing UTC plugin", "To be able to use UTC or timezones, you have to enable the `utc` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-utc"].join("\n");
  const MISSING_TIMEZONE_PLUGIN = ["Missing timezone plugin", "To be able to use timezones, you have to enable both the `utc` and the `timezone` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-timezone"].join("\n");
  const withLocale = (dayjs2, locale) => !locale ? dayjs2 : (...args) => dayjs2(...args).locale(locale);
  class AdapterDayjs {
    constructor({
      locale: _locale,
      formats
    } = {}) {
      this.isMUIAdapter = true;
      this.isTimezoneCompatible = true;
      this.lib = "dayjs";
      this.dayjs = void 0;
      this.locale = void 0;
      this.formats = void 0;
      this.escapedCharacters = {
        start: "[",
        end: "]"
      };
      this.formatTokenMap = formatTokenMap;
      this.setLocaleToValue = (value) => {
        const expectedLocale = this.getCurrentLocaleCode();
        if (expectedLocale === value.locale()) {
          return value;
        }
        return value.locale(expectedLocale);
      };
      this.hasUTCPlugin = () => typeof dayjs.utc !== "undefined";
      this.hasTimezonePlugin = () => typeof dayjs.tz !== "undefined";
      this.isSame = (value, comparing, comparisonTemplate) => {
        const comparingInValueTimezone = this.setTimezone(comparing, this.getTimezone(value));
        return value.format(comparisonTemplate) === comparingInValueTimezone.format(comparisonTemplate);
      };
      this.cleanTimezone = (timezone) => {
        switch (timezone) {
          case "default": {
            return void 0;
          }
          case "system": {
            return dayjs.tz.guess();
          }
          default: {
            return timezone;
          }
        }
      };
      this.createSystemDate = (value) => {
        if (this.hasUTCPlugin() && this.hasTimezonePlugin()) {
          const timezone = dayjs.tz.guess();
          if (timezone !== "UTC") {
            return dayjs.tz(value, timezone);
          }
          return dayjs(value);
        }
        return dayjs(value);
      };
      this.createUTCDate = (value) => {
        if (!this.hasUTCPlugin()) {
          throw new Error(MISSING_UTC_PLUGIN);
        }
        return dayjs.utc(value);
      };
      this.createTZDate = (value, timezone) => {
        if (!this.hasUTCPlugin()) {
          throw new Error(MISSING_UTC_PLUGIN);
        }
        if (!this.hasTimezonePlugin()) {
          throw new Error(MISSING_TIMEZONE_PLUGIN);
        }
        const keepLocalTime = value !== void 0 && !value.endsWith("Z");
        return dayjs(value).tz(this.cleanTimezone(timezone), keepLocalTime);
      };
      this.getLocaleFormats = () => {
        const locales = dayjs.Ls;
        const locale = this.locale || "en";
        let localeObject = locales[locale];
        if (localeObject === void 0) {
          localeObject = locales.en;
        }
        return localeObject.formats;
      };
      this.adjustOffset = (value) => {
        if (!this.hasTimezonePlugin()) {
          return value;
        }
        const timezone = this.getTimezone(value);
        if (timezone !== "UTC") {
          const fixedValue = value.tz(this.cleanTimezone(timezone), true);
          if (fixedValue.$offset === (value.$offset ?? 0)) {
            return value;
          }
          value.$offset = fixedValue.$offset;
        }
        return value;
      };
      this.date = (value, timezone = "default") => {
        if (value === null) {
          return null;
        }
        let parsedValue;
        if (timezone === "UTC") {
          parsedValue = this.createUTCDate(value);
        } else if (timezone === "system" || timezone === "default" && !this.hasTimezonePlugin()) {
          parsedValue = this.createSystemDate(value);
        } else {
          parsedValue = this.createTZDate(value, timezone);
        }
        if (this.locale === void 0) {
          return parsedValue;
        }
        return parsedValue.locale(this.locale);
      };
      this.getInvalidDate = () => dayjs(/* @__PURE__ */ new Date("Invalid date"));
      this.getTimezone = (value) => {
        var _a;
        if (this.hasTimezonePlugin()) {
          const zone = (_a = value.$x) == null ? void 0 : _a.$timezone;
          if (zone) {
            return zone;
          }
        }
        if (this.hasUTCPlugin() && value.isUTC()) {
          return "UTC";
        }
        return "system";
      };
      this.setTimezone = (value, timezone) => {
        if (this.getTimezone(value) === timezone) {
          return value;
        }
        if (timezone === "UTC") {
          if (!this.hasUTCPlugin()) {
            throw new Error(MISSING_UTC_PLUGIN);
          }
          return value.utc();
        }
        if (timezone === "system") {
          return value.local();
        }
        if (!this.hasTimezonePlugin()) {
          if (timezone === "default") {
            return value;
          }
          throw new Error(MISSING_TIMEZONE_PLUGIN);
        }
        return dayjs.tz(value, this.cleanTimezone(timezone));
      };
      this.toJsDate = (value) => {
        return value.toDate();
      };
      this.parse = (value, format) => {
        if (value === "") {
          return null;
        }
        return this.dayjs(value, format, this.locale, true);
      };
      this.getCurrentLocaleCode = () => {
        return this.locale || "en";
      };
      this.is12HourCycleInCurrentLocale = () => {
        return /A|a/.test(this.getLocaleFormats().LT || "");
      };
      this.expandFormat = (format) => {
        const localeFormats = this.getLocaleFormats();
        const t2 = (formatBis) => formatBis.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (_2, a, b2) => a || b2.slice(1));
        return format.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (_2, a, b2) => {
          const B2 = b2 && b2.toUpperCase();
          return a || localeFormats[b2] || t2(localeFormats[B2]);
        });
      };
      this.isValid = (value) => {
        if (value == null) {
          return false;
        }
        return value.isValid();
      };
      this.format = (value, formatKey) => {
        return this.formatByString(value, this.formats[formatKey]);
      };
      this.formatByString = (value, formatString) => {
        return this.dayjs(value).format(formatString);
      };
      this.formatNumber = (numberToFormat) => {
        return numberToFormat;
      };
      this.isEqual = (value, comparing) => {
        if (value === null && comparing === null) {
          return true;
        }
        if (value === null || comparing === null) {
          return false;
        }
        return value.toDate().getTime() === comparing.toDate().getTime();
      };
      this.isSameYear = (value, comparing) => {
        return this.isSame(value, comparing, "YYYY");
      };
      this.isSameMonth = (value, comparing) => {
        return this.isSame(value, comparing, "YYYY-MM");
      };
      this.isSameDay = (value, comparing) => {
        return this.isSame(value, comparing, "YYYY-MM-DD");
      };
      this.isSameHour = (value, comparing) => {
        return value.isSame(comparing, "hour");
      };
      this.isAfter = (value, comparing) => {
        return value > comparing;
      };
      this.isAfterYear = (value, comparing) => {
        if (!this.hasUTCPlugin()) {
          return value.isAfter(comparing, "year");
        }
        return !this.isSameYear(value, comparing) && value.utc() > comparing.utc();
      };
      this.isAfterDay = (value, comparing) => {
        if (!this.hasUTCPlugin()) {
          return value.isAfter(comparing, "day");
        }
        return !this.isSameDay(value, comparing) && value.utc() > comparing.utc();
      };
      this.isBefore = (value, comparing) => {
        return value < comparing;
      };
      this.isBeforeYear = (value, comparing) => {
        if (!this.hasUTCPlugin()) {
          return value.isBefore(comparing, "year");
        }
        return !this.isSameYear(value, comparing) && value.utc() < comparing.utc();
      };
      this.isBeforeDay = (value, comparing) => {
        if (!this.hasUTCPlugin()) {
          return value.isBefore(comparing, "day");
        }
        return !this.isSameDay(value, comparing) && value.utc() < comparing.utc();
      };
      this.isWithinRange = (value, [start2, end2]) => {
        return value >= start2 && value <= end2;
      };
      this.startOfYear = (value) => {
        return this.adjustOffset(value.startOf("year"));
      };
      this.startOfMonth = (value) => {
        return this.adjustOffset(value.startOf("month"));
      };
      this.startOfWeek = (value) => {
        return this.adjustOffset(value.startOf("week"));
      };
      this.startOfDay = (value) => {
        return this.adjustOffset(value.startOf("day"));
      };
      this.endOfYear = (value) => {
        return this.adjustOffset(value.endOf("year"));
      };
      this.endOfMonth = (value) => {
        return this.adjustOffset(value.endOf("month"));
      };
      this.endOfWeek = (value) => {
        return this.adjustOffset(value.endOf("week"));
      };
      this.endOfDay = (value) => {
        return this.adjustOffset(value.endOf("day"));
      };
      this.addYears = (value, amount) => {
        return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "year") : value.add(amount, "year"));
      };
      this.addMonths = (value, amount) => {
        return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "month") : value.add(amount, "month"));
      };
      this.addWeeks = (value, amount) => {
        return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "week") : value.add(amount, "week"));
      };
      this.addDays = (value, amount) => {
        return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "day") : value.add(amount, "day"));
      };
      this.addHours = (value, amount) => {
        return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "hour") : value.add(amount, "hour"));
      };
      this.addMinutes = (value, amount) => {
        return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "minute") : value.add(amount, "minute"));
      };
      this.addSeconds = (value, amount) => {
        return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "second") : value.add(amount, "second"));
      };
      this.getYear = (value) => {
        return value.year();
      };
      this.getMonth = (value) => {
        return value.month();
      };
      this.getDate = (value) => {
        return value.date();
      };
      this.getHours = (value) => {
        return value.hour();
      };
      this.getMinutes = (value) => {
        return value.minute();
      };
      this.getSeconds = (value) => {
        return value.second();
      };
      this.getMilliseconds = (value) => {
        return value.millisecond();
      };
      this.setYear = (value, year) => {
        return this.adjustOffset(value.set("year", year));
      };
      this.setMonth = (value, month) => {
        return this.adjustOffset(value.set("month", month));
      };
      this.setDate = (value, date) => {
        return this.adjustOffset(value.set("date", date));
      };
      this.setHours = (value, hours) => {
        return this.adjustOffset(value.set("hour", hours));
      };
      this.setMinutes = (value, minutes) => {
        return this.adjustOffset(value.set("minute", minutes));
      };
      this.setSeconds = (value, seconds) => {
        return this.adjustOffset(value.set("second", seconds));
      };
      this.setMilliseconds = (value, milliseconds) => {
        return this.adjustOffset(value.set("millisecond", milliseconds));
      };
      this.getDaysInMonth = (value) => {
        return value.daysInMonth();
      };
      this.getWeekArray = (value) => {
        const cleanValue = this.setLocaleToValue(value);
        const start2 = this.startOfWeek(this.startOfMonth(cleanValue));
        const end2 = this.endOfWeek(this.endOfMonth(cleanValue));
        let count2 = 0;
        let current = start2;
        const nestedWeeks = [];
        while (current < end2) {
          const weekNumber = Math.floor(count2 / 7);
          nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
          nestedWeeks[weekNumber].push(current);
          current = this.addDays(current, 1);
          count2 += 1;
        }
        return nestedWeeks;
      };
      this.getWeekNumber = (value) => {
        return value.week();
      };
      this.getYearRange = ([start2, end2]) => {
        const startDate = this.startOfYear(start2);
        const endDate = this.endOfYear(end2);
        const years = [];
        let current = startDate;
        while (this.isBefore(current, endDate)) {
          years.push(current);
          current = this.addYears(current, 1);
        }
        return years;
      };
      this.dayjs = withLocale(dayjs, _locale);
      this.locale = _locale;
      this.formats = _extends$1({}, defaultFormats, formats);
      dayjs.extend(customParseFormatPlugin);
    }
    getDayOfWeek(value) {
      return value.day() + 1;
    }
  }
  function ExtendDateButton() {
    return /* @__PURE__ */ React$1.createElement(
      "button",
      {
        onClick: (e2) => {
          e2.stopPropagation(), e2.preventDefault();
          $(".datepicker").datepicker(
            "option",
            "maxDate",
            /* @__PURE__ */ new Date(2545827584e3)
          );
        }
      },
      "Extend Date"
    );
  }
  function PopulateFilterButton() {
    return /* @__PURE__ */ React$1.createElement(
      "button",
      {
        onClick: (e2) => {
          e2.stopPropagation(), e2.preventDefault();
          const url = new URL(window.location.href);
          url.searchParams.set("group_filter_one", "94");
          url.searchParams.set("group_filter_two", "108");
          window.location.replace(url);
        }
      },
      "Populate Filters"
    );
  }
  function GodFeatures() {
    const { isGodMode } = getAppContext();
    reactExports.useEffect(() => {
      var _a, _b;
      const tmpDiv = document.createElement("span");
      reactDomExports.render(ExtendDateButton(), tmpDiv);
      (_b = (_a = document.getElementById("date_filter_from")) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.append(tmpDiv);
    }, []);
    reactExports.useEffect(() => {
      var _a, _b;
      if (!isGodMode)
        return;
      const tmpDiv = document.createElement("span");
      reactDomExports.render(PopulateFilterButton(), tmpDiv);
      (_b = (_a = document.getElementById("group_filter_two")) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.append(tmpDiv);
      return () => {
        var _a2, _b2;
        (_b2 = (_a2 = document.getElementById("group_filter_two")) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b2.removeChild(tmpDiv);
      };
    }, [isGodMode]);
    return null;
  }
  const AppContext = React$1.createContext(null);
  function getAppContext() {
    const context = reactExports.useContext(AppContext);
    if (context == null)
      throw new Error("Context used outside provider.");
    return context;
  }
  function App() {
    const setNext9 = (dt) => {
      return dt.hour(dt.hour() < 9 ? 9 : 33).minute(0).second(0).millisecond(0);
    };
    const defaultTime = dayjs();
    const changedTime = setNext9(defaultTime);
    const [isMacroEnabled, setMacroEnabled] = reactExports.useState(false);
    const [isGodMode, setGodMode] = reactExports.useState(true);
    const [macroTime, setMacroTime] = reactExports.useState(changedTime);
    reactExports.useEffect(() => {
      var _a;
      let el2 = (_a = document.getElementById("trigger")) == null ? void 0 : _a.style;
      if (isMacroEnabled) {
        if (el2) {
          el2.backgroundColor = "var(--green-6)";
        }
      } else {
        if (el2) {
          el2.backgroundColor = "white";
        }
      }
    }, [isMacroEnabled]);
    return /* @__PURE__ */ React$1.createElement("div", { className: "App IconButton" }, /* @__PURE__ */ React$1.createElement(LocalizationProvider, { dateAdapter: AdapterDayjs }, /* @__PURE__ */ React$1.createElement(
      AppContext.Provider,
      {
        value: {
          isMacroEnabled,
          setMacroEnabled,
          macroTime,
          setMacroTime,
          isGodMode,
          setGodMode
        }
      },
      /* @__PURE__ */ React$1.createElement(TimePicker, { value: macroTime }),
      /* @__PURE__ */ React$1.createElement(Macro, null),
      /* @__PURE__ */ React$1.createElement(GodFeatures, null),
      /* @__PURE__ */ React$1.createElement(Root, null, /* @__PURE__ */ React$1.createElement(Trigger, { asChild: true, id: "trigger" }, /* @__PURE__ */ React$1.createElement("div", { className: "IconButton" }, /* @__PURE__ */ React$1.createElement(HamburgerMenuIcon, null))), /* @__PURE__ */ React$1.createElement(Portal$1, null, /* @__PURE__ */ React$1.createElement(Overlay, { className: "DialogOverlay" }), /* @__PURE__ */ React$1.createElement(Content, { className: "DialogContent" }, /* @__PURE__ */ React$1.createElement(Title, { className: "DialogTitle" }), /* @__PURE__ */ React$1.createElement(Description, { className: "DialogDescription" }, /* @__PURE__ */ React$1.createElement(MacroDialogContent, null)))))
    )));
  }
  function log(...args) {
    console.log(
      "%cUserscript (React Mode):",
      "color: purple; font-weight: bold",
      ...args
    );
  }
  function addLocationChangeCallback(callback) {
    window.setTimeout(callback, 0);
    let oldHref = window.location.href;
    const body = document.querySelector("body");
    const observer = new MutationObserver((mutations) => {
      if (mutations.some(() => oldHref !== document.location.href)) {
        oldHref = document.location.href;
        callback();
      }
    });
    observer.observe(body, { childList: true, subtree: true });
    return observer;
  }
  async function awaitElement(selector) {
    const MAX_TRIES = 60;
    let tries = 0;
    return new Promise((resolve, reject) => {
      function probe() {
        tries++;
        return document.querySelector(selector);
      }
      function delayedProbe() {
        if (tries >= MAX_TRIES) {
          log("Can't find element with selector", selector);
          reject();
          return;
        }
        const elm = probe();
        if (elm) {
          resolve(elm);
          return;
        }
        window.setTimeout(delayedProbe, 250);
      }
      delayedProbe();
    });
  }
  log("React script has successfully started");
  async function main() {
    const body = await awaitElement("body > div");
    const container = document.createElement("div");
    body.appendChild(container);
    const root = createRoot(container);
    root.render(/* @__PURE__ */ React$1.createElement(App, null));
  }
  addLocationChangeCallback(() => {
    main().catch((e2) => {
      log(e2);
    });
  });
})();
;
(function(){
                    const el = document.createElement("style");
                    el.innerText = "@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\nbody {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\",\n    \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\",\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\ncode {\n  font-family: source-code-pro, Menlo, Monaco, Consolas, \"Courier New\",\n    monospace;\n}\n:root {\n  --black-a1: rgba(0, 0, 0, 0.05);\n  --black-a2: rgba(0, 0, 0, 0.1);\n  --black-a3: rgba(0, 0, 0, 0.15);\n  --black-a4: rgba(0, 0, 0, 0.2);\n  --black-a5: rgba(0, 0, 0, 0.3);\n  --black-a6: rgba(0, 0, 0, 0.4);\n  --black-a7: rgba(0, 0, 0, 0.5);\n  --black-a8: rgba(0, 0, 0, 0.6);\n  --black-a9: rgba(0, 0, 0, 0.7);\n  --black-a10: rgba(0, 0, 0, 0.8);\n  --black-a11: rgba(0, 0, 0, 0.9);\n  --black-a12: rgba(0, 0, 0, 0.95);\n}\n\n@supports (color: color(display-p3 1 1 1)) {\n  @media (color-gamut: p3) {\n    :root {\n      --black-a1: color(display-p3 0 0 0 / 0.05);\n      --black-a2: color(display-p3 0 0 0 / 0.1);\n      --black-a3: color(display-p3 0 0 0 / 0.15);\n      --black-a4: color(display-p3 0 0 0 / 0.2);\n      --black-a5: color(display-p3 0 0 0 / 0.3);\n      --black-a6: color(display-p3 0 0 0 / 0.4);\n      --black-a7: color(display-p3 0 0 0 / 0.5);\n      --black-a8: color(display-p3 0 0 0 / 0.6);\n      --black-a9: color(display-p3 0 0 0 / 0.7);\n      --black-a10: color(display-p3 0 0 0 / 0.8);\n      --black-a11: color(display-p3 0 0 0 / 0.9);\n      --black-a12: color(display-p3 0 0 0 / 0.95);\n    }\n  }\n}\n\n:root, .light, .light-theme {\n  --green-1: #fbfefc;\n  --green-2: #f4fbf6;\n  --green-3: #e6f6eb;\n  --green-4: #d6f1df;\n  --green-5: #c4e8d1;\n  --green-6: #adddc0;\n  --green-7: #8eceaa;\n  --green-8: #5bb98b;\n  --green-9: #30a46c;\n  --green-10: #2b9a66;\n  --green-11: #218358;\n  --green-12: #193b2d;\n}\n\n@supports (color: color(display-p3 1 1 1)) {\n  @media (color-gamut: p3) {\n    :root, .light, .light-theme {\n      --green-1: color(display-p3 0.986 0.996 0.989);\n      --green-2: color(display-p3 0.963 0.983 0.967);\n      --green-3: color(display-p3 0.913 0.964 0.925);\n      --green-4: color(display-p3 0.859 0.94 0.879);\n      --green-5: color(display-p3 0.796 0.907 0.826);\n      --green-6: color(display-p3 0.718 0.863 0.761);\n      --green-7: color(display-p3 0.61 0.801 0.675);\n      --green-8: color(display-p3 0.451 0.715 0.559);\n      --green-9: color(display-p3 0.332 0.634 0.442);\n      --green-10: color(display-p3 0.308 0.595 0.417);\n      --green-11: color(display-p3 0.19 0.5 0.32);\n      --green-12: color(display-p3 0.132 0.228 0.18);\n    }\n  }\n}\n\n:root, .light, .light-theme {\n  --red-1: #fffcfc;\n  --red-2: #fff7f7;\n  --red-3: #feebec;\n  --red-4: #ffdbdc;\n  --red-5: #ffcdce;\n  --red-6: #fdbdbe;\n  --red-7: #f4a9aa;\n  --red-8: #eb8e90;\n  --red-9: #e5484d;\n  --red-10: #dc3e42;\n  --red-11: #ce2c31;\n  --red-12: #641723;\n}\n\n@supports (color: color(display-p3 1 1 1)) {\n  @media (color-gamut: p3) {\n    :root, .light, .light-theme {\n      --red-1: color(display-p3 0.998 0.989 0.988);\n      --red-2: color(display-p3 0.995 0.971 0.971);\n      --red-3: color(display-p3 0.985 0.925 0.925);\n      --red-4: color(display-p3 0.999 0.866 0.866);\n      --red-5: color(display-p3 0.984 0.812 0.811);\n      --red-6: color(display-p3 0.955 0.751 0.749);\n      --red-7: color(display-p3 0.915 0.675 0.672);\n      --red-8: color(display-p3 0.872 0.575 0.572);\n      --red-9: color(display-p3 0.83 0.329 0.324);\n      --red-10: color(display-p3 0.798 0.294 0.285);\n      --red-11: color(display-p3 0.744 0.234 0.222);\n      --red-12: color(display-p3 0.36 0.115 0.143);\n    }\n  }\n}\n\n:root, .light, .light-theme {\n  --mauve-1: #fdfcfd;\n  --mauve-2: #faf9fb;\n  --mauve-3: #f2eff3;\n  --mauve-4: #eae7ec;\n  --mauve-5: #e3dfe6;\n  --mauve-6: #dbd8e0;\n  --mauve-7: #d0cdd7;\n  --mauve-8: #bcbac7;\n  --mauve-9: #8e8c99;\n  --mauve-10: #84828e;\n  --mauve-11: #65636d;\n  --mauve-12: #211f26;\n}\n\n@supports (color: color(display-p3 1 1 1)) {\n  @media (color-gamut: p3) {\n    :root, .light, .light-theme {\n      --mauve-1: color(display-p3 0.991 0.988 0.992);\n      --mauve-2: color(display-p3 0.98 0.976 0.984);\n      --mauve-3: color(display-p3 0.946 0.938 0.952);\n      --mauve-4: color(display-p3 0.915 0.906 0.925);\n      --mauve-5: color(display-p3 0.886 0.876 0.901);\n      --mauve-6: color(display-p3 0.856 0.846 0.875);\n      --mauve-7: color(display-p3 0.814 0.804 0.84);\n      --mauve-8: color(display-p3 0.735 0.728 0.777);\n      --mauve-9: color(display-p3 0.555 0.549 0.596);\n      --mauve-10: color(display-p3 0.514 0.508 0.552);\n      --mauve-11: color(display-p3 0.395 0.388 0.424);\n      --mauve-12: color(display-p3 0.128 0.122 0.147);\n    }\n  }\n}\n\n:root, .light, .light-theme {\n  --violet-1: #fdfcfe;\n  --violet-2: #faf8ff;\n  --violet-3: #f4f0fe;\n  --violet-4: #ebe4ff;\n  --violet-5: #e1d9ff;\n  --violet-6: #d4cafe;\n  --violet-7: #c2b5f5;\n  --violet-8: #aa99ec;\n  --violet-9: #6e56cf;\n  --violet-10: #654dc4;\n  --violet-11: #6550b9;\n  --violet-12: #2f265f;\n}\n\n@supports (color: color(display-p3 1 1 1)) {\n  @media (color-gamut: p3) {\n    :root, .light, .light-theme {\n      --violet-1: color(display-p3 0.991 0.988 0.995);\n      --violet-2: color(display-p3 0.978 0.974 0.998);\n      --violet-3: color(display-p3 0.953 0.943 0.993);\n      --violet-4: color(display-p3 0.916 0.897 1);\n      --violet-5: color(display-p3 0.876 0.851 1);\n      --violet-6: color(display-p3 0.825 0.793 0.981);\n      --violet-7: color(display-p3 0.752 0.712 0.943);\n      --violet-8: color(display-p3 0.654 0.602 0.902);\n      --violet-9: color(display-p3 0.417 0.341 0.784);\n      --violet-10: color(display-p3 0.381 0.306 0.741);\n      --violet-11: color(display-p3 0.383 0.317 0.702);\n      --violet-12: color(display-p3 0.179 0.15 0.359);\n    }\n  }\n}\n\n.App {}\n\n.IconButton {\n    position: fixed;\n    bottom: 15px;\n    right: 15px;\n    font-family: inherit;\n    border-radius: 100%;\n    height: 50px;\n    width: 50px;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    color: var(--violet-11);\n    background-color: white;\n    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);\n    cursor: pointer;\n}\n\n.App-logo {\n    height: 40vmin;\n}\n\n.App-header {\n    background-color: #282c34;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    font-size: calc(10px + 2vmin);\n    color: white;\n}\n\n.App-link {\n    text-decoration: underline;\n}\n\n.DialogOverlay {\n    background-color: var(--black-a9);\n    position: fixed;\n    inset: 0;\n    animation: overlayShow 150ms cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n.DialogContent {\n    background-color: white;\n    border-radius: 6px;\n    box-shadow: hsl(206 22% 7% / 35%) 0px 10px 38px -10px, hsl(206 22% 7% / 20%) 0px 10px 20px -15px;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    width: 90vw;\n    max-width: 450px;\n    max-height: 85vh;\n    padding: 25px;\n    animation: contentShow 150ms cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n.DialogTitle {\n    margin: 0;\n    font-weight: 500;\n    color: var(--mauve-12);\n    font-size: 17px;\n}\n\n.DialogDescription {\n    margin: 10px 0 20px;\n    color: var(--mauve-11);\n    font-size: 15px;\n    line-height: 1.5;\n}\n\n.Button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    border-radius: 4px;\n    padding: 0 15px;\n    font-size: 15px;\n    line-height: 1;\n    font-weight: 500;\n    height: 35px;\n    border: 0;\n}\n\n.Button.green {\n    background-color: var(--green-4);\n    color: var(--green-11);\n}\n\n:root {\n    font-size: 100%;\n}:root {\n  --black-a1: rgba(0, 0, 0, 0.05);\n  --black-a2: rgba(0, 0, 0, 0.1);\n  --black-a3: rgba(0, 0, 0, 0.15);\n  --black-a4: rgba(0, 0, 0, 0.2);\n  --black-a5: rgba(0, 0, 0, 0.3);\n  --black-a6: rgba(0, 0, 0, 0.4);\n  --black-a7: rgba(0, 0, 0, 0.5);\n  --black-a8: rgba(0, 0, 0, 0.6);\n  --black-a9: rgba(0, 0, 0, 0.7);\n  --black-a10: rgba(0, 0, 0, 0.8);\n  --black-a11: rgba(0, 0, 0, 0.9);\n  --black-a12: rgba(0, 0, 0, 0.95);\n}\n\n@supports (color: color(display-p3 1 1 1)) {\n  @media (color-gamut: p3) {\n    :root {\n      --black-a1: color(display-p3 0 0 0 / 0.05);\n      --black-a2: color(display-p3 0 0 0 / 0.1);\n      --black-a3: color(display-p3 0 0 0 / 0.15);\n      --black-a4: color(display-p3 0 0 0 / 0.2);\n      --black-a5: color(display-p3 0 0 0 / 0.3);\n      --black-a6: color(display-p3 0 0 0 / 0.4);\n      --black-a7: color(display-p3 0 0 0 / 0.5);\n      --black-a8: color(display-p3 0 0 0 / 0.6);\n      --black-a9: color(display-p3 0 0 0 / 0.7);\n      --black-a10: color(display-p3 0 0 0 / 0.8);\n      --black-a11: color(display-p3 0 0 0 / 0.9);\n      --black-a12: color(display-p3 0 0 0 / 0.95);\n    }\n  }\n}\n\n.SwitchRoot {\r\n  width: 42px;\r\n  height: 25px;\r\n  background-color: var(--black-a9);\r\n  border-radius: 9999px;\r\n  position: relative;\r\n  box-shadow: 0 2px 10px var(--black-a7);\r\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\r\n}\n\n.SwitchRoot:focus {\r\n  box-shadow: 0 0 0 2px black;\r\n}\n\n.SwitchRoot[data-state='checked'] {\r\n  background-color: black;\r\n}\n\n.SwitchThumb {\r\n  display: block;\r\n  width: 21px;\r\n  height: 21px;\r\n  background-color: white;\r\n  border-radius: 9999px;\r\n  box-shadow: 0 2px 2px var(--black-a7);\r\n  transition: transform 100ms;\r\n  transform: translateX(2px);\r\n  will-change: transform;\r\n}\n\n.SwitchThumb[data-state='checked'] {\r\n  transform: translateX(19px);\r\n}";
                    el.type = "text/css";
                    document.head.appendChild(el);
                })();